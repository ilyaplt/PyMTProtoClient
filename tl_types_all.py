from tl_base import *

class boolFalse(TLObject):
    ID = 0xbc799737
    def __init__(self):
        pass
    def __str__(self):
        return 'boolFalse'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class boolTrue(TLObject):
    ID = 0x997275b5
    def __init__(self):
        pass
    def __str__(self):
        return 'boolTrue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_logOut(TLObject):
    ID = 0x5717da40
    def __init__(self):
        pass
    def __str__(self):
        return 'auth_logOut'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_resetAuthorizations(TLObject):
    ID = 0x9fab0d1a
    def __init__(self):
        pass
    def __str__(self):
        return 'auth_resetAuthorizations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_bindTempAuthKey(TLObject):
    ID = 0xcdd42a05
    def __init__(self, perm_auth_key_id = None, nonce = None, expires_at = None, encrypted_message = None):
        self.perm_auth_key_id = perm_auth_key_id
        self.nonce = nonce
        self.expires_at = expires_at
        self.encrypted_message = encrypted_message
    def __str__(self):
        return 'auth_bindTempAuthKey'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.perm_auth_key_id)
        stream.pack_int64(self.nonce)
        stream.pack_int32(self.expires_at)
        stream.pack_string(self.encrypted_message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.perm_auth_key_id = data.unpack_int64()
        self.nonce = data.unpack_int64()
        self.expires_at = data.unpack_int32()
        self.encrypted_message = data.unpack_string()
        return self

class auth_cancelCode(TLObject):
    ID = 0x1f040578
    def __init__(self, phone_number = None, phone_code_hash = None):
        self.phone_number = phone_number
        self.phone_code_hash = phone_code_hash
    def __str__(self):
        return 'auth_cancelCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.phone_code_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.phone_code_hash = data.unpack_string()
        return self

class auth_dropTempAuthKeys(TLObject):
    ID = 0x8e48a188
    def __init__(self, except_auth_keys = None):
        self.except_auth_keys = except_auth_keys
    def __str__(self):
        return 'auth_dropTempAuthKeys'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.except_auth_keys))
        for vec_k_2 in self.except_auth_keys:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.except_auth_keys = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.except_auth_keys.append(data.unpack_int64())
        return self

class auth_checkRecoveryPassword(TLObject):
    ID = 0xd36bf79
    def __init__(self, code = None):
        self.code = code
    def __str__(self):
        return 'auth_checkRecoveryPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.code = data.unpack_string()
        return self

class account_registerDevice(TLObject):
    ID = 0xec86017a
    def __init__(self, flags = None, no_muted = None, token_type = None, token = None, app_sandbox = None, secret = None, other_uids = None):
        self.flags = flags
        self.no_muted = no_muted
        self.token_type = token_type
        self.token = token
        self.app_sandbox = app_sandbox
        self.secret = secret
        self.other_uids = other_uids
    def __str__(self):
        return 'account_registerDevice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_muted:
            flags |= (1 << 0)
        stream.pack_int32(self.token_type)
        stream.pack_string(self.token)
        stream.pack_bytes(self.app_sandbox.write())
        stream.pack_string(self.secret)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.other_uids))
        for vec_k_2 in self.other_uids:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.no_muted = True
        self.token_type = data.unpack_int32()
        self.token = data.unpack_string()
        self.app_sandbox = Bool()
        self.app_sandbox = self.app_sandbox.read(data)
        self.secret = data.unpack_string()
        self.other_uids = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.other_uids.append(data.unpack_int64())
        return self

class account_unregisterDevice(TLObject):
    ID = 0x6a0d3206
    def __init__(self, token_type = None, token = None, other_uids = None):
        self.token_type = token_type
        self.token = token
        self.other_uids = other_uids
    def __str__(self):
        return 'account_unregisterDevice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.token_type)
        stream.pack_string(self.token)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.other_uids))
        for vec_k_2 in self.other_uids:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.token_type = data.unpack_int32()
        self.token = data.unpack_string()
        self.other_uids = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.other_uids.append(data.unpack_int64())
        return self

class account_updateNotifySettings(TLObject):
    ID = 0x84be5b93
    def __init__(self, peer = None, settings = None):
        self.peer = peer
        self.settings = settings
    def __str__(self):
        return 'account_updateNotifySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputNotifyPeer()
        self.peer = self.peer.read(data)
        self.settings = InputPeerNotifySettings()
        self.settings = self.settings.read(data)
        return self

class account_resetNotifySettings(TLObject):
    ID = 0xdb7e1747
    def __init__(self):
        pass
    def __str__(self):
        return 'account_resetNotifySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_updateStatus(TLObject):
    ID = 0x6628562c
    def __init__(self, offline = None):
        self.offline = offline
    def __str__(self):
        return 'account_updateStatus'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.offline.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offline = Bool()
        self.offline = self.offline.read(data)
        return self

class account_reportPeer(TLObject):
    ID = 0xc5ba3d86
    def __init__(self, peer = None, reason = None, message = None):
        self.peer = peer
        self.reason = reason
        self.message = message
    def __str__(self):
        return 'account_reportPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.reason.write())
        stream.pack_string(self.message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.reason = ReportReason()
        self.reason = self.reason.read(data)
        self.message = data.unpack_string()
        return self

class account_checkUsername(TLObject):
    ID = 0x2714d86c
    def __init__(self, username = None):
        self.username = username
    def __str__(self):
        return 'account_checkUsername'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.username)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.username = data.unpack_string()
        return self

class account_deleteAccount(TLObject):
    ID = 0x418d4e0b
    def __init__(self, reason = None):
        self.reason = reason
    def __str__(self):
        return 'account_deleteAccount'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.reason)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.reason = data.unpack_string()
        return self

class account_setAccountTTL(TLObject):
    ID = 0x2442485e
    def __init__(self, ttl = None):
        self.ttl = ttl
    def __str__(self):
        return 'account_setAccountTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.ttl.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.ttl = AccountDaysTTL()
        self.ttl = self.ttl.read(data)
        return self

class account_updateDeviceLocked(TLObject):
    ID = 0x38df3532
    def __init__(self, period = None):
        self.period = period
    def __str__(self):
        return 'account_updateDeviceLocked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.period)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.period = data.unpack_int32()
        return self

class account_resetAuthorization(TLObject):
    ID = 0xdf77f3bc
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'account_resetAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class account_updatePasswordSettings(TLObject):
    ID = 0xa59b102f
    def __init__(self, password = None, new_settings = None):
        self.password = password
        self.new_settings = new_settings
    def __str__(self):
        return 'account_updatePasswordSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.password.write())
        stream.pack_bytes(self.new_settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.password = InputCheckPasswordSRP()
        self.password = self.password.read(data)
        self.new_settings = account_PasswordInputSettings()
        self.new_settings = self.new_settings.read(data)
        return self

class account_confirmPhone(TLObject):
    ID = 0x5f2178c3
    def __init__(self, phone_code_hash = None, phone_code = None):
        self.phone_code_hash = phone_code_hash
        self.phone_code = phone_code
    def __str__(self):
        return 'account_confirmPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_code_hash)
        stream.pack_string(self.phone_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_code_hash = data.unpack_string()
        self.phone_code = data.unpack_string()
        return self

class account_resetWebAuthorization(TLObject):
    ID = 0x2d01b9ef
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'account_resetWebAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class account_resetWebAuthorizations(TLObject):
    ID = 0x682d2594
    def __init__(self):
        pass
    def __str__(self):
        return 'account_resetWebAuthorizations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_deleteSecureValue(TLObject):
    ID = 0xb880bc4b
    def __init__(self, types = None):
        self.types = types
    def __str__(self):
        return 'account_deleteSecureValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.types))
        for vec_k_2 in self.types:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.types = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureValueType()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.types.append(elem_of_1_vec)
        return self

class account_acceptAuthorization(TLObject):
    ID = 0xf3ed4c73
    def __init__(self, bot_id = None, scope = None, public_key = None, value_hashes = None, credentials = None):
        self.bot_id = bot_id
        self.scope = scope
        self.public_key = public_key
        self.value_hashes = value_hashes
        self.credentials = credentials
    def __str__(self):
        return 'account_acceptAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.bot_id)
        stream.pack_string(self.scope)
        stream.pack_string(self.public_key)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.value_hashes))
        for vec_k_2 in self.value_hashes:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_bytes(self.credentials.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.bot_id = data.unpack_int64()
        self.scope = data.unpack_string()
        self.public_key = data.unpack_string()
        self.value_hashes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureValueHash()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.value_hashes.append(elem_of_1_vec)
        self.credentials = SecureCredentialsEncrypted()
        self.credentials = self.credentials.read(data)
        return self

class account_verifyPhone(TLObject):
    ID = 0x4dd3a7f6
    def __init__(self, phone_number = None, phone_code_hash = None, phone_code = None):
        self.phone_number = phone_number
        self.phone_code_hash = phone_code_hash
        self.phone_code = phone_code
    def __str__(self):
        return 'account_verifyPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.phone_code_hash)
        stream.pack_string(self.phone_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.phone_code_hash = data.unpack_string()
        self.phone_code = data.unpack_string()
        return self

class account_verifyEmail(TLObject):
    ID = 0xecba39db
    def __init__(self, email = None, code = None):
        self.email = email
        self.code = code
    def __str__(self):
        return 'account_verifyEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.email)
        stream.pack_string(self.code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.email = data.unpack_string()
        self.code = data.unpack_string()
        return self

class account_finishTakeoutSession(TLObject):
    ID = 0x1d2652ee
    def __init__(self, flags = None, success = None):
        self.flags = flags
        self.success = success
    def __str__(self):
        return 'account_finishTakeoutSession'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.success:
            flags |= (1 << 0)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.success = True
        return self

class account_confirmPasswordEmail(TLObject):
    ID = 0x8fdf1920
    def __init__(self, code = None):
        self.code = code
    def __str__(self):
        return 'account_confirmPasswordEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.code = data.unpack_string()
        return self

class account_resendPasswordEmail(TLObject):
    ID = 0x7a7f2a15
    def __init__(self):
        pass
    def __str__(self):
        return 'account_resendPasswordEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_cancelPasswordEmail(TLObject):
    ID = 0xc1cbd5b6
    def __init__(self):
        pass
    def __str__(self):
        return 'account_cancelPasswordEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_getContactSignUpNotification(TLObject):
    ID = 0x9f07c728
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getContactSignUpNotification'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_setContactSignUpNotification(TLObject):
    ID = 0xcff43f61
    def __init__(self, silent = None):
        self.silent = silent
    def __str__(self):
        return 'account_setContactSignUpNotification'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.silent.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.silent = Bool()
        self.silent = self.silent.read(data)
        return self

class account_saveWallPaper(TLObject):
    ID = 0x6c5a5b37
    def __init__(self, wallpaper = None, unsave = None, settings = None):
        self.wallpaper = wallpaper
        self.unsave = unsave
        self.settings = settings
    def __str__(self):
        return 'account_saveWallPaper'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.wallpaper.write())
        stream.pack_bytes(self.unsave.write())
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.wallpaper = InputWallPaper()
        self.wallpaper = self.wallpaper.read(data)
        self.unsave = Bool()
        self.unsave = self.unsave.read(data)
        self.settings = WallPaperSettings()
        self.settings = self.settings.read(data)
        return self

class account_installWallPaper(TLObject):
    ID = 0xfeed5769
    def __init__(self, wallpaper = None, settings = None):
        self.wallpaper = wallpaper
        self.settings = settings
    def __str__(self):
        return 'account_installWallPaper'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.wallpaper.write())
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.wallpaper = InputWallPaper()
        self.wallpaper = self.wallpaper.read(data)
        self.settings = WallPaperSettings()
        self.settings = self.settings.read(data)
        return self

class account_resetWallPapers(TLObject):
    ID = 0xbb3b9804
    def __init__(self):
        pass
    def __str__(self):
        return 'account_resetWallPapers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_saveAutoDownloadSettings(TLObject):
    ID = 0x76f36233
    def __init__(self, flags = None, low = None, high = None, settings = None):
        self.flags = flags
        self.low = low
        self.high = high
        self.settings = settings
    def __str__(self):
        return 'account_saveAutoDownloadSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.low:
            flags |= (1 << 0)
        if self.high:
            flags |= (1 << 1)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.low = True
        if flags.check_bit(1):
            self.high = True
        self.settings = AutoDownloadSettings()
        self.settings = self.settings.read(data)
        return self

class account_saveTheme(TLObject):
    ID = 0xf257106c
    def __init__(self, theme = None, unsave = None):
        self.theme = theme
        self.unsave = unsave
    def __str__(self):
        return 'account_saveTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.theme.write())
        stream.pack_bytes(self.unsave.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.theme = InputTheme()
        self.theme = self.theme.read(data)
        self.unsave = Bool()
        self.unsave = self.unsave.read(data)
        return self

class account_installTheme(TLObject):
    ID = 0x7ae43737
    def __init__(self, flags = None, dark = None, format = None, theme = None):
        self.flags = flags
        self.dark = dark
        self.format = format
        self.theme = theme
    def __str__(self):
        return 'account_installTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.dark:
            flags |= (1 << 0)
        if self.format:
            flags |= (1 << 1)
            stream.pack_string(self.format)
        if self.theme:
            flags |= (1 << 1)
            stream.pack_bytes(self.theme.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.dark = True
        if flags.check_bit(1):
            self.format = data.unpack_string()
        if flags.check_bit(1):
            self.theme = InputTheme()
            self.theme = self.theme.read(data)
        return self

class account_setContentSettings(TLObject):
    ID = 0xb574b16b
    def __init__(self, flags = None, sensitive_enabled = None):
        self.flags = flags
        self.sensitive_enabled = sensitive_enabled
    def __str__(self):
        return 'account_setContentSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.sensitive_enabled:
            flags |= (1 << 0)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.sensitive_enabled = True
        return self

class account_reportProfilePhoto(TLObject):
    ID = 0xfa8cc6f5
    def __init__(self, peer = None, photo_id = None, reason = None, message = None):
        self.peer = peer
        self.photo_id = photo_id
        self.reason = reason
        self.message = message
    def __str__(self):
        return 'account_reportProfilePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.photo_id.write())
        stream.pack_bytes(self.reason.write())
        stream.pack_string(self.message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.photo_id = InputPhoto()
        self.photo_id = self.photo_id.read(data)
        self.reason = ReportReason()
        self.reason = self.reason.read(data)
        self.message = data.unpack_string()
        return self

class account_declinePasswordReset(TLObject):
    ID = 0x4c9409f6
    def __init__(self):
        pass
    def __str__(self):
        return 'account_declinePasswordReset'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class users_setSecureValueErrors(TLObject):
    ID = 0x90c894b5
    def __init__(self, id = None, errors = None):
        self.id = id
        self.errors = errors
    def __str__(self):
        return 'users_setSecureValueErrors'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.errors))
        for vec_k_2 in self.errors:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputUser()
        self.id = self.id.read(data)
        self.errors = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureValueError()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.errors.append(elem_of_1_vec)
        return self

class contacts_deleteByPhones(TLObject):
    ID = 0x1013fd9e
    def __init__(self, phones = None):
        self.phones = phones
    def __str__(self):
        return 'contacts_deleteByPhones'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.phones))
        for vec_k_2 in self.phones:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phones = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.phones.append(data.unpack_string())
        return self

class contacts_block(TLObject):
    ID = 0x68cc1411
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'contacts_block'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputPeer()
        self.id = self.id.read(data)
        return self

class contacts_unblock(TLObject):
    ID = 0xbea65d50
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'contacts_unblock'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputPeer()
        self.id = self.id.read(data)
        return self

class contacts_resetTopPeerRating(TLObject):
    ID = 0x1ae373ac
    def __init__(self, category = None, peer = None):
        self.category = category
        self.peer = peer
    def __str__(self):
        return 'contacts_resetTopPeerRating'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.category.write())
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.category = TopPeerCategory()
        self.category = self.category.read(data)
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class contacts_resetSaved(TLObject):
    ID = 0x879537f1
    def __init__(self):
        pass
    def __str__(self):
        return 'contacts_resetSaved'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class contacts_toggleTopPeers(TLObject):
    ID = 0x8514bdda
    def __init__(self, enabled = None):
        self.enabled = enabled
    def __str__(self):
        return 'contacts_toggleTopPeers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.enabled.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.enabled = Bool()
        self.enabled = self.enabled.read(data)
        return self

class messages_setTyping(TLObject):
    ID = 0x58943ee2
    def __init__(self, flags = None, peer = None, top_msg_id = None, action = None):
        self.flags = flags
        self.peer = peer
        self.top_msg_id = top_msg_id
        self.action = action
    def __str__(self):
        return 'messages_setTyping'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        flags = 0x0
        if self.top_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.top_msg_id)
        stream.pack_bytes(self.action.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.top_msg_id = data.unpack_int32()
        self.action = SendMessageAction()
        self.action = self.action.read(data)
        return self

class messages_reportSpam(TLObject):
    ID = 0xcf1592db
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_reportSpam'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class messages_report(TLObject):
    ID = 0x8953ab4e
    def __init__(self, peer = None, id = None, reason = None, message = None):
        self.peer = peer
        self.id = id
        self.reason = reason
        self.message = message
    def __str__(self):
        return 'messages_report'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        stream.pack_bytes(self.reason.write())
        stream.pack_string(self.message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        self.reason = ReportReason()
        self.reason = self.reason.read(data)
        self.message = data.unpack_string()
        return self

class messages_discardEncryption(TLObject):
    ID = 0xf393aea0
    def __init__(self, flags = None, delete_history = None, chat_id = None):
        self.flags = flags
        self.delete_history = delete_history
        self.chat_id = chat_id
    def __str__(self):
        return 'messages_discardEncryption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.delete_history:
            flags |= (1 << 0)
        stream.pack_int32(self.chat_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.delete_history = True
        self.chat_id = data.unpack_int32()
        return self

class messages_setEncryptedTyping(TLObject):
    ID = 0x791451ed
    def __init__(self, peer = None, typing = None):
        self.peer = peer
        self.typing = typing
    def __str__(self):
        return 'messages_setEncryptedTyping'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.typing.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.typing = Bool()
        self.typing = self.typing.read(data)
        return self

class messages_readEncryptedHistory(TLObject):
    ID = 0x7f4b690a
    def __init__(self, peer = None, max_date = None):
        self.peer = peer
        self.max_date = max_date
    def __str__(self):
        return 'messages_readEncryptedHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.max_date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.max_date = data.unpack_int32()
        return self

class messages_reportEncryptedSpam(TLObject):
    ID = 0x4b0c8c0f
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_reportEncryptedSpam'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        return self

class messages_uninstallStickerSet(TLObject):
    ID = 0xf96e55de
    def __init__(self, stickerset = None):
        self.stickerset = stickerset
    def __str__(self):
        return 'messages_uninstallStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        return self

class messages_editChatAdmin(TLObject):
    ID = 0xa85bd1c2
    def __init__(self, chat_id = None, user_id = None, is_admin = None):
        self.chat_id = chat_id
        self.user_id = user_id
        self.is_admin = is_admin
    def __str__(self):
        return 'messages_editChatAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_bytes(self.user_id.write())
        stream.pack_bytes(self.is_admin.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.is_admin = Bool()
        self.is_admin = self.is_admin.read(data)
        return self

class messages_reorderStickerSets(TLObject):
    ID = 0x78337739
    def __init__(self, flags = None, masks = None, order = None):
        self.flags = flags
        self.masks = masks
        self.order = order
    def __str__(self):
        return 'messages_reorderStickerSets'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.masks:
            flags |= (1 << 0)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.order))
        for vec_k_2 in self.order:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.masks = True
        self.order = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.order.append(data.unpack_int64())
        return self

class messages_saveGif(TLObject):
    ID = 0x327a30cb
    def __init__(self, id = None, unsave = None):
        self.id = id
        self.unsave = unsave
    def __str__(self):
        return 'messages_saveGif'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        stream.pack_bytes(self.unsave.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputDocument()
        self.id = self.id.read(data)
        self.unsave = Bool()
        self.unsave = self.unsave.read(data)
        return self

class messages_setInlineBotResults(TLObject):
    ID = 0xeb5ea206
    def __init__(self, flags = None, gallery = None, private = None, query_id = None, results = None, cache_time = None, next_offset = None, switch_pm = None):
        self.flags = flags
        self.gallery = gallery
        self.private = private
        self.query_id = query_id
        self.results = results
        self.cache_time = cache_time
        self.next_offset = next_offset
        self.switch_pm = switch_pm
    def __str__(self):
        return 'messages_setInlineBotResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.gallery:
            flags |= (1 << 0)
        if self.private:
            flags |= (1 << 1)
        stream.pack_int64(self.query_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.results))
        for vec_k_2 in self.results:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.cache_time)
        if self.next_offset:
            flags |= (1 << 2)
            stream.pack_string(self.next_offset)
        if self.switch_pm:
            flags |= (1 << 3)
            stream.pack_bytes(self.switch_pm.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.gallery = True
        if flags.check_bit(1):
            self.private = True
        self.query_id = data.unpack_int64()
        self.results = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputBotInlineResult()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.results.append(elem_of_1_vec)
        self.cache_time = data.unpack_int32()
        if flags.check_bit(2):
            self.next_offset = data.unpack_string()
        if flags.check_bit(3):
            self.switch_pm = InlineBotSwitchPM()
            self.switch_pm = self.switch_pm.read(data)
        return self

class messages_editInlineBotMessage(TLObject):
    ID = 0x83557dba
    def __init__(self, flags = None, no_webpage = None, id = None, message = None, media = None, reply_markup = None, entities = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.id = id
        self.message = message
        self.media = media
        self.reply_markup = reply_markup
        self.entities = entities
    def __str__(self):
        return 'messages_editInlineBotMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 1)
        stream.pack_bytes(self.id.write())
        if self.message:
            flags |= (1 << 11)
            stream.pack_string(self.message)
        if self.media:
            flags |= (1 << 14)
            stream.pack_bytes(self.media.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.no_webpage = True
        self.id = InputBotInlineMessageID()
        self.id = self.id.read(data)
        if flags.check_bit(11):
            self.message = data.unpack_string()
        if flags.check_bit(14):
            self.media = InputMedia()
            self.media = self.media.read(data)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        return self

class messages_setBotCallbackAnswer(TLObject):
    ID = 0xd58f130a
    def __init__(self, flags = None, alert = None, query_id = None, message = None, url = None, cache_time = None):
        self.flags = flags
        self.alert = alert
        self.query_id = query_id
        self.message = message
        self.url = url
        self.cache_time = cache_time
    def __str__(self):
        return 'messages_setBotCallbackAnswer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.alert:
            flags |= (1 << 1)
        stream.pack_int64(self.query_id)
        if self.message:
            flags |= (1 << 0)
            stream.pack_string(self.message)
        if self.url:
            flags |= (1 << 2)
            stream.pack_string(self.url)
        stream.pack_int32(self.cache_time)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.alert = True
        self.query_id = data.unpack_int64()
        if flags.check_bit(0):
            self.message = data.unpack_string()
        if flags.check_bit(2):
            self.url = data.unpack_string()
        self.cache_time = data.unpack_int32()
        return self

class messages_saveDraft(TLObject):
    ID = 0xbc39e14b
    def __init__(self, flags = None, no_webpage = None, reply_to_msg_id = None, peer = None, message = None, entities = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.peer = peer
        self.message = message
        self.entities = entities
    def __str__(self):
        return 'messages_saveDraft'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 1)
        if self.reply_to_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.reply_to_msg_id)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.message)
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.no_webpage = True
        if flags.check_bit(0):
            self.reply_to_msg_id = data.unpack_int32()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.message = data.unpack_string()
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        return self

class messages_readFeaturedStickers(TLObject):
    ID = 0x5b118126
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'messages_readFeaturedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int64())
        return self

class messages_saveRecentSticker(TLObject):
    ID = 0x392718f8
    def __init__(self, flags = None, attached = None, id = None, unsave = None):
        self.flags = flags
        self.attached = attached
        self.id = id
        self.unsave = unsave
    def __str__(self):
        return 'messages_saveRecentSticker'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.attached:
            flags |= (1 << 0)
        stream.pack_bytes(self.id.write())
        stream.pack_bytes(self.unsave.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.attached = True
        self.id = InputDocument()
        self.id = self.id.read(data)
        self.unsave = Bool()
        self.unsave = self.unsave.read(data)
        return self

class messages_clearRecentStickers(TLObject):
    ID = 0x8999602d
    def __init__(self, flags = None, attached = None):
        self.flags = flags
        self.attached = attached
    def __str__(self):
        return 'messages_clearRecentStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.attached:
            flags |= (1 << 0)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.attached = True
        return self

class messages_setInlineGameScore(TLObject):
    ID = 0x15ad9f64
    def __init__(self, flags = None, edit_message = None, force = None, id = None, user_id = None, score = None):
        self.flags = flags
        self.edit_message = edit_message
        self.force = force
        self.id = id
        self.user_id = user_id
        self.score = score
    def __str__(self):
        return 'messages_setInlineGameScore'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.edit_message:
            flags |= (1 << 0)
        if self.force:
            flags |= (1 << 1)
        stream.pack_bytes(self.id.write())
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(self.score)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.edit_message = True
        if flags.check_bit(1):
            self.force = True
        self.id = InputBotInlineMessageID()
        self.id = self.id.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.score = data.unpack_int32()
        return self

class messages_toggleDialogPin(TLObject):
    ID = 0xa731e257
    def __init__(self, flags = None, pinned = None, peer = None):
        self.flags = flags
        self.pinned = pinned
        self.peer = peer
    def __str__(self):
        return 'messages_toggleDialogPin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pinned:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pinned = True
        self.peer = InputDialogPeer()
        self.peer = self.peer.read(data)
        return self

class messages_reorderPinnedDialogs(TLObject):
    ID = 0x3b1adf37
    def __init__(self, flags = None, force = None, folder_id = None, order = None):
        self.flags = flags
        self.force = force
        self.folder_id = folder_id
        self.order = order
    def __str__(self):
        return 'messages_reorderPinnedDialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.force:
            flags |= (1 << 0)
        stream.pack_int32(self.folder_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.order))
        for vec_k_2 in self.order:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.force = True
        self.folder_id = data.unpack_int32()
        self.order = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputDialogPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.order.append(elem_of_1_vec)
        return self

class messages_setBotShippingResults(TLObject):
    ID = 0xe5f672fa
    def __init__(self, flags = None, query_id = None, error = None, shipping_options = None):
        self.flags = flags
        self.query_id = query_id
        self.error = error
        self.shipping_options = shipping_options
    def __str__(self):
        return 'messages_setBotShippingResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        flags = 0x0
        if self.error:
            flags |= (1 << 0)
            stream.pack_string(self.error)
        if self.shipping_options:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.shipping_options))
            for vec_k_2 in self.shipping_options:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.query_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.error = data.unpack_string()
        if flags.check_bit(1):
            self.shipping_options = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = ShippingOption()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.shipping_options.append(elem_of_1_vec)
        return self

class messages_setBotPrecheckoutResults(TLObject):
    ID = 0x9c2dd95
    def __init__(self, flags = None, success = None, query_id = None, error = None):
        self.flags = flags
        self.success = success
        self.query_id = query_id
        self.error = error
    def __str__(self):
        return 'messages_setBotPrecheckoutResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.success:
            flags |= (1 << 1)
        stream.pack_int64(self.query_id)
        if self.error:
            flags |= (1 << 0)
            stream.pack_string(self.error)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.success = True
        self.query_id = data.unpack_int64()
        if flags.check_bit(0):
            self.error = data.unpack_string()
        return self

class messages_faveSticker(TLObject):
    ID = 0xb9ffc55b
    def __init__(self, id = None, unfave = None):
        self.id = id
        self.unfave = unfave
    def __str__(self):
        return 'messages_faveSticker'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        stream.pack_bytes(self.unfave.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputDocument()
        self.id = self.id.read(data)
        self.unfave = Bool()
        self.unfave = self.unfave.read(data)
        return self

class messages_markDialogUnread(TLObject):
    ID = 0xc286d98f
    def __init__(self, flags = None, unread = None, peer = None):
        self.flags = flags
        self.unread = unread
        self.peer = peer
    def __str__(self):
        return 'messages_markDialogUnread'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.unread:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.unread = True
        self.peer = InputDialogPeer()
        self.peer = self.peer.read(data)
        return self

class messages_clearAllDrafts(TLObject):
    ID = 0x7e58ee9c
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_clearAllDrafts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_editChatAbout(TLObject):
    ID = 0xdef60797
    def __init__(self, peer = None, about = None):
        self.peer = peer
        self.about = about
    def __str__(self):
        return 'messages_editChatAbout'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.about)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.about = data.unpack_string()
        return self

class messages_hidePeerSettingsBar(TLObject):
    ID = 0x4facb138
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_hidePeerSettingsBar'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class messages_toggleStickerSets(TLObject):
    ID = 0xb5052fea
    def __init__(self, flags = None, uninstall = None, archive = None, unarchive = None, stickersets = None):
        self.flags = flags
        self.uninstall = uninstall
        self.archive = archive
        self.unarchive = unarchive
        self.stickersets = stickersets
    def __str__(self):
        return 'messages_toggleStickerSets'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.uninstall:
            flags |= (1 << 0)
        if self.archive:
            flags |= (1 << 1)
        if self.unarchive:
            flags |= (1 << 2)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.stickersets))
        for vec_k_2 in self.stickersets:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.uninstall = True
        if flags.check_bit(1):
            self.archive = True
        if flags.check_bit(2):
            self.unarchive = True
        self.stickersets = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputStickerSet()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.stickersets.append(elem_of_1_vec)
        return self

class messages_updateDialogFilter(TLObject):
    ID = 0x1ad4a04a
    def __init__(self, flags = None, id = None, filter = None):
        self.flags = flags
        self.id = id
        self.filter = filter
    def __str__(self):
        return 'messages_updateDialogFilter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        flags = 0x0
        if self.filter:
            flags |= (1 << 0)
            stream.pack_bytes(self.filter.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.filter = DialogFilter()
            self.filter = self.filter.read(data)
        return self

class messages_updateDialogFiltersOrder(TLObject):
    ID = 0xc563c1e4
    def __init__(self, order = None):
        self.order = order
    def __str__(self):
        return 'messages_updateDialogFiltersOrder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.order))
        for vec_k_2 in self.order:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.order = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.order.append(data.unpack_int32())
        return self

class messages_readDiscussion(TLObject):
    ID = 0xf731a9f4
    def __init__(self, peer = None, msg_id = None, read_max_id = None):
        self.peer = peer
        self.msg_id = msg_id
        self.read_max_id = read_max_id
    def __str__(self):
        return 'messages_readDiscussion'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int32(self.read_max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.read_max_id = data.unpack_int32()
        return self

class messages_deleteChat(TLObject):
    ID = 0x5bd0ee50
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'messages_deleteChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        return self

class messages_startHistoryImport(TLObject):
    ID = 0xb43df344
    def __init__(self, peer = None, import_id = None):
        self.peer = peer
        self.import_id = import_id
    def __str__(self):
        return 'messages_startHistoryImport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.import_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.import_id = data.unpack_int64()
        return self

class messages_deleteRevokedExportedChatInvites(TLObject):
    ID = 0x56987bd5
    def __init__(self, peer = None, admin_id = None):
        self.peer = peer
        self.admin_id = admin_id
    def __str__(self):
        return 'messages_deleteRevokedExportedChatInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.admin_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.admin_id = InputUser()
        self.admin_id = self.admin_id.read(data)
        return self

class messages_deleteExportedChatInvite(TLObject):
    ID = 0xd464a42b
    def __init__(self, peer = None, link = None):
        self.peer = peer
        self.link = link
    def __str__(self):
        return 'messages_deleteExportedChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.link)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.link = data.unpack_string()
        return self

class upload_saveFilePart(TLObject):
    ID = 0xb304a621
    def __init__(self, file_id = None, file_part = None, bytes = None):
        self.file_id = file_id
        self.file_part = file_part
        self.bytes = bytes
    def __str__(self):
        return 'upload_saveFilePart'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.file_id)
        stream.pack_int32(self.file_part)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file_id = data.unpack_int64()
        self.file_part = data.unpack_int32()
        self.bytes = data.unpack_string()
        return self

class upload_saveBigFilePart(TLObject):
    ID = 0xde7b673d
    def __init__(self, file_id = None, file_part = None, file_total_parts = None, bytes = None):
        self.file_id = file_id
        self.file_part = file_part
        self.file_total_parts = file_total_parts
        self.bytes = bytes
    def __str__(self):
        return 'upload_saveBigFilePart'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.file_id)
        stream.pack_int32(self.file_part)
        stream.pack_int32(self.file_total_parts)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file_id = data.unpack_int64()
        self.file_part = data.unpack_int32()
        self.file_total_parts = data.unpack_int32()
        self.bytes = data.unpack_string()
        return self

class help_setBotUpdatesStatus(TLObject):
    ID = 0xec22cfcd
    def __init__(self, pending_updates_count = None, message = None):
        self.pending_updates_count = pending_updates_count
        self.message = message
    def __str__(self):
        return 'help_setBotUpdatesStatus'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pending_updates_count)
        stream.pack_string(self.message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pending_updates_count = data.unpack_int32()
        self.message = data.unpack_string()
        return self

class help_acceptTermsOfService(TLObject):
    ID = 0xee72f79a
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'help_acceptTermsOfService'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = DataJSON()
        self.id = self.id.read(data)
        return self

class help_saveAppLog(TLObject):
    ID = 0x6f02f748
    def __init__(self, events = None):
        self.events = events
    def __str__(self):
        return 'help_saveAppLog'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.events))
        for vec_k_2 in self.events:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.events = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputAppEvent()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.events.append(elem_of_1_vec)
        return self

class help_hidePromoData(TLObject):
    ID = 0x1e251c95
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'help_hidePromoData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class help_dismissSuggestion(TLObject):
    ID = 0xf50dbaa1
    def __init__(self, peer = None, suggestion = None):
        self.peer = peer
        self.suggestion = suggestion
    def __str__(self):
        return 'help_dismissSuggestion'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.suggestion)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.suggestion = data.unpack_string()
        return self

class channels_readHistory(TLObject):
    ID = 0xcc104937
    def __init__(self, channel = None, max_id = None):
        self.channel = channel
        self.max_id = max_id
    def __str__(self):
        return 'channels_readHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.max_id = data.unpack_int32()
        return self

class channels_reportSpam(TLObject):
    ID = 0xfe087810
    def __init__(self, channel = None, user_id = None, id = None):
        self.channel = channel
        self.user_id = user_id
        self.id = id
    def __str__(self):
        return 'channels_reportSpam'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class channels_checkUsername(TLObject):
    ID = 0x10e6bd2c
    def __init__(self, channel = None, username = None):
        self.channel = channel
        self.username = username
    def __str__(self):
        return 'channels_checkUsername'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_string(self.username)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.username = data.unpack_string()
        return self

class channels_updateUsername(TLObject):
    ID = 0x3514b3de
    def __init__(self, channel = None, username = None):
        self.channel = channel
        self.username = username
    def __str__(self):
        return 'channels_updateUsername'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_string(self.username)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.username = data.unpack_string()
        return self

class channels_setStickers(TLObject):
    ID = 0xea8ca4f9
    def __init__(self, channel = None, stickerset = None):
        self.channel = channel
        self.stickerset = stickerset
    def __str__(self):
        return 'channels_setStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.stickerset.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        return self

class channels_readMessageContents(TLObject):
    ID = 0xeab5dc38
    def __init__(self, channel = None, id = None):
        self.channel = channel
        self.id = id
    def __str__(self):
        return 'channels_readMessageContents'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class channels_deleteHistory(TLObject):
    ID = 0xaf369d42
    def __init__(self, channel = None, max_id = None):
        self.channel = channel
        self.max_id = max_id
    def __str__(self):
        return 'channels_deleteHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.max_id = data.unpack_int32()
        return self

class channels_setDiscussionGroup(TLObject):
    ID = 0x40582bb2
    def __init__(self, broadcast = None, group = None):
        self.broadcast = broadcast
        self.group = group
    def __str__(self):
        return 'channels_setDiscussionGroup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.broadcast.write())
        stream.pack_bytes(self.group.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.broadcast = InputChannel()
        self.broadcast = self.broadcast.read(data)
        self.group = InputChannel()
        self.group = self.group.read(data)
        return self

class channels_editLocation(TLObject):
    ID = 0x58e63f6d
    def __init__(self, channel = None, geo_point = None, address = None):
        self.channel = channel
        self.geo_point = geo_point
        self.address = address
    def __str__(self):
        return 'channels_editLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.geo_point.write())
        stream.pack_string(self.address)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        self.address = data.unpack_string()
        return self

class channels_viewSponsoredMessage(TLObject):
    ID = 0xbeaedb94
    def __init__(self, channel = None, random_id = None):
        self.channel = channel
        self.random_id = random_id
    def __str__(self):
        return 'channels_viewSponsoredMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_string(self.random_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.random_id = data.unpack_string()
        return self

class bots_answerWebhookJSONQuery(TLObject):
    ID = 0xe6213f4d
    def __init__(self, query_id = None, data = None):
        self.query_id = query_id
        self.data = data
    def __str__(self):
        return 'bots_answerWebhookJSONQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_bytes(self.data.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.query_id = data.unpack_int64()
        self.data = DataJSON()
        self.data = self.data.read(data)
        return self

class bots_setBotCommands(TLObject):
    ID = 0x517165a
    def __init__(self, scope = None, lang_code = None, commands = None):
        self.scope = scope
        self.lang_code = lang_code
        self.commands = commands
    def __str__(self):
        return 'bots_setBotCommands'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.scope.write())
        stream.pack_string(self.lang_code)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.commands))
        for vec_k_2 in self.commands:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.scope = BotCommandScope()
        self.scope = self.scope.read(data)
        self.lang_code = data.unpack_string()
        self.commands = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = BotCommand()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.commands.append(elem_of_1_vec)
        return self

class bots_resetBotCommands(TLObject):
    ID = 0x3d8de0f9
    def __init__(self, scope = None, lang_code = None):
        self.scope = scope
        self.lang_code = lang_code
    def __str__(self):
        return 'bots_resetBotCommands'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.scope.write())
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.scope = BotCommandScope()
        self.scope = self.scope.read(data)
        self.lang_code = data.unpack_string()
        return self

class payments_clearSavedInfo(TLObject):
    ID = 0xd83d70c1
    def __init__(self, flags = None, credentials = None, info = None):
        self.flags = flags
        self.credentials = credentials
        self.info = info
    def __str__(self):
        return 'payments_clearSavedInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.credentials:
            flags |= (1 << 0)
        if self.info:
            flags |= (1 << 1)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.credentials = True
        if flags.check_bit(1):
            self.info = True
        return self

class stickers_checkShortName(TLObject):
    ID = 0x284b3639
    def __init__(self, short_name = None):
        self.short_name = short_name
    def __str__(self):
        return 'stickers_checkShortName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.short_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.short_name = data.unpack_string()
        return self

class phone_receivedCall(TLObject):
    ID = 0x17d54f61
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'phone_receivedCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        return self

class phone_saveCallDebug(TLObject):
    ID = 0x277add7e
    def __init__(self, peer = None, debug = None):
        self.peer = peer
        self.debug = debug
    def __str__(self):
        return 'phone_saveCallDebug'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.debug.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        self.debug = DataJSON()
        self.debug = self.debug.read(data)
        return self

class phone_sendSignalingData(TLObject):
    ID = 0xff7a9383
    def __init__(self, peer = None, data = None):
        self.peer = peer
        self.data = data
    def __str__(self):
        return 'phone_sendSignalingData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.data)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        self.data = data.unpack_string()
        return self

class phone_saveDefaultGroupCallJoinAs(TLObject):
    ID = 0x575e1f8c
    def __init__(self, peer = None, join_as = None):
        self.peer = peer
        self.join_as = join_as
    def __str__(self):
        return 'phone_saveDefaultGroupCallJoinAs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.join_as.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.join_as = InputPeer()
        self.join_as = self.join_as.read(data)
        return self

class Bool(TLObject):
    DERIVED_OBJECTS = {0xbc799737: boolFalse, 0x997275b5: boolTrue, 0x5717da40: auth_logOut, 0x9fab0d1a: auth_resetAuthorizations, 0xcdd42a05: auth_bindTempAuthKey, 0x1f040578: auth_cancelCode, 0x8e48a188: auth_dropTempAuthKeys, 0xd36bf79: auth_checkRecoveryPassword, 0xec86017a: account_registerDevice, 0x6a0d3206: account_unregisterDevice, 0x84be5b93: account_updateNotifySettings, 0xdb7e1747: account_resetNotifySettings, 0x6628562c: account_updateStatus, 0xc5ba3d86: account_reportPeer, 0x2714d86c: account_checkUsername, 0x418d4e0b: account_deleteAccount, 0x2442485e: account_setAccountTTL, 0x38df3532: account_updateDeviceLocked, 0xdf77f3bc: account_resetAuthorization, 0xa59b102f: account_updatePasswordSettings, 0x5f2178c3: account_confirmPhone, 0x2d01b9ef: account_resetWebAuthorization, 0x682d2594: account_resetWebAuthorizations, 0xb880bc4b: account_deleteSecureValue, 0xf3ed4c73: account_acceptAuthorization, 0x4dd3a7f6: account_verifyPhone, 0xecba39db: account_verifyEmail, 0x1d2652ee: account_finishTakeoutSession, 0x8fdf1920: account_confirmPasswordEmail, 0x7a7f2a15: account_resendPasswordEmail, 0xc1cbd5b6: account_cancelPasswordEmail, 0x9f07c728: account_getContactSignUpNotification, 0xcff43f61: account_setContactSignUpNotification, 0x6c5a5b37: account_saveWallPaper, 0xfeed5769: account_installWallPaper, 0xbb3b9804: account_resetWallPapers, 0x76f36233: account_saveAutoDownloadSettings, 0xf257106c: account_saveTheme, 0x7ae43737: account_installTheme, 0xb574b16b: account_setContentSettings, 0xfa8cc6f5: account_reportProfilePhoto, 0x4c9409f6: account_declinePasswordReset, 0x90c894b5: users_setSecureValueErrors, 0x1013fd9e: contacts_deleteByPhones, 0x68cc1411: contacts_block, 0xbea65d50: contacts_unblock, 0x1ae373ac: contacts_resetTopPeerRating, 0x879537f1: contacts_resetSaved, 0x8514bdda: contacts_toggleTopPeers, 0x58943ee2: messages_setTyping, 0xcf1592db: messages_reportSpam, 0x8953ab4e: messages_report, 0xf393aea0: messages_discardEncryption, 0x791451ed: messages_setEncryptedTyping, 0x7f4b690a: messages_readEncryptedHistory, 0x4b0c8c0f: messages_reportEncryptedSpam, 0xf96e55de: messages_uninstallStickerSet, 0xa85bd1c2: messages_editChatAdmin, 0x78337739: messages_reorderStickerSets, 0x327a30cb: messages_saveGif, 0xeb5ea206: messages_setInlineBotResults, 0x83557dba: messages_editInlineBotMessage, 0xd58f130a: messages_setBotCallbackAnswer, 0xbc39e14b: messages_saveDraft, 0x5b118126: messages_readFeaturedStickers, 0x392718f8: messages_saveRecentSticker, 0x8999602d: messages_clearRecentStickers, 0x15ad9f64: messages_setInlineGameScore, 0xa731e257: messages_toggleDialogPin, 0x3b1adf37: messages_reorderPinnedDialogs, 0xe5f672fa: messages_setBotShippingResults, 0x9c2dd95: messages_setBotPrecheckoutResults, 0xb9ffc55b: messages_faveSticker, 0xc286d98f: messages_markDialogUnread, 0x7e58ee9c: messages_clearAllDrafts, 0xdef60797: messages_editChatAbout, 0x4facb138: messages_hidePeerSettingsBar, 0xb5052fea: messages_toggleStickerSets, 0x1ad4a04a: messages_updateDialogFilter, 0xc563c1e4: messages_updateDialogFiltersOrder, 0xf731a9f4: messages_readDiscussion, 0x5bd0ee50: messages_deleteChat, 0xb43df344: messages_startHistoryImport, 0x56987bd5: messages_deleteRevokedExportedChatInvites, 0xd464a42b: messages_deleteExportedChatInvite, 0xb304a621: upload_saveFilePart, 0xde7b673d: upload_saveBigFilePart, 0xec22cfcd: help_setBotUpdatesStatus, 0xee72f79a: help_acceptTermsOfService, 0x6f02f748: help_saveAppLog, 0x1e251c95: help_hidePromoData, 0xf50dbaa1: help_dismissSuggestion, 0xcc104937: channels_readHistory, 0xfe087810: channels_reportSpam, 0x10e6bd2c: channels_checkUsername, 0x3514b3de: channels_updateUsername, 0xea8ca4f9: channels_setStickers, 0xeab5dc38: channels_readMessageContents, 0xaf369d42: channels_deleteHistory, 0x40582bb2: channels_setDiscussionGroup, 0x58e63f6d: channels_editLocation, 0xbeaedb94: channels_viewSponsoredMessage, 0xe6213f4d: bots_answerWebhookJSONQuery, 0x517165a: bots_setBotCommands, 0x3d8de0f9: bots_resetBotCommands, 0xd83d70c1: payments_clearSavedInfo, 0x284b3639: stickers_checkShortName, 0x17d54f61: phone_receivedCall, 0x277add7e: phone_saveCallDebug, 0xff7a9383: phone_sendSignalingData, 0x575e1f8c: phone_saveDefaultGroupCallJoinAs}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class error(TLObject):
    ID = 0xc4b9f9bb
    def __init__(self, code = None, text = None):
        self.code = code
        self.text = text
    def __str__(self):
        return 'error'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.code)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.code = data.unpack_int32()
        self.text = data.unpack_string()
        return self

class Error(TLObject):
    DERIVED_OBJECTS = {0xc4b9f9bb: error}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class null(TLObject):
    ID = 0x56730bcc
    def __init__(self):
        pass
    def __str__(self):
        return 'null'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class Null(TLObject):
    DERIVED_OBJECTS = {0x56730bcc: null}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPeerEmpty(TLObject):
    ID = 0x7f3b18ea
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPeerEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPeerSelf(TLObject):
    ID = 0x7da07ec9
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPeerSelf'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPeerChat(TLObject):
    ID = 0x35a95cb9
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'inputPeerChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        return self

class inputPeerUser(TLObject):
    ID = 0xdde8a54c
    def __init__(self, user_id = None, access_hash = None):
        self.user_id = user_id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputPeerUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputPeerChannel(TLObject):
    ID = 0x27bcbbfc
    def __init__(self, channel_id = None, access_hash = None):
        self.channel_id = channel_id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputPeerChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputPeerUserFromMessage(TLObject):
    ID = 0xa87b0a1c
    def __init__(self, peer = None, msg_id = None, user_id = None):
        self.peer = peer
        self.msg_id = msg_id
        self.user_id = user_id
    def __str__(self):
        return 'inputPeerUserFromMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.user_id = data.unpack_int64()
        return self

class inputPeerChannelFromMessage(TLObject):
    ID = 0xbd2a0840
    def __init__(self, peer = None, msg_id = None, channel_id = None):
        self.peer = peer
        self.msg_id = msg_id
        self.channel_id = channel_id
    def __str__(self):
        return 'inputPeerChannelFromMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int64(self.channel_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        return self

class InputPeer(TLObject):
    DERIVED_OBJECTS = {0x7f3b18ea: inputPeerEmpty, 0x7da07ec9: inputPeerSelf, 0x35a95cb9: inputPeerChat, 0xdde8a54c: inputPeerUser, 0x27bcbbfc: inputPeerChannel, 0xa87b0a1c: inputPeerUserFromMessage, 0xbd2a0840: inputPeerChannelFromMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputUserEmpty(TLObject):
    ID = 0xb98886cf
    def __init__(self):
        pass
    def __str__(self):
        return 'inputUserEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputUserSelf(TLObject):
    ID = 0xf7c1b13f
    def __init__(self):
        pass
    def __str__(self):
        return 'inputUserSelf'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputUser(TLObject):
    ID = 0xf21158c6
    def __init__(self, user_id = None, access_hash = None):
        self.user_id = user_id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputUserFromMessage(TLObject):
    ID = 0x1da448e2
    def __init__(self, peer = None, msg_id = None, user_id = None):
        self.peer = peer
        self.msg_id = msg_id
        self.user_id = user_id
    def __str__(self):
        return 'inputUserFromMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.user_id = data.unpack_int64()
        return self

class InputUser(TLObject):
    DERIVED_OBJECTS = {0xb98886cf: inputUserEmpty, 0xf7c1b13f: inputUserSelf, 0xf21158c6: inputUser, 0x1da448e2: inputUserFromMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPhoneContact(TLObject):
    ID = 0xf392b7f4
    def __init__(self, client_id = None, phone = None, first_name = None, last_name = None):
        self.client_id = client_id
        self.phone = phone
        self.first_name = first_name
        self.last_name = last_name
    def __str__(self):
        return 'inputPhoneContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.client_id)
        stream.pack_string(self.phone)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.client_id = data.unpack_int64()
        self.phone = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        return self

class InputContact(TLObject):
    DERIVED_OBJECTS = {0xf392b7f4: inputPhoneContact}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputFile(TLObject):
    ID = 0xf52ff27f
    def __init__(self, id = None, parts = None, name = None, md5_checksum = None):
        self.id = id
        self.parts = parts
        self.name = name
        self.md5_checksum = md5_checksum
    def __str__(self):
        return 'inputFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.parts)
        stream.pack_string(self.name)
        stream.pack_string(self.md5_checksum)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.parts = data.unpack_int32()
        self.name = data.unpack_string()
        self.md5_checksum = data.unpack_string()
        return self

class inputFileBig(TLObject):
    ID = 0xfa4f0bb5
    def __init__(self, id = None, parts = None, name = None):
        self.id = id
        self.parts = parts
        self.name = name
    def __str__(self):
        return 'inputFileBig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.parts)
        stream.pack_string(self.name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.parts = data.unpack_int32()
        self.name = data.unpack_string()
        return self

class InputFile(TLObject):
    DERIVED_OBJECTS = {0xf52ff27f: inputFile, 0xfa4f0bb5: inputFileBig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputMediaEmpty(TLObject):
    ID = 0x9664f57f
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMediaEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMediaUploadedPhoto(TLObject):
    ID = 0x1e287d04
    def __init__(self, flags = None, file = None, stickers = None, ttl_seconds = None):
        self.flags = flags
        self.file = file
        self.stickers = stickers
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'inputMediaUploadedPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.file.write())
        flags = 0x0
        if self.stickers:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.stickers))
            for vec_k_2 in self.stickers:
                stream.pack_bytes(vec_k_2.write())
        if self.ttl_seconds:
            flags |= (1 << 1)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.file = InputFile()
        self.file = self.file.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.stickers = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = InputDocument()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.stickers.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.ttl_seconds = data.unpack_int32()
        return self

class inputMediaPhoto(TLObject):
    ID = 0xb3ba0635
    def __init__(self, flags = None, id = None, ttl_seconds = None):
        self.flags = flags
        self.id = id
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'inputMediaPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        flags = 0x0
        if self.ttl_seconds:
            flags |= (1 << 0)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = InputPhoto()
        self.id = self.id.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.ttl_seconds = data.unpack_int32()
        return self

class inputMediaGeoPoint(TLObject):
    ID = 0xf9c44144
    def __init__(self, geo_point = None):
        self.geo_point = geo_point
    def __str__(self):
        return 'inputMediaGeoPoint'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo_point.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        return self

class inputMediaContact(TLObject):
    ID = 0xf8ab7dfb
    def __init__(self, phone_number = None, first_name = None, last_name = None, vcard = None):
        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.vcard = vcard
    def __str__(self):
        return 'inputMediaContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_string(self.vcard)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.vcard = data.unpack_string()
        return self

class inputMediaUploadedDocument(TLObject):
    ID = 0x5b38c6c1
    def __init__(self, flags = None, nosound_video = None, force_file = None, file = None, thumb = None, mime_type = None, attributes = None, stickers = None, ttl_seconds = None):
        self.flags = flags
        self.nosound_video = nosound_video
        self.force_file = force_file
        self.file = file
        self.thumb = thumb
        self.mime_type = mime_type
        self.attributes = attributes
        self.stickers = stickers
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'inputMediaUploadedDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.nosound_video:
            flags |= (1 << 3)
        if self.force_file:
            flags |= (1 << 4)
        stream.pack_bytes(self.file.write())
        if self.thumb:
            flags |= (1 << 2)
            stream.pack_bytes(self.thumb.write())
        stream.pack_string(self.mime_type)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.attributes))
        for vec_k_2 in self.attributes:
            stream.pack_bytes(vec_k_2.write())
        if self.stickers:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.stickers))
            for vec_k_3 in self.stickers:
                stream.pack_bytes(vec_k_3.write())
        if self.ttl_seconds:
            flags |= (1 << 1)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(3):
            self.nosound_video = True
        if flags.check_bit(4):
            self.force_file = True
        self.file = InputFile()
        self.file = self.file.read(data)
        if flags.check_bit(2):
            self.thumb = InputFile()
            self.thumb = self.thumb.read(data)
        self.mime_type = data.unpack_string()
        self.attributes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = DocumentAttribute()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.attributes.append(elem_of_1_vec)
        if flags.check_bit(0):
            self.stickers = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = InputDocument()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.stickers.append(elem_of_2_vec)
        if flags.check_bit(1):
            self.ttl_seconds = data.unpack_int32()
        return self

class inputMediaDocument(TLObject):
    ID = 0x33473058
    def __init__(self, flags = None, id = None, ttl_seconds = None, query = None):
        self.flags = flags
        self.id = id
        self.ttl_seconds = ttl_seconds
        self.query = query
    def __str__(self):
        return 'inputMediaDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        flags = 0x0
        if self.ttl_seconds:
            flags |= (1 << 0)
            stream.pack_int32(self.ttl_seconds)
        if self.query:
            flags |= (1 << 1)
            stream.pack_string(self.query)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = InputDocument()
        self.id = self.id.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.ttl_seconds = data.unpack_int32()
        if flags.check_bit(1):
            self.query = data.unpack_string()
        return self

class inputMediaVenue(TLObject):
    ID = 0xc13d1c11
    def __init__(self, geo_point = None, title = None, address = None, provider = None, venue_id = None, venue_type = None):
        self.geo_point = geo_point
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.venue_type = venue_type
    def __str__(self):
        return 'inputMediaVenue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo_point.write())
        stream.pack_string(self.title)
        stream.pack_string(self.address)
        stream.pack_string(self.provider)
        stream.pack_string(self.venue_id)
        stream.pack_string(self.venue_type)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        self.title = data.unpack_string()
        self.address = data.unpack_string()
        self.provider = data.unpack_string()
        self.venue_id = data.unpack_string()
        self.venue_type = data.unpack_string()
        return self

class inputMediaPhotoExternal(TLObject):
    ID = 0xe5bbfe1a
    def __init__(self, flags = None, url = None, ttl_seconds = None):
        self.flags = flags
        self.url = url
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'inputMediaPhotoExternal'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        flags = 0x0
        if self.ttl_seconds:
            flags |= (1 << 0)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.url = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.ttl_seconds = data.unpack_int32()
        return self

class inputMediaDocumentExternal(TLObject):
    ID = 0xfb52dc99
    def __init__(self, flags = None, url = None, ttl_seconds = None):
        self.flags = flags
        self.url = url
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'inputMediaDocumentExternal'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        flags = 0x0
        if self.ttl_seconds:
            flags |= (1 << 0)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.url = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.ttl_seconds = data.unpack_int32()
        return self

class inputMediaGame(TLObject):
    ID = 0xd33f43f3
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputMediaGame'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputGame()
        self.id = self.id.read(data)
        return self

class inputMediaInvoice(TLObject):
    ID = 0xd9799874
    def __init__(self, flags = None, title = None, description = None, photo = None, invoice = None, payload = None, provider = None, provider_data = None, start_param = None):
        self.flags = flags
        self.title = title
        self.description = description
        self.photo = photo
        self.invoice = invoice
        self.payload = payload
        self.provider = provider
        self.provider_data = provider_data
        self.start_param = start_param
    def __str__(self):
        return 'inputMediaInvoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        stream.pack_string(self.description)
        flags = 0x0
        if self.photo:
            flags |= (1 << 0)
            stream.pack_bytes(self.photo.write())
        stream.pack_bytes(self.invoice.write())
        stream.pack_string(self.payload)
        stream.pack_string(self.provider)
        stream.pack_bytes(self.provider_data.write())
        if self.start_param:
            flags |= (1 << 1)
            stream.pack_string(self.start_param)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.title = data.unpack_string()
        self.description = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.photo = InputWebDocument()
            self.photo = self.photo.read(data)
        self.invoice = Invoice()
        self.invoice = self.invoice.read(data)
        self.payload = data.unpack_string()
        self.provider = data.unpack_string()
        self.provider_data = DataJSON()
        self.provider_data = self.provider_data.read(data)
        if flags.check_bit(1):
            self.start_param = data.unpack_string()
        return self

class inputMediaGeoLive(TLObject):
    ID = 0x971fa843
    def __init__(self, flags = None, stopped = None, geo_point = None, heading = None, period = None, proximity_notification_radius = None):
        self.flags = flags
        self.stopped = stopped
        self.geo_point = geo_point
        self.heading = heading
        self.period = period
        self.proximity_notification_radius = proximity_notification_radius
    def __str__(self):
        return 'inputMediaGeoLive'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.stopped:
            flags |= (1 << 0)
        stream.pack_bytes(self.geo_point.write())
        if self.heading:
            flags |= (1 << 2)
            stream.pack_int32(self.heading)
        if self.period:
            flags |= (1 << 1)
            stream.pack_int32(self.period)
        if self.proximity_notification_radius:
            flags |= (1 << 3)
            stream.pack_int32(self.proximity_notification_radius)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.stopped = True
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        if flags.check_bit(2):
            self.heading = data.unpack_int32()
        if flags.check_bit(1):
            self.period = data.unpack_int32()
        if flags.check_bit(3):
            self.proximity_notification_radius = data.unpack_int32()
        return self

class inputMediaPoll(TLObject):
    ID = 0xf94e5f1
    def __init__(self, flags = None, poll = None, correct_answers = None, solution = None, solution_entities = None):
        self.flags = flags
        self.poll = poll
        self.correct_answers = correct_answers
        self.solution = solution
        self.solution_entities = solution_entities
    def __str__(self):
        return 'inputMediaPoll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.poll.write())
        flags = 0x0
        if self.correct_answers:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.correct_answers))
            for vec_k_2 in self.correct_answers:
                stream.pack_string(vec_k_2)
        if self.solution:
            flags |= (1 << 1)
            stream.pack_string(self.solution)
        if self.solution_entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.solution_entities))
            for vec_k_3 in self.solution_entities:
                stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.poll = Poll()
        self.poll = self.poll.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.correct_answers = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                self.correct_answers.append(data.unpack_string())
        if flags.check_bit(1):
            self.solution = data.unpack_string()
        if flags.check_bit(1):
            self.solution_entities = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = MessageEntity()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.solution_entities.append(elem_of_2_vec)
        return self

class inputMediaDice(TLObject):
    ID = 0xe66fbf7b
    def __init__(self, emoticon = None):
        self.emoticon = emoticon
    def __str__(self):
        return 'inputMediaDice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        return self

class InputMedia(TLObject):
    DERIVED_OBJECTS = {0x9664f57f: inputMediaEmpty, 0x1e287d04: inputMediaUploadedPhoto, 0xb3ba0635: inputMediaPhoto, 0xf9c44144: inputMediaGeoPoint, 0xf8ab7dfb: inputMediaContact, 0x5b38c6c1: inputMediaUploadedDocument, 0x33473058: inputMediaDocument, 0xc13d1c11: inputMediaVenue, 0xe5bbfe1a: inputMediaPhotoExternal, 0xfb52dc99: inputMediaDocumentExternal, 0xd33f43f3: inputMediaGame, 0xd9799874: inputMediaInvoice, 0x971fa843: inputMediaGeoLive, 0xf94e5f1: inputMediaPoll, 0xe66fbf7b: inputMediaDice}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputChatPhotoEmpty(TLObject):
    ID = 0x1ca48f57
    def __init__(self):
        pass
    def __str__(self):
        return 'inputChatPhotoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputChatUploadedPhoto(TLObject):
    ID = 0xc642724e
    def __init__(self, flags = None, file = None, video = None, video_start_ts = None):
        self.flags = flags
        self.file = file
        self.video = video
        self.video_start_ts = video_start_ts
    def __str__(self):
        return 'inputChatUploadedPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.file:
            flags |= (1 << 0)
            stream.pack_bytes(self.file.write())
        if self.video:
            flags |= (1 << 1)
            stream.pack_bytes(self.video.write())
        if self.video_start_ts:
            flags |= (1 << 2)
            stream.pack_double(self.video_start_ts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.file = InputFile()
            self.file = self.file.read(data)
        if flags.check_bit(1):
            self.video = InputFile()
            self.video = self.video.read(data)
        if flags.check_bit(2):
            self.video_start_ts = data.unpack_double()
        return self

class inputChatPhoto(TLObject):
    ID = 0x8953ad37
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputChatPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputPhoto()
        self.id = self.id.read(data)
        return self

class InputChatPhoto(TLObject):
    DERIVED_OBJECTS = {0x1ca48f57: inputChatPhotoEmpty, 0xc642724e: inputChatUploadedPhoto, 0x8953ad37: inputChatPhoto}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputGeoPointEmpty(TLObject):
    ID = 0xe4c123d6
    def __init__(self):
        pass
    def __str__(self):
        return 'inputGeoPointEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputGeoPoint(TLObject):
    ID = 0x48222faf
    def __init__(self, flags = None, lat = None, long = None, accuracy_radius = None):
        self.flags = flags
        self.lat = lat
        self.long = long
        self.accuracy_radius = accuracy_radius
    def __str__(self):
        return 'inputGeoPoint'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_double(self.lat)
        stream.pack_double(self.long)
        flags = 0x0
        if self.accuracy_radius:
            flags |= (1 << 0)
            stream.pack_int32(self.accuracy_radius)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.lat = data.unpack_double()
        self.long = data.unpack_double()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.accuracy_radius = data.unpack_int32()
        return self

class InputGeoPoint(TLObject):
    DERIVED_OBJECTS = {0xe4c123d6: inputGeoPointEmpty, 0x48222faf: inputGeoPoint}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPhotoEmpty(TLObject):
    ID = 0x1cd7bf0d
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPhotoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPhoto(TLObject):
    ID = 0x3bb3b94a
    def __init__(self, id = None, access_hash = None, file_reference = None):
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
    def __str__(self):
        return 'inputPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        return self

class InputPhoto(TLObject):
    DERIVED_OBJECTS = {0x1cd7bf0d: inputPhotoEmpty, 0x3bb3b94a: inputPhoto}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputFileLocation(TLObject):
    ID = 0xdfdaabe1
    def __init__(self, volume_id = None, local_id = None, secret = None, file_reference = None):
        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret
        self.file_reference = file_reference
    def __str__(self):
        return 'inputFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.volume_id)
        stream.pack_int32(self.local_id)
        stream.pack_int64(self.secret)
        stream.pack_string(self.file_reference)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.volume_id = data.unpack_int64()
        self.local_id = data.unpack_int32()
        self.secret = data.unpack_int64()
        self.file_reference = data.unpack_string()
        return self

class inputEncryptedFileLocation(TLObject):
    ID = 0xf5235d55
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputEncryptedFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputDocumentFileLocation(TLObject):
    ID = 0xbad07584
    def __init__(self, id = None, access_hash = None, file_reference = None, thumb_size = None):
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
        self.thumb_size = thumb_size
    def __str__(self):
        return 'inputDocumentFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        stream.pack_string(self.thumb_size)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        self.thumb_size = data.unpack_string()
        return self

class inputSecureFileLocation(TLObject):
    ID = 0xcbc7ee28
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputSecureFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputTakeoutFileLocation(TLObject):
    ID = 0x29be5899
    def __init__(self):
        pass
    def __str__(self):
        return 'inputTakeoutFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPhotoFileLocation(TLObject):
    ID = 0x40181ffe
    def __init__(self, id = None, access_hash = None, file_reference = None, thumb_size = None):
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
        self.thumb_size = thumb_size
    def __str__(self):
        return 'inputPhotoFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        stream.pack_string(self.thumb_size)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        self.thumb_size = data.unpack_string()
        return self

class inputPhotoLegacyFileLocation(TLObject):
    ID = 0xd83466f3
    def __init__(self, id = None, access_hash = None, file_reference = None, volume_id = None, local_id = None, secret = None):
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
        self.volume_id = volume_id
        self.local_id = local_id
        self.secret = secret
    def __str__(self):
        return 'inputPhotoLegacyFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        stream.pack_int64(self.volume_id)
        stream.pack_int32(self.local_id)
        stream.pack_int64(self.secret)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        self.volume_id = data.unpack_int64()
        self.local_id = data.unpack_int32()
        self.secret = data.unpack_int64()
        return self

class inputPeerPhotoFileLocation(TLObject):
    ID = 0x37257e99
    def __init__(self, flags = None, big = None, peer = None, photo_id = None):
        self.flags = flags
        self.big = big
        self.peer = peer
        self.photo_id = photo_id
    def __str__(self):
        return 'inputPeerPhotoFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.big:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.photo_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.big = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.photo_id = data.unpack_int64()
        return self

class inputStickerSetThumb(TLObject):
    ID = 0x9d84f3db
    def __init__(self, stickerset = None, thumb_version = None):
        self.stickerset = stickerset
        self.thumb_version = thumb_version
    def __str__(self):
        return 'inputStickerSetThumb'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        stream.pack_int32(self.thumb_version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        self.thumb_version = data.unpack_int32()
        return self

class inputGroupCallStream(TLObject):
    ID = 0x598a92a
    def __init__(self, flags = None, call = None, time_ms = None, scale = None, video_channel = None, video_quality = None):
        self.flags = flags
        self.call = call
        self.time_ms = time_ms
        self.scale = scale
        self.video_channel = video_channel
        self.video_quality = video_quality
    def __str__(self):
        return 'inputGroupCallStream'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int64(self.time_ms)
        stream.pack_int32(self.scale)
        flags = 0x0
        if self.video_channel:
            flags |= (1 << 0)
            stream.pack_int32(self.video_channel)
        if self.video_quality:
            flags |= (1 << 0)
            stream.pack_int32(self.video_quality)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.time_ms = data.unpack_int64()
        self.scale = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.video_channel = data.unpack_int32()
        if flags.check_bit(0):
            self.video_quality = data.unpack_int32()
        return self

class InputFileLocation(TLObject):
    DERIVED_OBJECTS = {0xdfdaabe1: inputFileLocation, 0xf5235d55: inputEncryptedFileLocation, 0xbad07584: inputDocumentFileLocation, 0xcbc7ee28: inputSecureFileLocation, 0x29be5899: inputTakeoutFileLocation, 0x40181ffe: inputPhotoFileLocation, 0xd83466f3: inputPhotoLegacyFileLocation, 0x37257e99: inputPeerPhotoFileLocation, 0x9d84f3db: inputStickerSetThumb, 0x598a92a: inputGroupCallStream}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class peerUser(TLObject):
    ID = 0x59511722
    def __init__(self, user_id = None):
        self.user_id = user_id
    def __str__(self):
        return 'peerUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        return self

class peerChat(TLObject):
    ID = 0x36c6019a
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'peerChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        return self

class peerChannel(TLObject):
    ID = 0xa2a5371e
    def __init__(self, channel_id = None):
        self.channel_id = channel_id
    def __str__(self):
        return 'peerChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        return self

class Peer(TLObject):
    DERIVED_OBJECTS = {0x59511722: peerUser, 0x36c6019a: peerChat, 0xa2a5371e: peerChannel}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class storage_fileUnknown(TLObject):
    ID = 0xaa963b05
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileUnknown'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_filePartial(TLObject):
    ID = 0x40bc6f52
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_filePartial'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_fileJpeg(TLObject):
    ID = 0x7efe0e
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileJpeg'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_fileGif(TLObject):
    ID = 0xcae1aadf
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileGif'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_filePng(TLObject):
    ID = 0xa4f63c0
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_filePng'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_filePdf(TLObject):
    ID = 0xae1e508d
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_filePdf'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_fileMp3(TLObject):
    ID = 0x528a0677
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileMp3'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_fileMov(TLObject):
    ID = 0x4b09ebbc
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileMov'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_fileMp4(TLObject):
    ID = 0xb3cea0e4
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileMp4'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_fileWebp(TLObject):
    ID = 0x1081464c
    def __init__(self):
        pass
    def __str__(self):
        return 'storage_fileWebp'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class storage_FileType(TLObject):
    DERIVED_OBJECTS = {0xaa963b05: storage_fileUnknown, 0x40bc6f52: storage_filePartial, 0x7efe0e: storage_fileJpeg, 0xcae1aadf: storage_fileGif, 0xa4f63c0: storage_filePng, 0xae1e508d: storage_filePdf, 0x528a0677: storage_fileMp3, 0x4b09ebbc: storage_fileMov, 0xb3cea0e4: storage_fileMp4, 0x1081464c: storage_fileWebp}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class userEmpty(TLObject):
    ID = 0xd3bc4b7a
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'userEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class user(TLObject):
    ID = 0x3ff6ecb0
    def __init__(self, flags = None, self_ = None, contact = None, mutual_contact = None, deleted = None, bot = None, bot_chat_history = None, bot_nochats = None, verified = None, restricted = None, min = None, bot_inline_geo = None, support = None, scam = None, apply_min_photo = None, fake = None, id = None, access_hash = None, first_name = None, last_name = None, username = None, phone = None, photo = None, status = None, bot_info_version = None, restriction_reason = None, bot_inline_placeholder = None, lang_code = None):
        self.flags = flags
        self.self_ = self_
        self.contact = contact
        self.mutual_contact = mutual_contact
        self.deleted = deleted
        self.bot = bot
        self.bot_chat_history = bot_chat_history
        self.bot_nochats = bot_nochats
        self.verified = verified
        self.restricted = restricted
        self.min = min
        self.bot_inline_geo = bot_inline_geo
        self.support = support
        self.scam = scam
        self.apply_min_photo = apply_min_photo
        self.fake = fake
        self.id = id
        self.access_hash = access_hash
        self.first_name = first_name
        self.last_name = last_name
        self.username = username
        self.phone = phone
        self.photo = photo
        self.status = status
        self.bot_info_version = bot_info_version
        self.restriction_reason = restriction_reason
        self.bot_inline_placeholder = bot_inline_placeholder
        self.lang_code = lang_code
    def __str__(self):
        return 'user'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.self_:
            flags |= (1 << 10)
        if self.contact:
            flags |= (1 << 11)
        if self.mutual_contact:
            flags |= (1 << 12)
        if self.deleted:
            flags |= (1 << 13)
        if self.bot:
            flags |= (1 << 14)
        if self.bot_chat_history:
            flags |= (1 << 15)
        if self.bot_nochats:
            flags |= (1 << 16)
        if self.verified:
            flags |= (1 << 17)
        if self.restricted:
            flags |= (1 << 18)
        if self.min:
            flags |= (1 << 20)
        if self.bot_inline_geo:
            flags |= (1 << 21)
        if self.support:
            flags |= (1 << 23)
        if self.scam:
            flags |= (1 << 24)
        if self.apply_min_photo:
            flags |= (1 << 25)
        if self.fake:
            flags |= (1 << 26)
        stream.pack_int64(self.id)
        if self.access_hash:
            flags |= (1 << 0)
            stream.pack_int64(self.access_hash)
        if self.first_name:
            flags |= (1 << 1)
            stream.pack_string(self.first_name)
        if self.last_name:
            flags |= (1 << 2)
            stream.pack_string(self.last_name)
        if self.username:
            flags |= (1 << 3)
            stream.pack_string(self.username)
        if self.phone:
            flags |= (1 << 4)
            stream.pack_string(self.phone)
        if self.photo:
            flags |= (1 << 5)
            stream.pack_bytes(self.photo.write())
        if self.status:
            flags |= (1 << 6)
            stream.pack_bytes(self.status.write())
        if self.bot_info_version:
            flags |= (1 << 14)
            stream.pack_int32(self.bot_info_version)
        if self.restriction_reason:
            flags |= (1 << 18)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.restriction_reason))
            for vec_k_2 in self.restriction_reason:
                stream.pack_bytes(vec_k_2.write())
        if self.bot_inline_placeholder:
            flags |= (1 << 19)
            stream.pack_string(self.bot_inline_placeholder)
        if self.lang_code:
            flags |= (1 << 22)
            stream.pack_string(self.lang_code)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(10):
            self.self_ = True
        if flags.check_bit(11):
            self.contact = True
        if flags.check_bit(12):
            self.mutual_contact = True
        if flags.check_bit(13):
            self.deleted = True
        if flags.check_bit(14):
            self.bot = True
        if flags.check_bit(15):
            self.bot_chat_history = True
        if flags.check_bit(16):
            self.bot_nochats = True
        if flags.check_bit(17):
            self.verified = True
        if flags.check_bit(18):
            self.restricted = True
        if flags.check_bit(20):
            self.min = True
        if flags.check_bit(21):
            self.bot_inline_geo = True
        if flags.check_bit(23):
            self.support = True
        if flags.check_bit(24):
            self.scam = True
        if flags.check_bit(25):
            self.apply_min_photo = True
        if flags.check_bit(26):
            self.fake = True
        self.id = data.unpack_int64()
        if flags.check_bit(0):
            self.access_hash = data.unpack_int64()
        if flags.check_bit(1):
            self.first_name = data.unpack_string()
        if flags.check_bit(2):
            self.last_name = data.unpack_string()
        if flags.check_bit(3):
            self.username = data.unpack_string()
        if flags.check_bit(4):
            self.phone = data.unpack_string()
        if flags.check_bit(5):
            self.photo = UserProfilePhoto()
            self.photo = self.photo.read(data)
        if flags.check_bit(6):
            self.status = UserStatus()
            self.status = self.status.read(data)
        if flags.check_bit(14):
            self.bot_info_version = data.unpack_int32()
        if flags.check_bit(18):
            self.restriction_reason = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = RestrictionReason()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.restriction_reason.append(elem_of_1_vec)
        if flags.check_bit(19):
            self.bot_inline_placeholder = data.unpack_string()
        if flags.check_bit(22):
            self.lang_code = data.unpack_string()
        return self

class account_updateProfile(TLObject):
    ID = 0x78515775
    def __init__(self, flags = None, first_name = None, last_name = None, about = None):
        self.flags = flags
        self.first_name = first_name
        self.last_name = last_name
        self.about = about
    def __str__(self):
        return 'account_updateProfile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.first_name:
            flags |= (1 << 0)
            stream.pack_string(self.first_name)
        if self.last_name:
            flags |= (1 << 1)
            stream.pack_string(self.last_name)
        if self.about:
            flags |= (1 << 2)
            stream.pack_string(self.about)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.first_name = data.unpack_string()
        if flags.check_bit(1):
            self.last_name = data.unpack_string()
        if flags.check_bit(2):
            self.about = data.unpack_string()
        return self

class account_updateUsername(TLObject):
    ID = 0x3e0bdd7c
    def __init__(self, username = None):
        self.username = username
    def __str__(self):
        return 'account_updateUsername'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.username)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.username = data.unpack_string()
        return self

class account_changePhone(TLObject):
    ID = 0x70c32edb
    def __init__(self, phone_number = None, phone_code_hash = None, phone_code = None):
        self.phone_number = phone_number
        self.phone_code_hash = phone_code_hash
        self.phone_code = phone_code
    def __str__(self):
        return 'account_changePhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.phone_code_hash)
        stream.pack_string(self.phone_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.phone_code_hash = data.unpack_string()
        self.phone_code = data.unpack_string()
        return self

class User(TLObject):
    DERIVED_OBJECTS = {0xd3bc4b7a: userEmpty, 0x3ff6ecb0: user, 0x78515775: account_updateProfile, 0x3e0bdd7c: account_updateUsername, 0x70c32edb: account_changePhone}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class userProfilePhotoEmpty(TLObject):
    ID = 0x4f11bae1
    def __init__(self):
        pass
    def __str__(self):
        return 'userProfilePhotoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class userProfilePhoto(TLObject):
    ID = 0x82d1f706
    def __init__(self, flags = None, has_video = None, photo_id = None, stripped_thumb = None, dc_id = None):
        self.flags = flags
        self.has_video = has_video
        self.photo_id = photo_id
        self.stripped_thumb = stripped_thumb
        self.dc_id = dc_id
    def __str__(self):
        return 'userProfilePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.has_video:
            flags |= (1 << 0)
        stream.pack_int64(self.photo_id)
        if self.stripped_thumb:
            flags |= (1 << 1)
            stream.pack_string(self.stripped_thumb)
        stream.pack_int32(self.dc_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.has_video = True
        self.photo_id = data.unpack_int64()
        if flags.check_bit(1):
            self.stripped_thumb = data.unpack_string()
        self.dc_id = data.unpack_int32()
        return self

class UserProfilePhoto(TLObject):
    DERIVED_OBJECTS = {0x4f11bae1: userProfilePhotoEmpty, 0x82d1f706: userProfilePhoto}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class userStatusEmpty(TLObject):
    ID = 0x9d05049
    def __init__(self):
        pass
    def __str__(self):
        return 'userStatusEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class userStatusOnline(TLObject):
    ID = 0xedb93949
    def __init__(self, expires = None):
        self.expires = expires
    def __str__(self):
        return 'userStatusOnline'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.expires)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.expires = data.unpack_int32()
        return self

class userStatusOffline(TLObject):
    ID = 0x8c703f
    def __init__(self, was_online = None):
        self.was_online = was_online
    def __str__(self):
        return 'userStatusOffline'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.was_online)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.was_online = data.unpack_int32()
        return self

class userStatusRecently(TLObject):
    ID = 0xe26f42f1
    def __init__(self):
        pass
    def __str__(self):
        return 'userStatusRecently'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class userStatusLastWeek(TLObject):
    ID = 0x7bf09fc
    def __init__(self):
        pass
    def __str__(self):
        return 'userStatusLastWeek'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class userStatusLastMonth(TLObject):
    ID = 0x77ebc742
    def __init__(self):
        pass
    def __str__(self):
        return 'userStatusLastMonth'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class UserStatus(TLObject):
    DERIVED_OBJECTS = {0x9d05049: userStatusEmpty, 0xedb93949: userStatusOnline, 0x8c703f: userStatusOffline, 0xe26f42f1: userStatusRecently, 0x7bf09fc: userStatusLastWeek, 0x77ebc742: userStatusLastMonth}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatEmpty(TLObject):
    ID = 0x29562865
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'chatEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class chat(TLObject):
    ID = 0x41cbf256
    def __init__(self, flags = None, creator = None, kicked = None, left = None, deactivated = None, call_active = None, call_not_empty = None, noforwards = None, id = None, title = None, photo = None, participants_count = None, date = None, version = None, migrated_to = None, admin_rights = None, default_banned_rights = None):
        self.flags = flags
        self.creator = creator
        self.kicked = kicked
        self.left = left
        self.deactivated = deactivated
        self.call_active = call_active
        self.call_not_empty = call_not_empty
        self.noforwards = noforwards
        self.id = id
        self.title = title
        self.photo = photo
        self.participants_count = participants_count
        self.date = date
        self.version = version
        self.migrated_to = migrated_to
        self.admin_rights = admin_rights
        self.default_banned_rights = default_banned_rights
    def __str__(self):
        return 'chat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.creator:
            flags |= (1 << 0)
        if self.kicked:
            flags |= (1 << 1)
        if self.left:
            flags |= (1 << 2)
        if self.deactivated:
            flags |= (1 << 5)
        if self.call_active:
            flags |= (1 << 23)
        if self.call_not_empty:
            flags |= (1 << 24)
        if self.noforwards:
            flags |= (1 << 25)
        stream.pack_int64(self.id)
        stream.pack_string(self.title)
        stream.pack_bytes(self.photo.write())
        stream.pack_int32(self.participants_count)
        stream.pack_int32(self.date)
        stream.pack_int32(self.version)
        if self.migrated_to:
            flags |= (1 << 6)
            stream.pack_bytes(self.migrated_to.write())
        if self.admin_rights:
            flags |= (1 << 14)
            stream.pack_bytes(self.admin_rights.write())
        if self.default_banned_rights:
            flags |= (1 << 18)
            stream.pack_bytes(self.default_banned_rights.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.creator = True
        if flags.check_bit(1):
            self.kicked = True
        if flags.check_bit(2):
            self.left = True
        if flags.check_bit(5):
            self.deactivated = True
        if flags.check_bit(23):
            self.call_active = True
        if flags.check_bit(24):
            self.call_not_empty = True
        if flags.check_bit(25):
            self.noforwards = True
        self.id = data.unpack_int64()
        self.title = data.unpack_string()
        self.photo = ChatPhoto()
        self.photo = self.photo.read(data)
        self.participants_count = data.unpack_int32()
        self.date = data.unpack_int32()
        self.version = data.unpack_int32()
        if flags.check_bit(6):
            self.migrated_to = InputChannel()
            self.migrated_to = self.migrated_to.read(data)
        if flags.check_bit(14):
            self.admin_rights = ChatAdminRights()
            self.admin_rights = self.admin_rights.read(data)
        if flags.check_bit(18):
            self.default_banned_rights = ChatBannedRights()
            self.default_banned_rights = self.default_banned_rights.read(data)
        return self

class chatForbidden(TLObject):
    ID = 0x6592a1a7
    def __init__(self, id = None, title = None):
        self.id = id
        self.title = title
    def __str__(self):
        return 'chatForbidden'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.title = data.unpack_string()
        return self

class channel(TLObject):
    ID = 0x8261ac61
    def __init__(self, flags = None, creator = None, left = None, broadcast = None, verified = None, megagroup = None, restricted = None, signatures = None, min = None, scam = None, has_link = None, has_geo = None, slowmode_enabled = None, call_active = None, call_not_empty = None, fake = None, gigagroup = None, noforwards = None, id = None, access_hash = None, title = None, username = None, photo = None, date = None, restriction_reason = None, admin_rights = None, banned_rights = None, default_banned_rights = None, participants_count = None):
        self.flags = flags
        self.creator = creator
        self.left = left
        self.broadcast = broadcast
        self.verified = verified
        self.megagroup = megagroup
        self.restricted = restricted
        self.signatures = signatures
        self.min = min
        self.scam = scam
        self.has_link = has_link
        self.has_geo = has_geo
        self.slowmode_enabled = slowmode_enabled
        self.call_active = call_active
        self.call_not_empty = call_not_empty
        self.fake = fake
        self.gigagroup = gigagroup
        self.noforwards = noforwards
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.username = username
        self.photo = photo
        self.date = date
        self.restriction_reason = restriction_reason
        self.admin_rights = admin_rights
        self.banned_rights = banned_rights
        self.default_banned_rights = default_banned_rights
        self.participants_count = participants_count
    def __str__(self):
        return 'channel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.creator:
            flags |= (1 << 0)
        if self.left:
            flags |= (1 << 2)
        if self.broadcast:
            flags |= (1 << 5)
        if self.verified:
            flags |= (1 << 7)
        if self.megagroup:
            flags |= (1 << 8)
        if self.restricted:
            flags |= (1 << 9)
        if self.signatures:
            flags |= (1 << 11)
        if self.min:
            flags |= (1 << 12)
        if self.scam:
            flags |= (1 << 19)
        if self.has_link:
            flags |= (1 << 20)
        if self.has_geo:
            flags |= (1 << 21)
        if self.slowmode_enabled:
            flags |= (1 << 22)
        if self.call_active:
            flags |= (1 << 23)
        if self.call_not_empty:
            flags |= (1 << 24)
        if self.fake:
            flags |= (1 << 25)
        if self.gigagroup:
            flags |= (1 << 26)
        if self.noforwards:
            flags |= (1 << 27)
        stream.pack_int64(self.id)
        if self.access_hash:
            flags |= (1 << 13)
            stream.pack_int64(self.access_hash)
        stream.pack_string(self.title)
        if self.username:
            flags |= (1 << 6)
            stream.pack_string(self.username)
        stream.pack_bytes(self.photo.write())
        stream.pack_int32(self.date)
        if self.restriction_reason:
            flags |= (1 << 9)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.restriction_reason))
            for vec_k_2 in self.restriction_reason:
                stream.pack_bytes(vec_k_2.write())
        if self.admin_rights:
            flags |= (1 << 14)
            stream.pack_bytes(self.admin_rights.write())
        if self.banned_rights:
            flags |= (1 << 15)
            stream.pack_bytes(self.banned_rights.write())
        if self.default_banned_rights:
            flags |= (1 << 18)
            stream.pack_bytes(self.default_banned_rights.write())
        if self.participants_count:
            flags |= (1 << 17)
            stream.pack_int32(self.participants_count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.creator = True
        if flags.check_bit(2):
            self.left = True
        if flags.check_bit(5):
            self.broadcast = True
        if flags.check_bit(7):
            self.verified = True
        if flags.check_bit(8):
            self.megagroup = True
        if flags.check_bit(9):
            self.restricted = True
        if flags.check_bit(11):
            self.signatures = True
        if flags.check_bit(12):
            self.min = True
        if flags.check_bit(19):
            self.scam = True
        if flags.check_bit(20):
            self.has_link = True
        if flags.check_bit(21):
            self.has_geo = True
        if flags.check_bit(22):
            self.slowmode_enabled = True
        if flags.check_bit(23):
            self.call_active = True
        if flags.check_bit(24):
            self.call_not_empty = True
        if flags.check_bit(25):
            self.fake = True
        if flags.check_bit(26):
            self.gigagroup = True
        if flags.check_bit(27):
            self.noforwards = True
        self.id = data.unpack_int64()
        if flags.check_bit(13):
            self.access_hash = data.unpack_int64()
        self.title = data.unpack_string()
        if flags.check_bit(6):
            self.username = data.unpack_string()
        self.photo = ChatPhoto()
        self.photo = self.photo.read(data)
        self.date = data.unpack_int32()
        if flags.check_bit(9):
            self.restriction_reason = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = RestrictionReason()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.restriction_reason.append(elem_of_1_vec)
        if flags.check_bit(14):
            self.admin_rights = ChatAdminRights()
            self.admin_rights = self.admin_rights.read(data)
        if flags.check_bit(15):
            self.banned_rights = ChatBannedRights()
            self.banned_rights = self.banned_rights.read(data)
        if flags.check_bit(18):
            self.default_banned_rights = ChatBannedRights()
            self.default_banned_rights = self.default_banned_rights.read(data)
        if flags.check_bit(17):
            self.participants_count = data.unpack_int32()
        return self

class channelForbidden(TLObject):
    ID = 0x17d493d5
    def __init__(self, flags = None, broadcast = None, megagroup = None, id = None, access_hash = None, title = None, until_date = None):
        self.flags = flags
        self.broadcast = broadcast
        self.megagroup = megagroup
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.until_date = until_date
    def __str__(self):
        return 'channelForbidden'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.broadcast:
            flags |= (1 << 5)
        if self.megagroup:
            flags |= (1 << 8)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.title)
        if self.until_date:
            flags |= (1 << 16)
            stream.pack_int32(self.until_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(5):
            self.broadcast = True
        if flags.check_bit(8):
            self.megagroup = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.title = data.unpack_string()
        if flags.check_bit(16):
            self.until_date = data.unpack_int32()
        return self

class Chat(TLObject):
    DERIVED_OBJECTS = {0x29562865: chatEmpty, 0x41cbf256: chat, 0x6592a1a7: chatForbidden, 0x8261ac61: channel, 0x17d493d5: channelForbidden}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatFull(TLObject):
    ID = 0x4dbdc099
    def __init__(self, flags = None, can_set_username = None, has_scheduled = None, id = None, about = None, participants = None, chat_photo = None, notify_settings = None, exported_invite = None, bot_info = None, pinned_msg_id = None, folder_id = None, call = None, ttl_period = None, groupcall_default_join_as = None, theme_emoticon = None):
        self.flags = flags
        self.can_set_username = can_set_username
        self.has_scheduled = has_scheduled
        self.id = id
        self.about = about
        self.participants = participants
        self.chat_photo = chat_photo
        self.notify_settings = notify_settings
        self.exported_invite = exported_invite
        self.bot_info = bot_info
        self.pinned_msg_id = pinned_msg_id
        self.folder_id = folder_id
        self.call = call
        self.ttl_period = ttl_period
        self.groupcall_default_join_as = groupcall_default_join_as
        self.theme_emoticon = theme_emoticon
    def __str__(self):
        return 'chatFull'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.can_set_username:
            flags |= (1 << 7)
        if self.has_scheduled:
            flags |= (1 << 8)
        stream.pack_int64(self.id)
        stream.pack_string(self.about)
        stream.pack_bytes(self.participants.write())
        if self.chat_photo:
            flags |= (1 << 2)
            stream.pack_bytes(self.chat_photo.write())
        stream.pack_bytes(self.notify_settings.write())
        if self.exported_invite:
            flags |= (1 << 13)
            stream.pack_bytes(self.exported_invite.write())
        if self.bot_info:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.bot_info))
            for vec_k_2 in self.bot_info:
                stream.pack_bytes(vec_k_2.write())
        if self.pinned_msg_id:
            flags |= (1 << 6)
            stream.pack_int32(self.pinned_msg_id)
        if self.folder_id:
            flags |= (1 << 11)
            stream.pack_int32(self.folder_id)
        if self.call:
            flags |= (1 << 12)
            stream.pack_bytes(self.call.write())
        if self.ttl_period:
            flags |= (1 << 14)
            stream.pack_int32(self.ttl_period)
        if self.groupcall_default_join_as:
            flags |= (1 << 15)
            stream.pack_bytes(self.groupcall_default_join_as.write())
        if self.theme_emoticon:
            flags |= (1 << 16)
            stream.pack_string(self.theme_emoticon)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(7):
            self.can_set_username = True
        if flags.check_bit(8):
            self.has_scheduled = True
        self.id = data.unpack_int64()
        self.about = data.unpack_string()
        self.participants = ChatParticipants()
        self.participants = self.participants.read(data)
        if flags.check_bit(2):
            self.chat_photo = Photo()
            self.chat_photo = self.chat_photo.read(data)
        self.notify_settings = PeerNotifySettings()
        self.notify_settings = self.notify_settings.read(data)
        if flags.check_bit(13):
            self.exported_invite = ExportedChatInvite()
            self.exported_invite = self.exported_invite.read(data)
        if flags.check_bit(3):
            self.bot_info = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = BotInfo()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.bot_info.append(elem_of_1_vec)
        if flags.check_bit(6):
            self.pinned_msg_id = data.unpack_int32()
        if flags.check_bit(11):
            self.folder_id = data.unpack_int32()
        if flags.check_bit(12):
            self.call = InputGroupCall()
            self.call = self.call.read(data)
        if flags.check_bit(14):
            self.ttl_period = data.unpack_int32()
        if flags.check_bit(15):
            self.groupcall_default_join_as = Peer()
            self.groupcall_default_join_as = self.groupcall_default_join_as.read(data)
        if flags.check_bit(16):
            self.theme_emoticon = data.unpack_string()
        return self

class channelFull(TLObject):
    ID = 0xe9b27a17
    def __init__(self, flags = None, can_view_participants = None, can_set_username = None, can_set_stickers = None, hidden_prehistory = None, can_set_location = None, has_scheduled = None, can_view_stats = None, blocked = None, id = None, about = None, participants_count = None, admins_count = None, kicked_count = None, banned_count = None, online_count = None, read_inbox_max_id = None, read_outbox_max_id = None, unread_count = None, chat_photo = None, notify_settings = None, exported_invite = None, bot_info = None, migrated_from_chat_id = None, migrated_from_max_id = None, pinned_msg_id = None, stickerset = None, available_min_id = None, folder_id = None, linked_chat_id = None, location = None, slowmode_seconds = None, slowmode_next_send_date = None, stats_dc = None, pts = None, call = None, ttl_period = None, pending_suggestions = None, groupcall_default_join_as = None, theme_emoticon = None):
        self.flags = flags
        self.can_view_participants = can_view_participants
        self.can_set_username = can_set_username
        self.can_set_stickers = can_set_stickers
        self.hidden_prehistory = hidden_prehistory
        self.can_set_location = can_set_location
        self.has_scheduled = has_scheduled
        self.can_view_stats = can_view_stats
        self.blocked = blocked
        self.id = id
        self.about = about
        self.participants_count = participants_count
        self.admins_count = admins_count
        self.kicked_count = kicked_count
        self.banned_count = banned_count
        self.online_count = online_count
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.chat_photo = chat_photo
        self.notify_settings = notify_settings
        self.exported_invite = exported_invite
        self.bot_info = bot_info
        self.migrated_from_chat_id = migrated_from_chat_id
        self.migrated_from_max_id = migrated_from_max_id
        self.pinned_msg_id = pinned_msg_id
        self.stickerset = stickerset
        self.available_min_id = available_min_id
        self.folder_id = folder_id
        self.linked_chat_id = linked_chat_id
        self.location = location
        self.slowmode_seconds = slowmode_seconds
        self.slowmode_next_send_date = slowmode_next_send_date
        self.stats_dc = stats_dc
        self.pts = pts
        self.call = call
        self.ttl_period = ttl_period
        self.pending_suggestions = pending_suggestions
        self.groupcall_default_join_as = groupcall_default_join_as
        self.theme_emoticon = theme_emoticon
    def __str__(self):
        return 'channelFull'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.can_view_participants:
            flags |= (1 << 3)
        if self.can_set_username:
            flags |= (1 << 6)
        if self.can_set_stickers:
            flags |= (1 << 7)
        if self.hidden_prehistory:
            flags |= (1 << 10)
        if self.can_set_location:
            flags |= (1 << 16)
        if self.has_scheduled:
            flags |= (1 << 19)
        if self.can_view_stats:
            flags |= (1 << 20)
        if self.blocked:
            flags |= (1 << 22)
        stream.pack_int64(self.id)
        stream.pack_string(self.about)
        if self.participants_count:
            flags |= (1 << 0)
            stream.pack_int32(self.participants_count)
        if self.admins_count:
            flags |= (1 << 1)
            stream.pack_int32(self.admins_count)
        if self.kicked_count:
            flags |= (1 << 2)
            stream.pack_int32(self.kicked_count)
        if self.banned_count:
            flags |= (1 << 2)
            stream.pack_int32(self.banned_count)
        if self.online_count:
            flags |= (1 << 13)
            stream.pack_int32(self.online_count)
        stream.pack_int32(self.read_inbox_max_id)
        stream.pack_int32(self.read_outbox_max_id)
        stream.pack_int32(self.unread_count)
        stream.pack_bytes(self.chat_photo.write())
        stream.pack_bytes(self.notify_settings.write())
        if self.exported_invite:
            flags |= (1 << 23)
            stream.pack_bytes(self.exported_invite.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.bot_info))
        for vec_k_2 in self.bot_info:
            stream.pack_bytes(vec_k_2.write())
        if self.migrated_from_chat_id:
            flags |= (1 << 4)
            stream.pack_int64(self.migrated_from_chat_id)
        if self.migrated_from_max_id:
            flags |= (1 << 4)
            stream.pack_int32(self.migrated_from_max_id)
        if self.pinned_msg_id:
            flags |= (1 << 5)
            stream.pack_int32(self.pinned_msg_id)
        if self.stickerset:
            flags |= (1 << 8)
            stream.pack_bytes(self.stickerset.write())
        if self.available_min_id:
            flags |= (1 << 9)
            stream.pack_int32(self.available_min_id)
        if self.folder_id:
            flags |= (1 << 11)
            stream.pack_int32(self.folder_id)
        if self.linked_chat_id:
            flags |= (1 << 14)
            stream.pack_int64(self.linked_chat_id)
        if self.location:
            flags |= (1 << 15)
            stream.pack_bytes(self.location.write())
        if self.slowmode_seconds:
            flags |= (1 << 17)
            stream.pack_int32(self.slowmode_seconds)
        if self.slowmode_next_send_date:
            flags |= (1 << 18)
            stream.pack_int32(self.slowmode_next_send_date)
        if self.stats_dc:
            flags |= (1 << 12)
            stream.pack_int32(self.stats_dc)
        stream.pack_int32(self.pts)
        if self.call:
            flags |= (1 << 21)
            stream.pack_bytes(self.call.write())
        if self.ttl_period:
            flags |= (1 << 24)
            stream.pack_int32(self.ttl_period)
        if self.pending_suggestions:
            flags |= (1 << 25)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.pending_suggestions))
            for vec_k_3 in self.pending_suggestions:
                stream.pack_string(vec_k_3)
        if self.groupcall_default_join_as:
            flags |= (1 << 26)
            stream.pack_bytes(self.groupcall_default_join_as.write())
        if self.theme_emoticon:
            flags |= (1 << 27)
            stream.pack_string(self.theme_emoticon)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(3):
            self.can_view_participants = True
        if flags.check_bit(6):
            self.can_set_username = True
        if flags.check_bit(7):
            self.can_set_stickers = True
        if flags.check_bit(10):
            self.hidden_prehistory = True
        if flags.check_bit(16):
            self.can_set_location = True
        if flags.check_bit(19):
            self.has_scheduled = True
        if flags.check_bit(20):
            self.can_view_stats = True
        if flags.check_bit(22):
            self.blocked = True
        self.id = data.unpack_int64()
        self.about = data.unpack_string()
        if flags.check_bit(0):
            self.participants_count = data.unpack_int32()
        if flags.check_bit(1):
            self.admins_count = data.unpack_int32()
        if flags.check_bit(2):
            self.kicked_count = data.unpack_int32()
        if flags.check_bit(2):
            self.banned_count = data.unpack_int32()
        if flags.check_bit(13):
            self.online_count = data.unpack_int32()
        self.read_inbox_max_id = data.unpack_int32()
        self.read_outbox_max_id = data.unpack_int32()
        self.unread_count = data.unpack_int32()
        self.chat_photo = Photo()
        self.chat_photo = self.chat_photo.read(data)
        self.notify_settings = PeerNotifySettings()
        self.notify_settings = self.notify_settings.read(data)
        if flags.check_bit(23):
            self.exported_invite = ExportedChatInvite()
            self.exported_invite = self.exported_invite.read(data)
        self.bot_info = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = BotInfo()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.bot_info.append(elem_of_1_vec)
        if flags.check_bit(4):
            self.migrated_from_chat_id = data.unpack_int64()
        if flags.check_bit(4):
            self.migrated_from_max_id = data.unpack_int32()
        if flags.check_bit(5):
            self.pinned_msg_id = data.unpack_int32()
        if flags.check_bit(8):
            self.stickerset = StickerSet()
            self.stickerset = self.stickerset.read(data)
        if flags.check_bit(9):
            self.available_min_id = data.unpack_int32()
        if flags.check_bit(11):
            self.folder_id = data.unpack_int32()
        if flags.check_bit(14):
            self.linked_chat_id = data.unpack_int64()
        if flags.check_bit(15):
            self.location = ChannelLocation()
            self.location = self.location.read(data)
        if flags.check_bit(17):
            self.slowmode_seconds = data.unpack_int32()
        if flags.check_bit(18):
            self.slowmode_next_send_date = data.unpack_int32()
        if flags.check_bit(12):
            self.stats_dc = data.unpack_int32()
        self.pts = data.unpack_int32()
        if flags.check_bit(21):
            self.call = InputGroupCall()
            self.call = self.call.read(data)
        if flags.check_bit(24):
            self.ttl_period = data.unpack_int32()
        if flags.check_bit(25):
            self.pending_suggestions = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                self.pending_suggestions.append(data.unpack_string())
        if flags.check_bit(26):
            self.groupcall_default_join_as = Peer()
            self.groupcall_default_join_as = self.groupcall_default_join_as.read(data)
        if flags.check_bit(27):
            self.theme_emoticon = data.unpack_string()
        return self

class ChatFull(TLObject):
    DERIVED_OBJECTS = {0x4dbdc099: chatFull, 0xe9b27a17: channelFull}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatParticipant(TLObject):
    ID = 0xc02d4007
    def __init__(self, user_id = None, inviter_id = None, date = None):
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date
    def __str__(self):
        return 'chatParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.inviter_id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.inviter_id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class chatParticipantCreator(TLObject):
    ID = 0xe46bcee4
    def __init__(self, user_id = None):
        self.user_id = user_id
    def __str__(self):
        return 'chatParticipantCreator'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        return self

class chatParticipantAdmin(TLObject):
    ID = 0xa0933f5b
    def __init__(self, user_id = None, inviter_id = None, date = None):
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date
    def __str__(self):
        return 'chatParticipantAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.inviter_id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.inviter_id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class ChatParticipant(TLObject):
    DERIVED_OBJECTS = {0xc02d4007: chatParticipant, 0xe46bcee4: chatParticipantCreator, 0xa0933f5b: chatParticipantAdmin}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatParticipantsForbidden(TLObject):
    ID = 0x8763d3e1
    def __init__(self, flags = None, chat_id = None, self_participant = None):
        self.flags = flags
        self.chat_id = chat_id
        self.self_participant = self_participant
    def __str__(self):
        return 'chatParticipantsForbidden'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        flags = 0x0
        if self.self_participant:
            flags |= (1 << 0)
            stream.pack_bytes(self.self_participant.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.chat_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.self_participant = ChatParticipant()
            self.self_participant = self.self_participant.read(data)
        return self

class chatParticipants(TLObject):
    ID = 0x3cbc93f8
    def __init__(self, chat_id = None, participants = None, version = None):
        self.chat_id = chat_id
        self.participants = participants
        self.version = version
    def __str__(self):
        return 'chatParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.participants))
        for vec_k_2 in self.participants:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.participants = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ChatParticipant()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.participants.append(elem_of_1_vec)
        self.version = data.unpack_int32()
        return self

class ChatParticipants(TLObject):
    DERIVED_OBJECTS = {0x8763d3e1: chatParticipantsForbidden, 0x3cbc93f8: chatParticipants}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatPhotoEmpty(TLObject):
    ID = 0x37c1011c
    def __init__(self):
        pass
    def __str__(self):
        return 'chatPhotoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class chatPhoto(TLObject):
    ID = 0x1c6e1c11
    def __init__(self, flags = None, has_video = None, photo_id = None, stripped_thumb = None, dc_id = None):
        self.flags = flags
        self.has_video = has_video
        self.photo_id = photo_id
        self.stripped_thumb = stripped_thumb
        self.dc_id = dc_id
    def __str__(self):
        return 'chatPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.has_video:
            flags |= (1 << 0)
        stream.pack_int64(self.photo_id)
        if self.stripped_thumb:
            flags |= (1 << 1)
            stream.pack_string(self.stripped_thumb)
        stream.pack_int32(self.dc_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.has_video = True
        self.photo_id = data.unpack_int64()
        if flags.check_bit(1):
            self.stripped_thumb = data.unpack_string()
        self.dc_id = data.unpack_int32()
        return self

class ChatPhoto(TLObject):
    DERIVED_OBJECTS = {0x37c1011c: chatPhotoEmpty, 0x1c6e1c11: chatPhoto}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageEmpty(TLObject):
    ID = 0x90a6ca84
    def __init__(self, flags = None, id = None, peer_id = None):
        self.flags = flags
        self.id = id
        self.peer_id = peer_id
    def __str__(self):
        return 'messageEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        flags = 0x0
        if self.peer_id:
            flags |= (1 << 0)
            stream.pack_bytes(self.peer_id.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.peer_id = Peer()
            self.peer_id = self.peer_id.read(data)
        return self

class message(TLObject):
    ID = 0x85d6cbe2
    def __init__(self, flags = None, out = None, mentioned = None, media_unread = None, silent = None, post = None, from_scheduled = None, legacy = None, edit_hide = None, pinned = None, id = None, from_id = None, peer_id = None, fwd_from = None, via_bot_id = None, reply_to = None, date = None, message = None, media = None, reply_markup = None, entities = None, views = None, forwards = None, replies = None, edit_date = None, post_author = None, grouped_id = None, restriction_reason = None, ttl_period = None):
        self.flags = flags
        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.post = post
        self.from_scheduled = from_scheduled
        self.legacy = legacy
        self.edit_hide = edit_hide
        self.pinned = pinned
        self.id = id
        self.from_id = from_id
        self.peer_id = peer_id
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to = reply_to
        self.date = date
        self.message = message
        self.media = media
        self.reply_markup = reply_markup
        self.entities = entities
        self.views = views
        self.forwards = forwards
        self.replies = replies
        self.edit_date = edit_date
        self.post_author = post_author
        self.grouped_id = grouped_id
        self.restriction_reason = restriction_reason
        self.ttl_period = ttl_period
    def __str__(self):
        return 'message'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.out:
            flags |= (1 << 1)
        if self.mentioned:
            flags |= (1 << 4)
        if self.media_unread:
            flags |= (1 << 5)
        if self.silent:
            flags |= (1 << 13)
        if self.post:
            flags |= (1 << 14)
        if self.from_scheduled:
            flags |= (1 << 18)
        if self.legacy:
            flags |= (1 << 19)
        if self.edit_hide:
            flags |= (1 << 21)
        if self.pinned:
            flags |= (1 << 24)
        stream.pack_int32(self.id)
        if self.from_id:
            flags |= (1 << 8)
            stream.pack_bytes(self.from_id.write())
        stream.pack_bytes(self.peer_id.write())
        if self.fwd_from:
            flags |= (1 << 2)
            stream.pack_bytes(self.fwd_from.write())
        if self.via_bot_id:
            flags |= (1 << 11)
            stream.pack_int64(self.via_bot_id)
        if self.reply_to:
            flags |= (1 << 3)
            stream.pack_bytes(self.reply_to.write())
        stream.pack_int32(self.date)
        stream.pack_string(self.message)
        if self.media:
            flags |= (1 << 9)
            stream.pack_bytes(self.media.write())
        if self.reply_markup:
            flags |= (1 << 6)
            stream.pack_bytes(self.reply_markup.write())
        if self.entities:
            flags |= (1 << 7)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.views:
            flags |= (1 << 10)
            stream.pack_int32(self.views)
        if self.forwards:
            flags |= (1 << 10)
            stream.pack_int32(self.forwards)
        if self.replies:
            flags |= (1 << 23)
            stream.pack_bytes(self.replies.write())
        if self.edit_date:
            flags |= (1 << 15)
            stream.pack_int32(self.edit_date)
        if self.post_author:
            flags |= (1 << 16)
            stream.pack_string(self.post_author)
        if self.grouped_id:
            flags |= (1 << 17)
            stream.pack_int64(self.grouped_id)
        if self.restriction_reason:
            flags |= (1 << 22)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.restriction_reason))
            for vec_k_3 in self.restriction_reason:
                stream.pack_bytes(vec_k_3.write())
        if self.ttl_period:
            flags |= (1 << 25)
            stream.pack_int32(self.ttl_period)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.out = True
        if flags.check_bit(4):
            self.mentioned = True
        if flags.check_bit(5):
            self.media_unread = True
        if flags.check_bit(13):
            self.silent = True
        if flags.check_bit(14):
            self.post = True
        if flags.check_bit(18):
            self.from_scheduled = True
        if flags.check_bit(19):
            self.legacy = True
        if flags.check_bit(21):
            self.edit_hide = True
        if flags.check_bit(24):
            self.pinned = True
        self.id = data.unpack_int32()
        if flags.check_bit(8):
            self.from_id = Peer()
            self.from_id = self.from_id.read(data)
        self.peer_id = Peer()
        self.peer_id = self.peer_id.read(data)
        if flags.check_bit(2):
            self.fwd_from = MessageFwdHeader()
            self.fwd_from = self.fwd_from.read(data)
        if flags.check_bit(11):
            self.via_bot_id = data.unpack_int64()
        if flags.check_bit(3):
            self.reply_to = MessageReplyHeader()
            self.reply_to = self.reply_to.read(data)
        self.date = data.unpack_int32()
        self.message = data.unpack_string()
        if flags.check_bit(9):
            self.media = MessageMedia()
            self.media = self.media.read(data)
        if flags.check_bit(6):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        if flags.check_bit(7):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(10):
            self.views = data.unpack_int32()
        if flags.check_bit(10):
            self.forwards = data.unpack_int32()
        if flags.check_bit(23):
            self.replies = MessageReplies()
            self.replies = self.replies.read(data)
        if flags.check_bit(15):
            self.edit_date = data.unpack_int32()
        if flags.check_bit(16):
            self.post_author = data.unpack_string()
        if flags.check_bit(17):
            self.grouped_id = data.unpack_int64()
        if flags.check_bit(22):
            self.restriction_reason = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = RestrictionReason()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.restriction_reason.append(elem_of_2_vec)
        if flags.check_bit(25):
            self.ttl_period = data.unpack_int32()
        return self

class messageService(TLObject):
    ID = 0x2b085862
    def __init__(self, flags = None, out = None, mentioned = None, media_unread = None, silent = None, post = None, legacy = None, id = None, from_id = None, peer_id = None, reply_to = None, date = None, action = None, ttl_period = None):
        self.flags = flags
        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.post = post
        self.legacy = legacy
        self.id = id
        self.from_id = from_id
        self.peer_id = peer_id
        self.reply_to = reply_to
        self.date = date
        self.action = action
        self.ttl_period = ttl_period
    def __str__(self):
        return 'messageService'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.out:
            flags |= (1 << 1)
        if self.mentioned:
            flags |= (1 << 4)
        if self.media_unread:
            flags |= (1 << 5)
        if self.silent:
            flags |= (1 << 13)
        if self.post:
            flags |= (1 << 14)
        if self.legacy:
            flags |= (1 << 19)
        stream.pack_int32(self.id)
        if self.from_id:
            flags |= (1 << 8)
            stream.pack_bytes(self.from_id.write())
        stream.pack_bytes(self.peer_id.write())
        if self.reply_to:
            flags |= (1 << 3)
            stream.pack_bytes(self.reply_to.write())
        stream.pack_int32(self.date)
        stream.pack_bytes(self.action.write())
        if self.ttl_period:
            flags |= (1 << 25)
            stream.pack_int32(self.ttl_period)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.out = True
        if flags.check_bit(4):
            self.mentioned = True
        if flags.check_bit(5):
            self.media_unread = True
        if flags.check_bit(13):
            self.silent = True
        if flags.check_bit(14):
            self.post = True
        if flags.check_bit(19):
            self.legacy = True
        self.id = data.unpack_int32()
        if flags.check_bit(8):
            self.from_id = Peer()
            self.from_id = self.from_id.read(data)
        self.peer_id = Peer()
        self.peer_id = self.peer_id.read(data)
        if flags.check_bit(3):
            self.reply_to = MessageReplyHeader()
            self.reply_to = self.reply_to.read(data)
        self.date = data.unpack_int32()
        self.action = MessageAction()
        self.action = self.action.read(data)
        if flags.check_bit(25):
            self.ttl_period = data.unpack_int32()
        return self

class Message(TLObject):
    DERIVED_OBJECTS = {0x90a6ca84: messageEmpty, 0x85d6cbe2: message, 0x2b085862: messageService}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageMediaEmpty(TLObject):
    ID = 0x3ded6320
    def __init__(self):
        pass
    def __str__(self):
        return 'messageMediaEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageMediaPhoto(TLObject):
    ID = 0x695150d7
    def __init__(self, flags = None, photo = None, ttl_seconds = None):
        self.flags = flags
        self.photo = photo
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'messageMediaPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.photo:
            flags |= (1 << 0)
            stream.pack_bytes(self.photo.write())
        if self.ttl_seconds:
            flags |= (1 << 2)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.photo = Photo()
            self.photo = self.photo.read(data)
        if flags.check_bit(2):
            self.ttl_seconds = data.unpack_int32()
        return self

class messageMediaGeo(TLObject):
    ID = 0x56e0d474
    def __init__(self, geo = None):
        self.geo = geo
    def __str__(self):
        return 'messageMediaGeo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo = GeoPoint()
        self.geo = self.geo.read(data)
        return self

class messageMediaContact(TLObject):
    ID = 0x70322949
    def __init__(self, phone_number = None, first_name = None, last_name = None, vcard = None, user_id = None):
        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.vcard = vcard
        self.user_id = user_id
    def __str__(self):
        return 'messageMediaContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_string(self.vcard)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.vcard = data.unpack_string()
        self.user_id = data.unpack_int64()
        return self

class messageMediaUnsupported(TLObject):
    ID = 0x9f84f49e
    def __init__(self):
        pass
    def __str__(self):
        return 'messageMediaUnsupported'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageMediaDocument(TLObject):
    ID = 0x9cb070d7
    def __init__(self, flags = None, document = None, ttl_seconds = None):
        self.flags = flags
        self.document = document
        self.ttl_seconds = ttl_seconds
    def __str__(self):
        return 'messageMediaDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.document:
            flags |= (1 << 0)
            stream.pack_bytes(self.document.write())
        if self.ttl_seconds:
            flags |= (1 << 2)
            stream.pack_int32(self.ttl_seconds)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.document = Document()
            self.document = self.document.read(data)
        if flags.check_bit(2):
            self.ttl_seconds = data.unpack_int32()
        return self

class messageMediaWebPage(TLObject):
    ID = 0xa32dd600
    def __init__(self, webpage = None):
        self.webpage = webpage
    def __str__(self):
        return 'messageMediaWebPage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.webpage.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.webpage = WebPage()
        self.webpage = self.webpage.read(data)
        return self

class messageMediaVenue(TLObject):
    ID = 0x2ec0533f
    def __init__(self, geo = None, title = None, address = None, provider = None, venue_id = None, venue_type = None):
        self.geo = geo
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.venue_type = venue_type
    def __str__(self):
        return 'messageMediaVenue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo.write())
        stream.pack_string(self.title)
        stream.pack_string(self.address)
        stream.pack_string(self.provider)
        stream.pack_string(self.venue_id)
        stream.pack_string(self.venue_type)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo = GeoPoint()
        self.geo = self.geo.read(data)
        self.title = data.unpack_string()
        self.address = data.unpack_string()
        self.provider = data.unpack_string()
        self.venue_id = data.unpack_string()
        self.venue_type = data.unpack_string()
        return self

class messageMediaGame(TLObject):
    ID = 0xfdb19008
    def __init__(self, game = None):
        self.game = game
    def __str__(self):
        return 'messageMediaGame'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.game.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.game = Game()
        self.game = self.game.read(data)
        return self

class messageMediaInvoice(TLObject):
    ID = 0x84551347
    def __init__(self, flags = None, shipping_address_requested = None, test = None, title = None, description = None, photo = None, receipt_msg_id = None, currency = None, total_amount = None, start_param = None):
        self.flags = flags
        self.shipping_address_requested = shipping_address_requested
        self.test = test
        self.title = title
        self.description = description
        self.photo = photo
        self.receipt_msg_id = receipt_msg_id
        self.currency = currency
        self.total_amount = total_amount
        self.start_param = start_param
    def __str__(self):
        return 'messageMediaInvoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.shipping_address_requested:
            flags |= (1 << 1)
        if self.test:
            flags |= (1 << 3)
        stream.pack_string(self.title)
        stream.pack_string(self.description)
        if self.photo:
            flags |= (1 << 0)
            stream.pack_bytes(self.photo.write())
        if self.receipt_msg_id:
            flags |= (1 << 2)
            stream.pack_int32(self.receipt_msg_id)
        stream.pack_string(self.currency)
        stream.pack_int64(self.total_amount)
        stream.pack_string(self.start_param)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.shipping_address_requested = True
        if flags.check_bit(3):
            self.test = True
        self.title = data.unpack_string()
        self.description = data.unpack_string()
        if flags.check_bit(0):
            self.photo = WebDocument()
            self.photo = self.photo.read(data)
        if flags.check_bit(2):
            self.receipt_msg_id = data.unpack_int32()
        self.currency = data.unpack_string()
        self.total_amount = data.unpack_int64()
        self.start_param = data.unpack_string()
        return self

class messageMediaGeoLive(TLObject):
    ID = 0xb940c666
    def __init__(self, flags = None, geo = None, heading = None, period = None, proximity_notification_radius = None):
        self.flags = flags
        self.geo = geo
        self.heading = heading
        self.period = period
        self.proximity_notification_radius = proximity_notification_radius
    def __str__(self):
        return 'messageMediaGeoLive'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo.write())
        flags = 0x0
        if self.heading:
            flags |= (1 << 0)
            stream.pack_int32(self.heading)
        stream.pack_int32(self.period)
        if self.proximity_notification_radius:
            flags |= (1 << 1)
            stream.pack_int32(self.proximity_notification_radius)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.geo = GeoPoint()
        self.geo = self.geo.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.heading = data.unpack_int32()
        self.period = data.unpack_int32()
        if flags.check_bit(1):
            self.proximity_notification_radius = data.unpack_int32()
        return self

class messageMediaPoll(TLObject):
    ID = 0x4bd6e798
    def __init__(self, poll = None, results = None):
        self.poll = poll
        self.results = results
    def __str__(self):
        return 'messageMediaPoll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.poll.write())
        stream.pack_bytes(self.results.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.poll = Poll()
        self.poll = self.poll.read(data)
        self.results = PollResults()
        self.results = self.results.read(data)
        return self

class messageMediaDice(TLObject):
    ID = 0x3f7ee58b
    def __init__(self, value = None, emoticon = None):
        self.value = value
        self.emoticon = emoticon
    def __str__(self):
        return 'messageMediaDice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.value)
        stream.pack_string(self.emoticon)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = data.unpack_int32()
        self.emoticon = data.unpack_string()
        return self

class messages_getWebPagePreview(TLObject):
    ID = 0x8b68b0cc
    def __init__(self, flags = None, message = None, entities = None):
        self.flags = flags
        self.message = message
        self.entities = entities
    def __str__(self):
        return 'messages_getWebPagePreview'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.message)
        flags = 0x0
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.message = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        return self

class messages_uploadMedia(TLObject):
    ID = 0x519bc2b1
    def __init__(self, peer = None, media = None):
        self.peer = peer
        self.media = media
    def __str__(self):
        return 'messages_uploadMedia'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.media.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.media = InputMedia()
        self.media = self.media.read(data)
        return self

class messages_uploadImportedMedia(TLObject):
    ID = 0x2a862092
    def __init__(self, peer = None, import_id = None, file_name = None, media = None):
        self.peer = peer
        self.import_id = import_id
        self.file_name = file_name
        self.media = media
    def __str__(self):
        return 'messages_uploadImportedMedia'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.import_id)
        stream.pack_string(self.file_name)
        stream.pack_bytes(self.media.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.import_id = data.unpack_int64()
        self.file_name = data.unpack_string()
        self.media = InputMedia()
        self.media = self.media.read(data)
        return self

class MessageMedia(TLObject):
    DERIVED_OBJECTS = {0x3ded6320: messageMediaEmpty, 0x695150d7: messageMediaPhoto, 0x56e0d474: messageMediaGeo, 0x70322949: messageMediaContact, 0x9f84f49e: messageMediaUnsupported, 0x9cb070d7: messageMediaDocument, 0xa32dd600: messageMediaWebPage, 0x2ec0533f: messageMediaVenue, 0xfdb19008: messageMediaGame, 0x84551347: messageMediaInvoice, 0xb940c666: messageMediaGeoLive, 0x4bd6e798: messageMediaPoll, 0x3f7ee58b: messageMediaDice, 0x8b68b0cc: messages_getWebPagePreview, 0x519bc2b1: messages_uploadMedia, 0x2a862092: messages_uploadImportedMedia}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageActionEmpty(TLObject):
    ID = 0xb6aef7b0
    def __init__(self):
        pass
    def __str__(self):
        return 'messageActionEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageActionChatCreate(TLObject):
    ID = 0xbd47cbad
    def __init__(self, title = None, users = None):
        self.title = title
        self.users = users
    def __str__(self):
        return 'messageActionChatCreate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = data.unpack_string()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.users.append(data.unpack_int64())
        return self

class messageActionChatEditTitle(TLObject):
    ID = 0xb5a1ce5a
    def __init__(self, title = None):
        self.title = title
    def __str__(self):
        return 'messageActionChatEditTitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = data.unpack_string()
        return self

class messageActionChatEditPhoto(TLObject):
    ID = 0x7fcb13a8
    def __init__(self, photo = None):
        self.photo = photo
    def __str__(self):
        return 'messageActionChatEditPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.photo.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.photo = Photo()
        self.photo = self.photo.read(data)
        return self

class messageActionChatDeletePhoto(TLObject):
    ID = 0x95e3fbef
    def __init__(self):
        pass
    def __str__(self):
        return 'messageActionChatDeletePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageActionChatAddUser(TLObject):
    ID = 0x15cefd00
    def __init__(self, users = None):
        self.users = users
    def __str__(self):
        return 'messageActionChatAddUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.users.append(data.unpack_int64())
        return self

class messageActionChatDeleteUser(TLObject):
    ID = 0xa43f30cc
    def __init__(self, user_id = None):
        self.user_id = user_id
    def __str__(self):
        return 'messageActionChatDeleteUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        return self

class messageActionChatJoinedByLink(TLObject):
    ID = 0x31224c3
    def __init__(self, inviter_id = None):
        self.inviter_id = inviter_id
    def __str__(self):
        return 'messageActionChatJoinedByLink'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.inviter_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.inviter_id = data.unpack_int64()
        return self

class messageActionChannelCreate(TLObject):
    ID = 0x95d2ac92
    def __init__(self, title = None):
        self.title = title
    def __str__(self):
        return 'messageActionChannelCreate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = data.unpack_string()
        return self

class messageActionChatMigrateTo(TLObject):
    ID = 0xe1037f92
    def __init__(self, channel_id = None):
        self.channel_id = channel_id
    def __str__(self):
        return 'messageActionChatMigrateTo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        return self

class messageActionChannelMigrateFrom(TLObject):
    ID = 0xea3948e9
    def __init__(self, title = None, chat_id = None):
        self.title = title
        self.chat_id = chat_id
    def __str__(self):
        return 'messageActionChannelMigrateFrom'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = data.unpack_string()
        self.chat_id = data.unpack_int64()
        return self

class messageActionPinMessage(TLObject):
    ID = 0x94bd38ed
    def __init__(self):
        pass
    def __str__(self):
        return 'messageActionPinMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageActionHistoryClear(TLObject):
    ID = 0x9fbab604
    def __init__(self):
        pass
    def __str__(self):
        return 'messageActionHistoryClear'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageActionGameScore(TLObject):
    ID = 0x92a72876
    def __init__(self, game_id = None, score = None):
        self.game_id = game_id
        self.score = score
    def __str__(self):
        return 'messageActionGameScore'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.game_id)
        stream.pack_int32(self.score)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.game_id = data.unpack_int64()
        self.score = data.unpack_int32()
        return self

class messageActionPaymentSentMe(TLObject):
    ID = 0x8f31b327
    def __init__(self, flags = None, currency = None, total_amount = None, payload = None, info = None, shipping_option_id = None, charge = None):
        self.flags = flags
        self.currency = currency
        self.total_amount = total_amount
        self.payload = payload
        self.info = info
        self.shipping_option_id = shipping_option_id
        self.charge = charge
    def __str__(self):
        return 'messageActionPaymentSentMe'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.currency)
        stream.pack_int64(self.total_amount)
        stream.pack_string(self.payload)
        flags = 0x0
        if self.info:
            flags |= (1 << 0)
            stream.pack_bytes(self.info.write())
        if self.shipping_option_id:
            flags |= (1 << 1)
            stream.pack_string(self.shipping_option_id)
        stream.pack_bytes(self.charge.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.currency = data.unpack_string()
        self.total_amount = data.unpack_int64()
        self.payload = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.info = PaymentRequestedInfo()
            self.info = self.info.read(data)
        if flags.check_bit(1):
            self.shipping_option_id = data.unpack_string()
        self.charge = PaymentCharge()
        self.charge = self.charge.read(data)
        return self

class messageActionPaymentSent(TLObject):
    ID = 0x40699cd0
    def __init__(self, currency = None, total_amount = None):
        self.currency = currency
        self.total_amount = total_amount
    def __str__(self):
        return 'messageActionPaymentSent'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.currency)
        stream.pack_int64(self.total_amount)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.currency = data.unpack_string()
        self.total_amount = data.unpack_int64()
        return self

class messageActionPhoneCall(TLObject):
    ID = 0x80e11a7f
    def __init__(self, flags = None, video = None, call_id = None, reason = None, duration = None):
        self.flags = flags
        self.video = video
        self.call_id = call_id
        self.reason = reason
        self.duration = duration
    def __str__(self):
        return 'messageActionPhoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.video:
            flags |= (1 << 2)
        stream.pack_int64(self.call_id)
        if self.reason:
            flags |= (1 << 0)
            stream.pack_bytes(self.reason.write())
        if self.duration:
            flags |= (1 << 1)
            stream.pack_int32(self.duration)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.video = True
        self.call_id = data.unpack_int64()
        if flags.check_bit(0):
            self.reason = PhoneCallDiscardReason()
            self.reason = self.reason.read(data)
        if flags.check_bit(1):
            self.duration = data.unpack_int32()
        return self

class messageActionScreenshotTaken(TLObject):
    ID = 0x4792929b
    def __init__(self):
        pass
    def __str__(self):
        return 'messageActionScreenshotTaken'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageActionCustomAction(TLObject):
    ID = 0xfae69f56
    def __init__(self, message = None):
        self.message = message
    def __str__(self):
        return 'messageActionCustomAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = data.unpack_string()
        return self

class messageActionBotAllowed(TLObject):
    ID = 0xabe9affe
    def __init__(self, domain = None):
        self.domain = domain
    def __str__(self):
        return 'messageActionBotAllowed'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.domain)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.domain = data.unpack_string()
        return self

class messageActionSecureValuesSentMe(TLObject):
    ID = 0x1b287353
    def __init__(self, values = None, credentials = None):
        self.values = values
        self.credentials = credentials
    def __str__(self):
        return 'messageActionSecureValuesSentMe'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.values))
        for vec_k_2 in self.values:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_bytes(self.credentials.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.values = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureValue()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.values.append(elem_of_1_vec)
        self.credentials = SecureCredentialsEncrypted()
        self.credentials = self.credentials.read(data)
        return self

class messageActionSecureValuesSent(TLObject):
    ID = 0xd95c6154
    def __init__(self, types = None):
        self.types = types
    def __str__(self):
        return 'messageActionSecureValuesSent'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.types))
        for vec_k_2 in self.types:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.types = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureValueType()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.types.append(elem_of_1_vec)
        return self

class messageActionContactSignUp(TLObject):
    ID = 0xf3f25f76
    def __init__(self):
        pass
    def __str__(self):
        return 'messageActionContactSignUp'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messageActionGeoProximityReached(TLObject):
    ID = 0x98e0d697
    def __init__(self, from_id = None, to_id = None, distance = None):
        self.from_id = from_id
        self.to_id = to_id
        self.distance = distance
    def __str__(self):
        return 'messageActionGeoProximityReached'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.from_id.write())
        stream.pack_bytes(self.to_id.write())
        stream.pack_int32(self.distance)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.from_id = Peer()
        self.from_id = self.from_id.read(data)
        self.to_id = Peer()
        self.to_id = self.to_id.read(data)
        self.distance = data.unpack_int32()
        return self

class messageActionGroupCall(TLObject):
    ID = 0x7a0d7f42
    def __init__(self, flags = None, call = None, duration = None):
        self.flags = flags
        self.call = call
        self.duration = duration
    def __str__(self):
        return 'messageActionGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        flags = 0x0
        if self.duration:
            flags |= (1 << 0)
            stream.pack_int32(self.duration)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.duration = data.unpack_int32()
        return self

class messageActionInviteToGroupCall(TLObject):
    ID = 0x502f92f7
    def __init__(self, call = None, users = None):
        self.call = call
        self.users = users
    def __str__(self):
        return 'messageActionInviteToGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.users.append(data.unpack_int64())
        return self

class messageActionSetMessagesTTL(TLObject):
    ID = 0xaa1afbfd
    def __init__(self, period = None):
        self.period = period
    def __str__(self):
        return 'messageActionSetMessagesTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.period)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.period = data.unpack_int32()
        return self

class messageActionGroupCallScheduled(TLObject):
    ID = 0xb3a07661
    def __init__(self, call = None, schedule_date = None):
        self.call = call
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messageActionGroupCallScheduled'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.schedule_date = data.unpack_int32()
        return self

class messageActionSetChatTheme(TLObject):
    ID = 0xaa786345
    def __init__(self, emoticon = None):
        self.emoticon = emoticon
    def __str__(self):
        return 'messageActionSetChatTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        return self

class MessageAction(TLObject):
    DERIVED_OBJECTS = {0xb6aef7b0: messageActionEmpty, 0xbd47cbad: messageActionChatCreate, 0xb5a1ce5a: messageActionChatEditTitle, 0x7fcb13a8: messageActionChatEditPhoto, 0x95e3fbef: messageActionChatDeletePhoto, 0x15cefd00: messageActionChatAddUser, 0xa43f30cc: messageActionChatDeleteUser, 0x31224c3: messageActionChatJoinedByLink, 0x95d2ac92: messageActionChannelCreate, 0xe1037f92: messageActionChatMigrateTo, 0xea3948e9: messageActionChannelMigrateFrom, 0x94bd38ed: messageActionPinMessage, 0x9fbab604: messageActionHistoryClear, 0x92a72876: messageActionGameScore, 0x8f31b327: messageActionPaymentSentMe, 0x40699cd0: messageActionPaymentSent, 0x80e11a7f: messageActionPhoneCall, 0x4792929b: messageActionScreenshotTaken, 0xfae69f56: messageActionCustomAction, 0xabe9affe: messageActionBotAllowed, 0x1b287353: messageActionSecureValuesSentMe, 0xd95c6154: messageActionSecureValuesSent, 0xf3f25f76: messageActionContactSignUp, 0x98e0d697: messageActionGeoProximityReached, 0x7a0d7f42: messageActionGroupCall, 0x502f92f7: messageActionInviteToGroupCall, 0xaa1afbfd: messageActionSetMessagesTTL, 0xb3a07661: messageActionGroupCallScheduled, 0xaa786345: messageActionSetChatTheme}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class dialog(TLObject):
    ID = 0x2c171f72
    def __init__(self, flags = None, pinned = None, unread_mark = None, peer = None, top_message = None, read_inbox_max_id = None, read_outbox_max_id = None, unread_count = None, unread_mentions_count = None, notify_settings = None, pts = None, draft = None, folder_id = None):
        self.flags = flags
        self.pinned = pinned
        self.unread_mark = unread_mark
        self.peer = peer
        self.top_message = top_message
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.unread_mentions_count = unread_mentions_count
        self.notify_settings = notify_settings
        self.pts = pts
        self.draft = draft
        self.folder_id = folder_id
    def __str__(self):
        return 'dialog'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pinned:
            flags |= (1 << 2)
        if self.unread_mark:
            flags |= (1 << 3)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.top_message)
        stream.pack_int32(self.read_inbox_max_id)
        stream.pack_int32(self.read_outbox_max_id)
        stream.pack_int32(self.unread_count)
        stream.pack_int32(self.unread_mentions_count)
        stream.pack_bytes(self.notify_settings.write())
        if self.pts:
            flags |= (1 << 0)
            stream.pack_int32(self.pts)
        if self.draft:
            flags |= (1 << 1)
            stream.pack_bytes(self.draft.write())
        if self.folder_id:
            flags |= (1 << 4)
            stream.pack_int32(self.folder_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.pinned = True
        if flags.check_bit(3):
            self.unread_mark = True
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.top_message = data.unpack_int32()
        self.read_inbox_max_id = data.unpack_int32()
        self.read_outbox_max_id = data.unpack_int32()
        self.unread_count = data.unpack_int32()
        self.unread_mentions_count = data.unpack_int32()
        self.notify_settings = PeerNotifySettings()
        self.notify_settings = self.notify_settings.read(data)
        if flags.check_bit(0):
            self.pts = data.unpack_int32()
        if flags.check_bit(1):
            self.draft = DraftMessage()
            self.draft = self.draft.read(data)
        if flags.check_bit(4):
            self.folder_id = data.unpack_int32()
        return self

class dialogFolder(TLObject):
    ID = 0x71bd134c
    def __init__(self, flags = None, pinned = None, folder = None, peer = None, top_message = None, unread_muted_peers_count = None, unread_unmuted_peers_count = None, unread_muted_messages_count = None, unread_unmuted_messages_count = None):
        self.flags = flags
        self.pinned = pinned
        self.folder = folder
        self.peer = peer
        self.top_message = top_message
        self.unread_muted_peers_count = unread_muted_peers_count
        self.unread_unmuted_peers_count = unread_unmuted_peers_count
        self.unread_muted_messages_count = unread_muted_messages_count
        self.unread_unmuted_messages_count = unread_unmuted_messages_count
    def __str__(self):
        return 'dialogFolder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pinned:
            flags |= (1 << 2)
        stream.pack_bytes(self.folder.write())
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.top_message)
        stream.pack_int32(self.unread_muted_peers_count)
        stream.pack_int32(self.unread_unmuted_peers_count)
        stream.pack_int32(self.unread_muted_messages_count)
        stream.pack_int32(self.unread_unmuted_messages_count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.pinned = True
        self.folder = Folder()
        self.folder = self.folder.read(data)
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.top_message = data.unpack_int32()
        self.unread_muted_peers_count = data.unpack_int32()
        self.unread_unmuted_peers_count = data.unpack_int32()
        self.unread_muted_messages_count = data.unpack_int32()
        self.unread_unmuted_messages_count = data.unpack_int32()
        return self

class Dialog(TLObject):
    DERIVED_OBJECTS = {0x2c171f72: dialog, 0x71bd134c: dialogFolder}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class photoEmpty(TLObject):
    ID = 0x2331b22d
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'photoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class photo(TLObject):
    ID = 0xfb197a65
    def __init__(self, flags = None, has_stickers = None, id = None, access_hash = None, file_reference = None, date = None, sizes = None, video_sizes = None, dc_id = None):
        self.flags = flags
        self.has_stickers = has_stickers
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
        self.date = date
        self.sizes = sizes
        self.video_sizes = video_sizes
        self.dc_id = dc_id
    def __str__(self):
        return 'photo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.has_stickers:
            flags |= (1 << 0)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        stream.pack_int32(self.date)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sizes))
        for vec_k_2 in self.sizes:
            stream.pack_bytes(vec_k_2.write())
        if self.video_sizes:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.video_sizes))
            for vec_k_3 in self.video_sizes:
                stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(self.dc_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.has_stickers = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        self.date = data.unpack_int32()
        self.sizes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PhotoSize()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.sizes.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.video_sizes = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = VideoSize()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.video_sizes.append(elem_of_2_vec)
        self.dc_id = data.unpack_int32()
        return self

class Photo(TLObject):
    DERIVED_OBJECTS = {0x2331b22d: photoEmpty, 0xfb197a65: photo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class photoSizeEmpty(TLObject):
    ID = 0xe17e23c
    def __init__(self, type = None):
        self.type = type
    def __str__(self):
        return 'photoSizeEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = data.unpack_string()
        return self

class photoSize(TLObject):
    ID = 0x75c78e60
    def __init__(self, type = None, w = None, h = None, size = None):
        self.type = type
        self.w = w
        self.h = h
        self.size = size
    def __str__(self):
        return 'photoSize'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        stream.pack_int32(self.size)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = data.unpack_string()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        self.size = data.unpack_int32()
        return self

class photoCachedSize(TLObject):
    ID = 0x21e1ad6
    def __init__(self, type = None, w = None, h = None, bytes = None):
        self.type = type
        self.w = w
        self.h = h
        self.bytes = bytes
    def __str__(self):
        return 'photoCachedSize'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = data.unpack_string()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        self.bytes = data.unpack_string()
        return self

class photoStrippedSize(TLObject):
    ID = 0xe0b0bc2e
    def __init__(self, type = None, bytes = None):
        self.type = type
        self.bytes = bytes
    def __str__(self):
        return 'photoStrippedSize'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = data.unpack_string()
        self.bytes = data.unpack_string()
        return self

class photoSizeProgressive(TLObject):
    ID = 0xfa3efb95
    def __init__(self, type = None, w = None, h = None, sizes = None):
        self.type = type
        self.w = w
        self.h = h
        self.sizes = sizes
    def __str__(self):
        return 'photoSizeProgressive'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sizes))
        for vec_k_2 in self.sizes:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = data.unpack_string()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        self.sizes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.sizes.append(data.unpack_int32())
        return self

class photoPathSize(TLObject):
    ID = 0xd8214d41
    def __init__(self, type = None, bytes = None):
        self.type = type
        self.bytes = bytes
    def __str__(self):
        return 'photoPathSize'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = data.unpack_string()
        self.bytes = data.unpack_string()
        return self

class PhotoSize(TLObject):
    DERIVED_OBJECTS = {0xe17e23c: photoSizeEmpty, 0x75c78e60: photoSize, 0x21e1ad6: photoCachedSize, 0xe0b0bc2e: photoStrippedSize, 0xfa3efb95: photoSizeProgressive, 0xd8214d41: photoPathSize}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class geoPointEmpty(TLObject):
    ID = 0x1117dd5f
    def __init__(self):
        pass
    def __str__(self):
        return 'geoPointEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class geoPoint(TLObject):
    ID = 0xb2a2f663
    def __init__(self, flags = None, long = None, lat = None, access_hash = None, accuracy_radius = None):
        self.flags = flags
        self.long = long
        self.lat = lat
        self.access_hash = access_hash
        self.accuracy_radius = accuracy_radius
    def __str__(self):
        return 'geoPoint'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_double(self.long)
        stream.pack_double(self.lat)
        stream.pack_int64(self.access_hash)
        flags = 0x0
        if self.accuracy_radius:
            flags |= (1 << 0)
            stream.pack_int32(self.accuracy_radius)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.long = data.unpack_double()
        self.lat = data.unpack_double()
        self.access_hash = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.accuracy_radius = data.unpack_int32()
        return self

class GeoPoint(TLObject):
    DERIVED_OBJECTS = {0x1117dd5f: geoPointEmpty, 0xb2a2f663: geoPoint}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_sentCode(TLObject):
    ID = 0x5e002502
    def __init__(self, flags = None, type = None, phone_code_hash = None, next_type = None, timeout = None):
        self.flags = flags
        self.type = type
        self.phone_code_hash = phone_code_hash
        self.next_type = next_type
        self.timeout = timeout
    def __str__(self):
        return 'auth_sentCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.phone_code_hash)
        flags = 0x0
        if self.next_type:
            flags |= (1 << 1)
            stream.pack_bytes(self.next_type.write())
        if self.timeout:
            flags |= (1 << 2)
            stream.pack_int32(self.timeout)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.type = auth_SentCodeType()
        self.type = self.type.read(data)
        self.phone_code_hash = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.next_type = auth_CodeType()
            self.next_type = self.next_type.read(data)
        if flags.check_bit(2):
            self.timeout = data.unpack_int32()
        return self

class auth_sendCode(TLObject):
    ID = 0xa677244f
    def __init__(self, phone_number = None, api_id = None, api_hash = None, settings = None):
        self.phone_number = phone_number
        self.api_id = api_id
        self.api_hash = api_hash
        self.settings = settings
    def __str__(self):
        return 'auth_sendCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_int32(self.api_id)
        stream.pack_string(self.api_hash)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.api_id = data.unpack_int32()
        self.api_hash = data.unpack_string()
        self.settings = CodeSettings()
        self.settings = self.settings.read(data)
        return self

class auth_resendCode(TLObject):
    ID = 0x3ef1a9bf
    def __init__(self, phone_number = None, phone_code_hash = None):
        self.phone_number = phone_number
        self.phone_code_hash = phone_code_hash
    def __str__(self):
        return 'auth_resendCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.phone_code_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.phone_code_hash = data.unpack_string()
        return self

class account_sendChangePhoneCode(TLObject):
    ID = 0x82574ae5
    def __init__(self, phone_number = None, settings = None):
        self.phone_number = phone_number
        self.settings = settings
    def __str__(self):
        return 'account_sendChangePhoneCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.settings = CodeSettings()
        self.settings = self.settings.read(data)
        return self

class account_sendConfirmPhoneCode(TLObject):
    ID = 0x1b3faa88
    def __init__(self, hash = None, settings = None):
        self.hash = hash
        self.settings = settings
    def __str__(self):
        return 'account_sendConfirmPhoneCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.hash)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_string()
        self.settings = CodeSettings()
        self.settings = self.settings.read(data)
        return self

class account_sendVerifyPhoneCode(TLObject):
    ID = 0xa5a356f9
    def __init__(self, phone_number = None, settings = None):
        self.phone_number = phone_number
        self.settings = settings
    def __str__(self):
        return 'account_sendVerifyPhoneCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.settings = CodeSettings()
        self.settings = self.settings.read(data)
        return self

class auth_SentCode(TLObject):
    DERIVED_OBJECTS = {0x5e002502: auth_sentCode, 0xa677244f: auth_sendCode, 0x3ef1a9bf: auth_resendCode, 0x82574ae5: account_sendChangePhoneCode, 0x1b3faa88: account_sendConfirmPhoneCode, 0xa5a356f9: account_sendVerifyPhoneCode}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_authorization(TLObject):
    ID = 0xcd050916
    def __init__(self, flags = None, tmp_sessions = None, user = None):
        self.flags = flags
        self.tmp_sessions = tmp_sessions
        self.user = user
    def __str__(self):
        return 'auth_authorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.tmp_sessions:
            flags |= (1 << 0)
            stream.pack_int32(self.tmp_sessions)
        stream.pack_bytes(self.user.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.tmp_sessions = data.unpack_int32()
        self.user = User()
        self.user = self.user.read(data)
        return self

class auth_authorizationSignUpRequired(TLObject):
    ID = 0x44747e9a
    def __init__(self, flags = None, terms_of_service = None):
        self.flags = flags
        self.terms_of_service = terms_of_service
    def __str__(self):
        return 'auth_authorizationSignUpRequired'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.terms_of_service:
            flags |= (1 << 0)
            stream.pack_bytes(self.terms_of_service.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.terms_of_service = help_TermsOfService()
            self.terms_of_service = self.terms_of_service.read(data)
        return self

class auth_signUp(TLObject):
    ID = 0x80eee427
    def __init__(self, phone_number = None, phone_code_hash = None, first_name = None, last_name = None):
        self.phone_number = phone_number
        self.phone_code_hash = phone_code_hash
        self.first_name = first_name
        self.last_name = last_name
    def __str__(self):
        return 'auth_signUp'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.phone_code_hash)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.phone_code_hash = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        return self

class auth_signIn(TLObject):
    ID = 0xbcd51581
    def __init__(self, phone_number = None, phone_code_hash = None, phone_code = None):
        self.phone_number = phone_number
        self.phone_code_hash = phone_code_hash
        self.phone_code = phone_code
    def __str__(self):
        return 'auth_signIn'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.phone_code_hash)
        stream.pack_string(self.phone_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.phone_code_hash = data.unpack_string()
        self.phone_code = data.unpack_string()
        return self

class auth_importAuthorization(TLObject):
    ID = 0xa57a7dad
    def __init__(self, id = None, bytes = None):
        self.id = id
        self.bytes = bytes
    def __str__(self):
        return 'auth_importAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.bytes = data.unpack_string()
        return self

class auth_importBotAuthorization(TLObject):
    ID = 0x67a3ff2c
    def __init__(self, flags = None, api_id = None, api_hash = None, bot_auth_token = None):
        self.flags = flags
        self.api_id = api_id
        self.api_hash = api_hash
        self.bot_auth_token = bot_auth_token
    def __str__(self):
        return 'auth_importBotAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.api_id)
        stream.pack_string(self.api_hash)
        stream.pack_string(self.bot_auth_token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.api_id = data.unpack_int32()
        self.api_hash = data.unpack_string()
        self.bot_auth_token = data.unpack_string()
        return self

class auth_checkPassword(TLObject):
    ID = 0xd18b4d16
    def __init__(self, password = None):
        self.password = password
    def __str__(self):
        return 'auth_checkPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.password.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.password = InputCheckPasswordSRP()
        self.password = self.password.read(data)
        return self

class auth_recoverPassword(TLObject):
    ID = 0x37096c70
    def __init__(self, flags = None, code = None, new_settings = None):
        self.flags = flags
        self.code = code
        self.new_settings = new_settings
    def __str__(self):
        return 'auth_recoverPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.code)
        flags = 0x0
        if self.new_settings:
            flags |= (1 << 0)
            stream.pack_bytes(self.new_settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.code = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.new_settings = account_PasswordInputSettings()
            self.new_settings = self.new_settings.read(data)
        return self

class auth_Authorization(TLObject):
    DERIVED_OBJECTS = {0xcd050916: auth_authorization, 0x44747e9a: auth_authorizationSignUpRequired, 0x80eee427: auth_signUp, 0xbcd51581: auth_signIn, 0xa57a7dad: auth_importAuthorization, 0x67a3ff2c: auth_importBotAuthorization, 0xd18b4d16: auth_checkPassword, 0x37096c70: auth_recoverPassword}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_exportedAuthorization(TLObject):
    ID = 0xb434e2b8
    def __init__(self, id = None, bytes = None):
        self.id = id
        self.bytes = bytes
    def __str__(self):
        return 'auth_exportedAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.bytes = data.unpack_string()
        return self

class auth_exportAuthorization(TLObject):
    ID = 0xe5bfffcd
    def __init__(self, dc_id = None):
        self.dc_id = dc_id
    def __str__(self):
        return 'auth_exportAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.dc_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_id = data.unpack_int32()
        return self

class auth_ExportedAuthorization(TLObject):
    DERIVED_OBJECTS = {0xb434e2b8: auth_exportedAuthorization, 0xe5bfffcd: auth_exportAuthorization}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputNotifyPeer(TLObject):
    ID = 0xb8bc5b0c
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'inputNotifyPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class inputNotifyUsers(TLObject):
    ID = 0x193b4417
    def __init__(self):
        pass
    def __str__(self):
        return 'inputNotifyUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputNotifyChats(TLObject):
    ID = 0x4a95e84e
    def __init__(self):
        pass
    def __str__(self):
        return 'inputNotifyChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputNotifyBroadcasts(TLObject):
    ID = 0xb1db7c7e
    def __init__(self):
        pass
    def __str__(self):
        return 'inputNotifyBroadcasts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class InputNotifyPeer(TLObject):
    DERIVED_OBJECTS = {0xb8bc5b0c: inputNotifyPeer, 0x193b4417: inputNotifyUsers, 0x4a95e84e: inputNotifyChats, 0xb1db7c7e: inputNotifyBroadcasts}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPeerNotifySettings(TLObject):
    ID = 0x9c3d198e
    def __init__(self, flags = None, show_previews = None, silent = None, mute_until = None, sound = None):
        self.flags = flags
        self.show_previews = show_previews
        self.silent = silent
        self.mute_until = mute_until
        self.sound = sound
    def __str__(self):
        return 'inputPeerNotifySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.show_previews:
            flags |= (1 << 0)
            stream.pack_bytes(self.show_previews.write())
        if self.silent:
            flags |= (1 << 1)
            stream.pack_bytes(self.silent.write())
        if self.mute_until:
            flags |= (1 << 2)
            stream.pack_int32(self.mute_until)
        if self.sound:
            flags |= (1 << 3)
            stream.pack_string(self.sound)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.show_previews = Bool()
            self.show_previews = self.show_previews.read(data)
        if flags.check_bit(1):
            self.silent = Bool()
            self.silent = self.silent.read(data)
        if flags.check_bit(2):
            self.mute_until = data.unpack_int32()
        if flags.check_bit(3):
            self.sound = data.unpack_string()
        return self

class InputPeerNotifySettings(TLObject):
    DERIVED_OBJECTS = {0x9c3d198e: inputPeerNotifySettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class peerNotifySettings(TLObject):
    ID = 0xaf509d20
    def __init__(self, flags = None, show_previews = None, silent = None, mute_until = None, sound = None):
        self.flags = flags
        self.show_previews = show_previews
        self.silent = silent
        self.mute_until = mute_until
        self.sound = sound
    def __str__(self):
        return 'peerNotifySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.show_previews:
            flags |= (1 << 0)
            stream.pack_bytes(self.show_previews.write())
        if self.silent:
            flags |= (1 << 1)
            stream.pack_bytes(self.silent.write())
        if self.mute_until:
            flags |= (1 << 2)
            stream.pack_int32(self.mute_until)
        if self.sound:
            flags |= (1 << 3)
            stream.pack_string(self.sound)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.show_previews = Bool()
            self.show_previews = self.show_previews.read(data)
        if flags.check_bit(1):
            self.silent = Bool()
            self.silent = self.silent.read(data)
        if flags.check_bit(2):
            self.mute_until = data.unpack_int32()
        if flags.check_bit(3):
            self.sound = data.unpack_string()
        return self

class account_getNotifySettings(TLObject):
    ID = 0x12b3ad31
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'account_getNotifySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputNotifyPeer()
        self.peer = self.peer.read(data)
        return self

class PeerNotifySettings(TLObject):
    DERIVED_OBJECTS = {0xaf509d20: peerNotifySettings, 0x12b3ad31: account_getNotifySettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class peerSettings(TLObject):
    ID = 0x733f2961
    def __init__(self, flags = None, report_spam = None, add_contact = None, block_contact = None, share_contact = None, need_contacts_exception = None, report_geo = None, autoarchived = None, invite_members = None, geo_distance = None):
        self.flags = flags
        self.report_spam = report_spam
        self.add_contact = add_contact
        self.block_contact = block_contact
        self.share_contact = share_contact
        self.need_contacts_exception = need_contacts_exception
        self.report_geo = report_geo
        self.autoarchived = autoarchived
        self.invite_members = invite_members
        self.geo_distance = geo_distance
    def __str__(self):
        return 'peerSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.report_spam:
            flags |= (1 << 0)
        if self.add_contact:
            flags |= (1 << 1)
        if self.block_contact:
            flags |= (1 << 2)
        if self.share_contact:
            flags |= (1 << 3)
        if self.need_contacts_exception:
            flags |= (1 << 4)
        if self.report_geo:
            flags |= (1 << 5)
        if self.autoarchived:
            flags |= (1 << 7)
        if self.invite_members:
            flags |= (1 << 8)
        if self.geo_distance:
            flags |= (1 << 6)
            stream.pack_int32(self.geo_distance)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.report_spam = True
        if flags.check_bit(1):
            self.add_contact = True
        if flags.check_bit(2):
            self.block_contact = True
        if flags.check_bit(3):
            self.share_contact = True
        if flags.check_bit(4):
            self.need_contacts_exception = True
        if flags.check_bit(5):
            self.report_geo = True
        if flags.check_bit(7):
            self.autoarchived = True
        if flags.check_bit(8):
            self.invite_members = True
        if flags.check_bit(6):
            self.geo_distance = data.unpack_int32()
        return self

class messages_getPeerSettings(TLObject):
    ID = 0x3672e09c
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_getPeerSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class PeerSettings(TLObject):
    DERIVED_OBJECTS = {0x733f2961: peerSettings, 0x3672e09c: messages_getPeerSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class wallPaper(TLObject):
    ID = 0xa437c3ed
    def __init__(self, id = None, flags = None, creator = None, default = None, pattern = None, dark = None, access_hash = None, slug = None, document = None, settings = None):
        self.id = id
        self.flags = flags
        self.creator = creator
        self.default = default
        self.pattern = pattern
        self.dark = dark
        self.access_hash = access_hash
        self.slug = slug
        self.document = document
        self.settings = settings
    def __str__(self):
        return 'wallPaper'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        flags = 0x0
        if self.creator:
            flags |= (1 << 0)
        if self.default:
            flags |= (1 << 1)
        if self.pattern:
            flags |= (1 << 3)
        if self.dark:
            flags |= (1 << 4)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.slug)
        stream.pack_bytes(self.document.write())
        if self.settings:
            flags |= (1 << 2)
            stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.creator = True
        if flags.check_bit(1):
            self.default = True
        if flags.check_bit(3):
            self.pattern = True
        if flags.check_bit(4):
            self.dark = True
        self.access_hash = data.unpack_int64()
        self.slug = data.unpack_string()
        self.document = Document()
        self.document = self.document.read(data)
        if flags.check_bit(2):
            self.settings = WallPaperSettings()
            self.settings = self.settings.read(data)
        return self

class wallPaperNoFile(TLObject):
    ID = 0xe0804116
    def __init__(self, id = None, flags = None, default = None, dark = None, settings = None):
        self.id = id
        self.flags = flags
        self.default = default
        self.dark = dark
        self.settings = settings
    def __str__(self):
        return 'wallPaperNoFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        flags = 0x0
        if self.default:
            flags |= (1 << 1)
        if self.dark:
            flags |= (1 << 4)
        if self.settings:
            flags |= (1 << 2)
            stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.default = True
        if flags.check_bit(4):
            self.dark = True
        if flags.check_bit(2):
            self.settings = WallPaperSettings()
            self.settings = self.settings.read(data)
        return self

class account_getWallPaper(TLObject):
    ID = 0xfc8ddbea
    def __init__(self, wallpaper = None):
        self.wallpaper = wallpaper
    def __str__(self):
        return 'account_getWallPaper'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.wallpaper.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.wallpaper = InputWallPaper()
        self.wallpaper = self.wallpaper.read(data)
        return self

class account_uploadWallPaper(TLObject):
    ID = 0xdd853661
    def __init__(self, file = None, mime_type = None, settings = None):
        self.file = file
        self.mime_type = mime_type
        self.settings = settings
    def __str__(self):
        return 'account_uploadWallPaper'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.file.write())
        stream.pack_string(self.mime_type)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file = InputFile()
        self.file = self.file.read(data)
        self.mime_type = data.unpack_string()
        self.settings = WallPaperSettings()
        self.settings = self.settings.read(data)
        return self

class WallPaper(TLObject):
    DERIVED_OBJECTS = {0xa437c3ed: wallPaper, 0xe0804116: wallPaperNoFile, 0xfc8ddbea: account_getWallPaper, 0xdd853661: account_uploadWallPaper}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputReportReasonSpam(TLObject):
    ID = 0x58dbcab8
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonSpam'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonViolence(TLObject):
    ID = 0x1e22c78d
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonViolence'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonPornography(TLObject):
    ID = 0x2e59d922
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonPornography'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonChildAbuse(TLObject):
    ID = 0xadf44ee3
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonChildAbuse'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonOther(TLObject):
    ID = 0xc1e4a2b1
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonOther'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonCopyright(TLObject):
    ID = 0x9b89f93a
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonCopyright'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonGeoIrrelevant(TLObject):
    ID = 0xdbd4feed
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonGeoIrrelevant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputReportReasonFake(TLObject):
    ID = 0xf5ddd6e7
    def __init__(self):
        pass
    def __str__(self):
        return 'inputReportReasonFake'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class ReportReason(TLObject):
    DERIVED_OBJECTS = {0x58dbcab8: inputReportReasonSpam, 0x1e22c78d: inputReportReasonViolence, 0x2e59d922: inputReportReasonPornography, 0xadf44ee3: inputReportReasonChildAbuse, 0xc1e4a2b1: inputReportReasonOther, 0x9b89f93a: inputReportReasonCopyright, 0xdbd4feed: inputReportReasonGeoIrrelevant, 0xf5ddd6e7: inputReportReasonFake}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class userFull(TLObject):
    ID = 0xd697ff05
    def __init__(self, flags = None, blocked = None, phone_calls_available = None, phone_calls_private = None, can_pin_message = None, has_scheduled = None, video_calls_available = None, user = None, about = None, settings = None, profile_photo = None, notify_settings = None, bot_info = None, pinned_msg_id = None, common_chats_count = None, folder_id = None, ttl_period = None, theme_emoticon = None):
        self.flags = flags
        self.blocked = blocked
        self.phone_calls_available = phone_calls_available
        self.phone_calls_private = phone_calls_private
        self.can_pin_message = can_pin_message
        self.has_scheduled = has_scheduled
        self.video_calls_available = video_calls_available
        self.user = user
        self.about = about
        self.settings = settings
        self.profile_photo = profile_photo
        self.notify_settings = notify_settings
        self.bot_info = bot_info
        self.pinned_msg_id = pinned_msg_id
        self.common_chats_count = common_chats_count
        self.folder_id = folder_id
        self.ttl_period = ttl_period
        self.theme_emoticon = theme_emoticon
    def __str__(self):
        return 'userFull'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.blocked:
            flags |= (1 << 0)
        if self.phone_calls_available:
            flags |= (1 << 4)
        if self.phone_calls_private:
            flags |= (1 << 5)
        if self.can_pin_message:
            flags |= (1 << 7)
        if self.has_scheduled:
            flags |= (1 << 12)
        if self.video_calls_available:
            flags |= (1 << 13)
        stream.pack_bytes(self.user.write())
        if self.about:
            flags |= (1 << 1)
            stream.pack_string(self.about)
        stream.pack_bytes(self.settings.write())
        if self.profile_photo:
            flags |= (1 << 2)
            stream.pack_bytes(self.profile_photo.write())
        stream.pack_bytes(self.notify_settings.write())
        if self.bot_info:
            flags |= (1 << 3)
            stream.pack_bytes(self.bot_info.write())
        if self.pinned_msg_id:
            flags |= (1 << 6)
            stream.pack_int32(self.pinned_msg_id)
        stream.pack_int32(self.common_chats_count)
        if self.folder_id:
            flags |= (1 << 11)
            stream.pack_int32(self.folder_id)
        if self.ttl_period:
            flags |= (1 << 14)
            stream.pack_int32(self.ttl_period)
        if self.theme_emoticon:
            flags |= (1 << 15)
            stream.pack_string(self.theme_emoticon)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.blocked = True
        if flags.check_bit(4):
            self.phone_calls_available = True
        if flags.check_bit(5):
            self.phone_calls_private = True
        if flags.check_bit(7):
            self.can_pin_message = True
        if flags.check_bit(12):
            self.has_scheduled = True
        if flags.check_bit(13):
            self.video_calls_available = True
        self.user = User()
        self.user = self.user.read(data)
        if flags.check_bit(1):
            self.about = data.unpack_string()
        self.settings = PeerSettings()
        self.settings = self.settings.read(data)
        if flags.check_bit(2):
            self.profile_photo = Photo()
            self.profile_photo = self.profile_photo.read(data)
        self.notify_settings = PeerNotifySettings()
        self.notify_settings = self.notify_settings.read(data)
        if flags.check_bit(3):
            self.bot_info = BotInfo()
            self.bot_info = self.bot_info.read(data)
        if flags.check_bit(6):
            self.pinned_msg_id = data.unpack_int32()
        self.common_chats_count = data.unpack_int32()
        if flags.check_bit(11):
            self.folder_id = data.unpack_int32()
        if flags.check_bit(14):
            self.ttl_period = data.unpack_int32()
        if flags.check_bit(15):
            self.theme_emoticon = data.unpack_string()
        return self

class users_getFullUser(TLObject):
    ID = 0xca30a5b1
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'users_getFullUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputUser()
        self.id = self.id.read(data)
        return self

class UserFull(TLObject):
    DERIVED_OBJECTS = {0xd697ff05: userFull, 0xca30a5b1: users_getFullUser}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contact(TLObject):
    ID = 0x145ade0b
    def __init__(self, user_id = None, mutual = None):
        self.user_id = user_id
        self.mutual = mutual
    def __str__(self):
        return 'contact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.mutual.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.mutual = Bool()
        self.mutual = self.mutual.read(data)
        return self

class Contact(TLObject):
    DERIVED_OBJECTS = {0x145ade0b: contact}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class importedContact(TLObject):
    ID = 0xc13e3c50
    def __init__(self, user_id = None, client_id = None):
        self.user_id = user_id
        self.client_id = client_id
    def __str__(self):
        return 'importedContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.client_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.client_id = data.unpack_int64()
        return self

class ImportedContact(TLObject):
    DERIVED_OBJECTS = {0xc13e3c50: importedContact}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contactStatus(TLObject):
    ID = 0x16d9703b
    def __init__(self, user_id = None, status = None):
        self.user_id = user_id
        self.status = status
    def __str__(self):
        return 'contactStatus'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.status.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.status = UserStatus()
        self.status = self.status.read(data)
        return self

class ContactStatus(TLObject):
    DERIVED_OBJECTS = {0x16d9703b: contactStatus}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contacts_contactsNotModified(TLObject):
    ID = 0xb74ba9d2
    def __init__(self):
        pass
    def __str__(self):
        return 'contacts_contactsNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class contacts_contacts(TLObject):
    ID = 0xeae87e42
    def __init__(self, contacts = None, saved_count = None, users = None):
        self.contacts = contacts
        self.saved_count = saved_count
        self.users = users
    def __str__(self):
        return 'contacts_contacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.contacts))
        for vec_k_2 in self.contacts:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.saved_count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.contacts = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Contact()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.contacts.append(elem_of_1_vec)
        self.saved_count = data.unpack_int32()
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class contacts_getContacts(TLObject):
    ID = 0x5dd69e12
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'contacts_getContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class contacts_Contacts(TLObject):
    DERIVED_OBJECTS = {0xb74ba9d2: contacts_contactsNotModified, 0xeae87e42: contacts_contacts, 0x5dd69e12: contacts_getContacts}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contacts_importedContacts(TLObject):
    ID = 0x77d01c3b
    def __init__(self, imported = None, popular_invites = None, retry_contacts = None, users = None):
        self.imported = imported
        self.popular_invites = popular_invites
        self.retry_contacts = retry_contacts
        self.users = users
    def __str__(self):
        return 'contacts_importedContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.imported))
        for vec_k_2 in self.imported:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.popular_invites))
        for vec_k_3 in self.popular_invites:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.retry_contacts))
        for vec_k_4 in self.retry_contacts:
            stream.pack_int64(vec_k_4)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.imported = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ImportedContact()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.imported.append(elem_of_1_vec)
        self.popular_invites = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = PopularContact()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.popular_invites.append(elem_of_2_vec)
        self.retry_contacts = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            self.retry_contacts.append(data.unpack_int64())
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        return self

class contacts_importContacts(TLObject):
    ID = 0x2c800be5
    def __init__(self, contacts = None):
        self.contacts = contacts
    def __str__(self):
        return 'contacts_importContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.contacts))
        for vec_k_2 in self.contacts:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.contacts = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputContact()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.contacts.append(elem_of_1_vec)
        return self

class contacts_ImportedContacts(TLObject):
    DERIVED_OBJECTS = {0x77d01c3b: contacts_importedContacts, 0x2c800be5: contacts_importContacts}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contacts_blocked(TLObject):
    ID = 0xade1591
    def __init__(self, blocked = None, chats = None, users = None):
        self.blocked = blocked
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'contacts_blocked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocked))
        for vec_k_2 in self.blocked:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.blocked = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PeerBlocked()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocked.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class contacts_blockedSlice(TLObject):
    ID = 0xe1664194
    def __init__(self, count = None, blocked = None, chats = None, users = None):
        self.count = count
        self.blocked = blocked
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'contacts_blockedSlice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocked))
        for vec_k_2 in self.blocked:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.blocked = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PeerBlocked()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocked.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class contacts_getBlocked(TLObject):
    ID = 0xf57c350f
    def __init__(self, offset = None, limit = None):
        self.offset = offset
        self.limit = limit
    def __str__(self):
        return 'contacts_getBlocked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class contacts_Blocked(TLObject):
    DERIVED_OBJECTS = {0xade1591: contacts_blocked, 0xe1664194: contacts_blockedSlice, 0xf57c350f: contacts_getBlocked}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_dialogs(TLObject):
    ID = 0x15ba6c40
    def __init__(self, dialogs = None, messages = None, chats = None, users = None):
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_dialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dialogs))
        for vec_k_2 in self.dialogs:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_3 in self.messages:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dialogs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Dialog()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.dialogs.append(elem_of_1_vec)
        self.messages = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Message()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.messages.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        return self

class messages_dialogsSlice(TLObject):
    ID = 0x71e094f3
    def __init__(self, count = None, dialogs = None, messages = None, chats = None, users = None):
        self.count = count
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_dialogsSlice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dialogs))
        for vec_k_2 in self.dialogs:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_3 in self.messages:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.dialogs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Dialog()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.dialogs.append(elem_of_1_vec)
        self.messages = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Message()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.messages.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        return self

class messages_dialogsNotModified(TLObject):
    ID = 0xf0e3e596
    def __init__(self, count = None):
        self.count = count
    def __str__(self):
        return 'messages_dialogsNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        return self

class messages_getDialogs(TLObject):
    ID = 0xa0f4cb4f
    def __init__(self, flags = None, exclude_pinned = None, folder_id = None, offset_date = None, offset_id = None, offset_peer = None, limit = None, hash = None):
        self.flags = flags
        self.exclude_pinned = exclude_pinned
        self.folder_id = folder_id
        self.offset_date = offset_date
        self.offset_id = offset_id
        self.offset_peer = offset_peer
        self.limit = limit
        self.hash = hash
    def __str__(self):
        return 'messages_getDialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.exclude_pinned:
            flags |= (1 << 0)
        if self.folder_id:
            flags |= (1 << 1)
            stream.pack_int32(self.folder_id)
        stream.pack_int32(self.offset_date)
        stream.pack_int32(self.offset_id)
        stream.pack_bytes(self.offset_peer.write())
        stream.pack_int32(self.limit)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.exclude_pinned = True
        if flags.check_bit(1):
            self.folder_id = data.unpack_int32()
        self.offset_date = data.unpack_int32()
        self.offset_id = data.unpack_int32()
        self.offset_peer = InputPeer()
        self.offset_peer = self.offset_peer.read(data)
        self.limit = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class messages_Dialogs(TLObject):
    DERIVED_OBJECTS = {0x15ba6c40: messages_dialogs, 0x71e094f3: messages_dialogsSlice, 0xf0e3e596: messages_dialogsNotModified, 0xa0f4cb4f: messages_getDialogs}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_messages(TLObject):
    ID = 0x8c718e87
    def __init__(self, messages = None, chats = None, users = None):
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_messages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.messages.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class messages_messagesSlice(TLObject):
    ID = 0x3a54685e
    def __init__(self, flags = None, inexact = None, count = None, next_rate = None, offset_id_offset = None, messages = None, chats = None, users = None):
        self.flags = flags
        self.inexact = inexact
        self.count = count
        self.next_rate = next_rate
        self.offset_id_offset = offset_id_offset
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_messagesSlice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.inexact:
            flags |= (1 << 1)
        stream.pack_int32(self.count)
        if self.next_rate:
            flags |= (1 << 0)
            stream.pack_int32(self.next_rate)
        if self.offset_id_offset:
            flags |= (1 << 2)
            stream.pack_int32(self.offset_id_offset)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.inexact = True
        self.count = data.unpack_int32()
        if flags.check_bit(0):
            self.next_rate = data.unpack_int32()
        if flags.check_bit(2):
            self.offset_id_offset = data.unpack_int32()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.messages.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class messages_channelMessages(TLObject):
    ID = 0x64479808
    def __init__(self, flags = None, inexact = None, pts = None, count = None, offset_id_offset = None, messages = None, chats = None, users = None):
        self.flags = flags
        self.inexact = inexact
        self.pts = pts
        self.count = count
        self.offset_id_offset = offset_id_offset
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_channelMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.inexact:
            flags |= (1 << 1)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.count)
        if self.offset_id_offset:
            flags |= (1 << 2)
            stream.pack_int32(self.offset_id_offset)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.inexact = True
        self.pts = data.unpack_int32()
        self.count = data.unpack_int32()
        if flags.check_bit(2):
            self.offset_id_offset = data.unpack_int32()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.messages.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class messages_messagesNotModified(TLObject):
    ID = 0x74535f21
    def __init__(self, count = None):
        self.count = count
    def __str__(self):
        return 'messages_messagesNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        return self

class messages_getMessages(TLObject):
    ID = 0x63c66506
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'messages_getMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputMessage()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.id.append(elem_of_1_vec)
        return self

class messages_getHistory(TLObject):
    ID = 0x4423e6c5
    def __init__(self, peer = None, offset_id = None, offset_date = None, add_offset = None, limit = None, max_id = None, min_id = None, hash = None):
        self.peer = peer
        self.offset_id = offset_id
        self.offset_date = offset_date
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id
        self.hash = hash
    def __str__(self):
        return 'messages_getHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.offset_id)
        stream.pack_int32(self.offset_date)
        stream.pack_int32(self.add_offset)
        stream.pack_int32(self.limit)
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.min_id)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.offset_id = data.unpack_int32()
        self.offset_date = data.unpack_int32()
        self.add_offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.max_id = data.unpack_int32()
        self.min_id = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class messages_search(TLObject):
    ID = 0xa0fda762
    def __init__(self, flags = None, peer = None, q = None, from_id = None, top_msg_id = None, filter = None, min_date = None, max_date = None, offset_id = None, add_offset = None, limit = None, max_id = None, min_id = None, hash = None):
        self.flags = flags
        self.peer = peer
        self.q = q
        self.from_id = from_id
        self.top_msg_id = top_msg_id
        self.filter = filter
        self.min_date = min_date
        self.max_date = max_date
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id
        self.hash = hash
    def __str__(self):
        return 'messages_search'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.q)
        flags = 0x0
        if self.from_id:
            flags |= (1 << 0)
            stream.pack_bytes(self.from_id.write())
        if self.top_msg_id:
            flags |= (1 << 1)
            stream.pack_int32(self.top_msg_id)
        stream.pack_bytes(self.filter.write())
        stream.pack_int32(self.min_date)
        stream.pack_int32(self.max_date)
        stream.pack_int32(self.offset_id)
        stream.pack_int32(self.add_offset)
        stream.pack_int32(self.limit)
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.min_id)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.q = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.from_id = InputPeer()
            self.from_id = self.from_id.read(data)
        if flags.check_bit(1):
            self.top_msg_id = data.unpack_int32()
        self.filter = MessagesFilter()
        self.filter = self.filter.read(data)
        self.min_date = data.unpack_int32()
        self.max_date = data.unpack_int32()
        self.offset_id = data.unpack_int32()
        self.add_offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.max_id = data.unpack_int32()
        self.min_id = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class messages_searchGlobal(TLObject):
    ID = 0x4bc6589a
    def __init__(self, flags = None, folder_id = None, q = None, filter = None, min_date = None, max_date = None, offset_rate = None, offset_peer = None, offset_id = None, limit = None):
        self.flags = flags
        self.folder_id = folder_id
        self.q = q
        self.filter = filter
        self.min_date = min_date
        self.max_date = max_date
        self.offset_rate = offset_rate
        self.offset_peer = offset_peer
        self.offset_id = offset_id
        self.limit = limit
    def __str__(self):
        return 'messages_searchGlobal'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.folder_id:
            flags |= (1 << 0)
            stream.pack_int32(self.folder_id)
        stream.pack_string(self.q)
        stream.pack_bytes(self.filter.write())
        stream.pack_int32(self.min_date)
        stream.pack_int32(self.max_date)
        stream.pack_int32(self.offset_rate)
        stream.pack_bytes(self.offset_peer.write())
        stream.pack_int32(self.offset_id)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.folder_id = data.unpack_int32()
        self.q = data.unpack_string()
        self.filter = MessagesFilter()
        self.filter = self.filter.read(data)
        self.min_date = data.unpack_int32()
        self.max_date = data.unpack_int32()
        self.offset_rate = data.unpack_int32()
        self.offset_peer = InputPeer()
        self.offset_peer = self.offset_peer.read(data)
        self.offset_id = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class messages_getUnreadMentions(TLObject):
    ID = 0x46578472
    def __init__(self, peer = None, offset_id = None, add_offset = None, limit = None, max_id = None, min_id = None):
        self.peer = peer
        self.offset_id = offset_id
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id
    def __str__(self):
        return 'messages_getUnreadMentions'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.offset_id)
        stream.pack_int32(self.add_offset)
        stream.pack_int32(self.limit)
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.min_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.offset_id = data.unpack_int32()
        self.add_offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.max_id = data.unpack_int32()
        self.min_id = data.unpack_int32()
        return self

class messages_getRecentLocations(TLObject):
    ID = 0x702a40e0
    def __init__(self, peer = None, limit = None, hash = None):
        self.peer = peer
        self.limit = limit
        self.hash = hash
    def __str__(self):
        return 'messages_getRecentLocations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.limit)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.limit = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class messages_getScheduledHistory(TLObject):
    ID = 0xf516760b
    def __init__(self, peer = None, hash = None):
        self.peer = peer
        self.hash = hash
    def __str__(self):
        return 'messages_getScheduledHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.hash = data.unpack_int64()
        return self

class messages_getScheduledMessages(TLObject):
    ID = 0xbdbb0464
    def __init__(self, peer = None, id = None):
        self.peer = peer
        self.id = id
    def __str__(self):
        return 'messages_getScheduledMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class messages_getReplies(TLObject):
    ID = 0x22ddd30c
    def __init__(self, peer = None, msg_id = None, offset_id = None, offset_date = None, add_offset = None, limit = None, max_id = None, min_id = None, hash = None):
        self.peer = peer
        self.msg_id = msg_id
        self.offset_id = offset_id
        self.offset_date = offset_date
        self.add_offset = add_offset
        self.limit = limit
        self.max_id = max_id
        self.min_id = min_id
        self.hash = hash
    def __str__(self):
        return 'messages_getReplies'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int32(self.offset_id)
        stream.pack_int32(self.offset_date)
        stream.pack_int32(self.add_offset)
        stream.pack_int32(self.limit)
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.min_id)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.offset_id = data.unpack_int32()
        self.offset_date = data.unpack_int32()
        self.add_offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.max_id = data.unpack_int32()
        self.min_id = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class channels_getMessages(TLObject):
    ID = 0xad8c9a23
    def __init__(self, channel = None, id = None):
        self.channel = channel
        self.id = id
    def __str__(self):
        return 'channels_getMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputMessage()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.id.append(elem_of_1_vec)
        return self

class stats_getMessagePublicForwards(TLObject):
    ID = 0x5630281b
    def __init__(self, channel = None, msg_id = None, offset_rate = None, offset_peer = None, offset_id = None, limit = None):
        self.channel = channel
        self.msg_id = msg_id
        self.offset_rate = offset_rate
        self.offset_peer = offset_peer
        self.offset_id = offset_id
        self.limit = limit
    def __str__(self):
        return 'stats_getMessagePublicForwards'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int32(self.offset_rate)
        stream.pack_bytes(self.offset_peer.write())
        stream.pack_int32(self.offset_id)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.msg_id = data.unpack_int32()
        self.offset_rate = data.unpack_int32()
        self.offset_peer = InputPeer()
        self.offset_peer = self.offset_peer.read(data)
        self.offset_id = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class messages_Messages(TLObject):
    DERIVED_OBJECTS = {0x8c718e87: messages_messages, 0x3a54685e: messages_messagesSlice, 0x64479808: messages_channelMessages, 0x74535f21: messages_messagesNotModified, 0x63c66506: messages_getMessages, 0x4423e6c5: messages_getHistory, 0xa0fda762: messages_search, 0x4bc6589a: messages_searchGlobal, 0x46578472: messages_getUnreadMentions, 0x702a40e0: messages_getRecentLocations, 0xf516760b: messages_getScheduledHistory, 0xbdbb0464: messages_getScheduledMessages, 0x22ddd30c: messages_getReplies, 0xad8c9a23: channels_getMessages, 0x5630281b: stats_getMessagePublicForwards}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_chats(TLObject):
    ID = 0x64ff9fd5
    def __init__(self, chats = None):
        self.chats = chats
    def __str__(self):
        return 'messages_chats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Chat()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.chats.append(elem_of_1_vec)
        return self

class messages_chatsSlice(TLObject):
    ID = 0x9cd81144
    def __init__(self, count = None, chats = None):
        self.count = count
        self.chats = chats
    def __str__(self):
        return 'messages_chatsSlice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Chat()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.chats.append(elem_of_1_vec)
        return self

class messages_getChats(TLObject):
    ID = 0x49e9528f
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'messages_getChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int64())
        return self

class messages_getCommonChats(TLObject):
    ID = 0xe40ca104
    def __init__(self, user_id = None, max_id = None, limit = None):
        self.user_id = user_id
        self.max_id = max_id
        self.limit = limit
    def __str__(self):
        return 'messages_getCommonChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.user_id.write())
        stream.pack_int64(self.max_id)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.max_id = data.unpack_int64()
        self.limit = data.unpack_int32()
        return self

class messages_getAllChats(TLObject):
    ID = 0x875f74be
    def __init__(self, except_ids = None):
        self.except_ids = except_ids
    def __str__(self):
        return 'messages_getAllChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.except_ids))
        for vec_k_2 in self.except_ids:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.except_ids = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.except_ids.append(data.unpack_int64())
        return self

class channels_getChannels(TLObject):
    ID = 0xa7f6bbb
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'channels_getChannels'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputChannel()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.id.append(elem_of_1_vec)
        return self

class channels_getAdminedPublicChannels(TLObject):
    ID = 0xf8b036af
    def __init__(self, flags = None, by_location = None, check_limit = None):
        self.flags = flags
        self.by_location = by_location
        self.check_limit = check_limit
    def __str__(self):
        return 'channels_getAdminedPublicChannels'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.by_location:
            flags |= (1 << 0)
        if self.check_limit:
            flags |= (1 << 1)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.by_location = True
        if flags.check_bit(1):
            self.check_limit = True
        return self

class channels_getLeftChannels(TLObject):
    ID = 0x8341ecc0
    def __init__(self, offset = None):
        self.offset = offset
    def __str__(self):
        return 'channels_getLeftChannels'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        return self

class channels_getGroupsForDiscussion(TLObject):
    ID = 0xf5dad378
    def __init__(self):
        pass
    def __str__(self):
        return 'channels_getGroupsForDiscussion'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_Chats(TLObject):
    DERIVED_OBJECTS = {0x64ff9fd5: messages_chats, 0x9cd81144: messages_chatsSlice, 0x49e9528f: messages_getChats, 0xe40ca104: messages_getCommonChats, 0x875f74be: messages_getAllChats, 0xa7f6bbb: channels_getChannels, 0xf8b036af: channels_getAdminedPublicChannels, 0x8341ecc0: channels_getLeftChannels, 0xf5dad378: channels_getGroupsForDiscussion}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_chatFull(TLObject):
    ID = 0xe5d7d19c
    def __init__(self, full_chat = None, chats = None, users = None):
        self.full_chat = full_chat
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_chatFull'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.full_chat.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.full_chat = ChatFull()
        self.full_chat = self.full_chat.read(data)
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Chat()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.chats.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class messages_getFullChat(TLObject):
    ID = 0xaeb00b34
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'messages_getFullChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        return self

class channels_getFullChannel(TLObject):
    ID = 0x8736a09
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'channels_getFullChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class messages_ChatFull(TLObject):
    DERIVED_OBJECTS = {0xe5d7d19c: messages_chatFull, 0xaeb00b34: messages_getFullChat, 0x8736a09: channels_getFullChannel}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_affectedHistory(TLObject):
    ID = 0xb45c69d1
    def __init__(self, pts = None, pts_count = None, offset = None):
        self.pts = pts
        self.pts_count = pts_count
        self.offset = offset
    def __str__(self):
        return 'messages_affectedHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        stream.pack_int32(self.offset)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        self.offset = data.unpack_int32()
        return self

class messages_deleteHistory(TLObject):
    ID = 0x1c015b09
    def __init__(self, flags = None, just_clear = None, revoke = None, peer = None, max_id = None):
        self.flags = flags
        self.just_clear = just_clear
        self.revoke = revoke
        self.peer = peer
        self.max_id = max_id
    def __str__(self):
        return 'messages_deleteHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.just_clear:
            flags |= (1 << 0)
        if self.revoke:
            flags |= (1 << 1)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.just_clear = True
        if flags.check_bit(1):
            self.revoke = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.max_id = data.unpack_int32()
        return self

class messages_readMentions(TLObject):
    ID = 0xf0189d3
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_readMentions'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class messages_unpinAllMessages(TLObject):
    ID = 0xf025bc8b
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_unpinAllMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class channels_deleteUserHistory(TLObject):
    ID = 0xd10dd71b
    def __init__(self, channel = None, user_id = None):
        self.channel = channel
        self.user_id = user_id
    def __str__(self):
        return 'channels_deleteUserHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class messages_AffectedHistory(TLObject):
    DERIVED_OBJECTS = {0xb45c69d1: messages_affectedHistory, 0x1c015b09: messages_deleteHistory, 0xf0189d3: messages_readMentions, 0xf025bc8b: messages_unpinAllMessages, 0xd10dd71b: channels_deleteUserHistory}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputMessagesFilterEmpty(TLObject):
    ID = 0x57e2f66c
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterPhotos(TLObject):
    ID = 0x9609a51c
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterPhotos'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterVideo(TLObject):
    ID = 0x9fc00e65
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterVideo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterPhotoVideo(TLObject):
    ID = 0x56e9f0e4
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterPhotoVideo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterDocument(TLObject):
    ID = 0x9eddf188
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterUrl(TLObject):
    ID = 0x7ef0dd87
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterUrl'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterGif(TLObject):
    ID = 0xffc86587
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterGif'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterVoice(TLObject):
    ID = 0x50f5c392
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterVoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterMusic(TLObject):
    ID = 0x3751b49e
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterMusic'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterChatPhotos(TLObject):
    ID = 0x3a20ecb8
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterChatPhotos'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterPhoneCalls(TLObject):
    ID = 0x80c99768
    def __init__(self, flags = None, missed = None):
        self.flags = flags
        self.missed = missed
    def __str__(self):
        return 'inputMessagesFilterPhoneCalls'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.missed:
            flags |= (1 << 0)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.missed = True
        return self

class inputMessagesFilterRoundVoice(TLObject):
    ID = 0x7a7c17a4
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterRoundVoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterRoundVideo(TLObject):
    ID = 0xb549da53
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterRoundVideo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterMyMentions(TLObject):
    ID = 0xc1f8e69a
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterMyMentions'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterGeo(TLObject):
    ID = 0xe7026d0d
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterGeo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterContacts(TLObject):
    ID = 0xe062db83
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessagesFilterPinned(TLObject):
    ID = 0x1bb00451
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagesFilterPinned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class MessagesFilter(TLObject):
    DERIVED_OBJECTS = {0x57e2f66c: inputMessagesFilterEmpty, 0x9609a51c: inputMessagesFilterPhotos, 0x9fc00e65: inputMessagesFilterVideo, 0x56e9f0e4: inputMessagesFilterPhotoVideo, 0x9eddf188: inputMessagesFilterDocument, 0x7ef0dd87: inputMessagesFilterUrl, 0xffc86587: inputMessagesFilterGif, 0x50f5c392: inputMessagesFilterVoice, 0x3751b49e: inputMessagesFilterMusic, 0x3a20ecb8: inputMessagesFilterChatPhotos, 0x80c99768: inputMessagesFilterPhoneCalls, 0x7a7c17a4: inputMessagesFilterRoundVoice, 0xb549da53: inputMessagesFilterRoundVideo, 0xc1f8e69a: inputMessagesFilterMyMentions, 0xe7026d0d: inputMessagesFilterGeo, 0xe062db83: inputMessagesFilterContacts, 0x1bb00451: inputMessagesFilterPinned}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class updateNewMessage(TLObject):
    ID = 0x1f2b0afd
    def __init__(self, message = None, pts = None, pts_count = None):
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateNewMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateMessageID(TLObject):
    ID = 0x4e90bfd6
    def __init__(self, id = None, random_id = None):
        self.id = id
        self.random_id = random_id
    def __str__(self):
        return 'updateMessageID'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        stream.pack_int64(self.random_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        self.random_id = data.unpack_int64()
        return self

class updateDeleteMessages(TLObject):
    ID = 0xa20db0e5
    def __init__(self, messages = None, pts = None, pts_count = None):
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateDeleteMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateUserTyping(TLObject):
    ID = 0xc01e857f
    def __init__(self, user_id = None, action = None):
        self.user_id = user_id
        self.action = action
    def __str__(self):
        return 'updateUserTyping'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.action.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.action = SendMessageAction()
        self.action = self.action.read(data)
        return self

class updateChatUserTyping(TLObject):
    ID = 0x83487af0
    def __init__(self, chat_id = None, from_id = None, action = None):
        self.chat_id = chat_id
        self.from_id = from_id
        self.action = action
    def __str__(self):
        return 'updateChatUserTyping'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_bytes(self.from_id.write())
        stream.pack_bytes(self.action.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.from_id = Peer()
        self.from_id = self.from_id.read(data)
        self.action = SendMessageAction()
        self.action = self.action.read(data)
        return self

class updateChatParticipants(TLObject):
    ID = 0x7761198
    def __init__(self, participants = None):
        self.participants = participants
    def __str__(self):
        return 'updateChatParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.participants.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.participants = ChatParticipants()
        self.participants = self.participants.read(data)
        return self

class updateUserStatus(TLObject):
    ID = 0xe5bdf8de
    def __init__(self, user_id = None, status = None):
        self.user_id = user_id
        self.status = status
    def __str__(self):
        return 'updateUserStatus'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.status.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.status = UserStatus()
        self.status = self.status.read(data)
        return self

class updateUserName(TLObject):
    ID = 0xc3f202e0
    def __init__(self, user_id = None, first_name = None, last_name = None, username = None):
        self.user_id = user_id
        self.first_name = first_name
        self.last_name = last_name
        self.username = username
    def __str__(self):
        return 'updateUserName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_string(self.username)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.username = data.unpack_string()
        return self

class updateUserPhoto(TLObject):
    ID = 0xf227868c
    def __init__(self, user_id = None, date = None, photo = None, previous = None):
        self.user_id = user_id
        self.date = date
        self.photo = photo
        self.previous = previous
    def __str__(self):
        return 'updateUserPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.date)
        stream.pack_bytes(self.photo.write())
        stream.pack_bytes(self.previous.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.date = data.unpack_int32()
        self.photo = UserProfilePhoto()
        self.photo = self.photo.read(data)
        self.previous = Bool()
        self.previous = self.previous.read(data)
        return self

class updateNewEncryptedMessage(TLObject):
    ID = 0x12bcbd9a
    def __init__(self, message = None, qts = None):
        self.message = message
        self.qts = qts
    def __str__(self):
        return 'updateNewEncryptedMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        stream.pack_int32(self.qts)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = EncryptedMessage()
        self.message = self.message.read(data)
        self.qts = data.unpack_int32()
        return self

class updateEncryptedChatTyping(TLObject):
    ID = 0x1710f156
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'updateEncryptedChatTyping'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int32()
        return self

class updateEncryption(TLObject):
    ID = 0xb4a2e88d
    def __init__(self, chat = None, date = None):
        self.chat = chat
        self.date = date
    def __str__(self):
        return 'updateEncryption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.chat.write())
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat = EncryptedChat()
        self.chat = self.chat.read(data)
        self.date = data.unpack_int32()
        return self

class updateEncryptedMessagesRead(TLObject):
    ID = 0x38fe25b7
    def __init__(self, chat_id = None, max_date = None, date = None):
        self.chat_id = chat_id
        self.max_date = max_date
        self.date = date
    def __str__(self):
        return 'updateEncryptedMessagesRead'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.chat_id)
        stream.pack_int32(self.max_date)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int32()
        self.max_date = data.unpack_int32()
        self.date = data.unpack_int32()
        return self

class updateChatParticipantAdd(TLObject):
    ID = 0x3dda5451
    def __init__(self, chat_id = None, user_id = None, inviter_id = None, date = None, version = None):
        self.chat_id = chat_id
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date
        self.version = version
    def __str__(self):
        return 'updateChatParticipantAdd'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.inviter_id)
        stream.pack_int32(self.date)
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.inviter_id = data.unpack_int64()
        self.date = data.unpack_int32()
        self.version = data.unpack_int32()
        return self

class updateChatParticipantDelete(TLObject):
    ID = 0xe32f3d77
    def __init__(self, chat_id = None, user_id = None, version = None):
        self.chat_id = chat_id
        self.user_id = user_id
        self.version = version
    def __str__(self):
        return 'updateChatParticipantDelete'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.version = data.unpack_int32()
        return self

class updateDcOptions(TLObject):
    ID = 0x8e5e9873
    def __init__(self, dc_options = None):
        self.dc_options = dc_options
    def __str__(self):
        return 'updateDcOptions'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dc_options))
        for vec_k_2 in self.dc_options:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_options = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = DcOption()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.dc_options.append(elem_of_1_vec)
        return self

class updateNotifySettings(TLObject):
    ID = 0xbec268ef
    def __init__(self, peer = None, notify_settings = None):
        self.peer = peer
        self.notify_settings = notify_settings
    def __str__(self):
        return 'updateNotifySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.notify_settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = NotifyPeer()
        self.peer = self.peer.read(data)
        self.notify_settings = PeerNotifySettings()
        self.notify_settings = self.notify_settings.read(data)
        return self

class updateServiceNotification(TLObject):
    ID = 0xebe46819
    def __init__(self, flags = None, popup = None, inbox_date = None, type = None, message = None, media = None, entities = None):
        self.flags = flags
        self.popup = popup
        self.inbox_date = inbox_date
        self.type = type
        self.message = message
        self.media = media
        self.entities = entities
    def __str__(self):
        return 'updateServiceNotification'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.popup:
            flags |= (1 << 0)
        if self.inbox_date:
            flags |= (1 << 1)
            stream.pack_int32(self.inbox_date)
        stream.pack_string(self.type)
        stream.pack_string(self.message)
        stream.pack_bytes(self.media.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.entities))
        for vec_k_2 in self.entities:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.popup = True
        if flags.check_bit(1):
            self.inbox_date = data.unpack_int32()
        self.type = data.unpack_string()
        self.message = data.unpack_string()
        self.media = MessageMedia()
        self.media = self.media.read(data)
        self.entities = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageEntity()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.entities.append(elem_of_1_vec)
        return self

class updatePrivacy(TLObject):
    ID = 0xee3b272a
    def __init__(self, key = None, rules = None):
        self.key = key
        self.rules = rules
    def __str__(self):
        return 'updatePrivacy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.key.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.rules))
        for vec_k_2 in self.rules:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.key = PrivacyKey()
        self.key = self.key.read(data)
        self.rules = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PrivacyRule()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.rules.append(elem_of_1_vec)
        return self

class updateUserPhone(TLObject):
    ID = 0x5492a13
    def __init__(self, user_id = None, phone = None):
        self.user_id = user_id
        self.phone = phone
    def __str__(self):
        return 'updateUserPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.phone)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.phone = data.unpack_string()
        return self

class updateReadHistoryInbox(TLObject):
    ID = 0x9c974fdf
    def __init__(self, flags = None, folder_id = None, peer = None, max_id = None, still_unread_count = None, pts = None, pts_count = None):
        self.flags = flags
        self.folder_id = folder_id
        self.peer = peer
        self.max_id = max_id
        self.still_unread_count = still_unread_count
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateReadHistoryInbox'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.folder_id:
            flags |= (1 << 0)
            stream.pack_int32(self.folder_id)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.still_unread_count)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.folder_id = data.unpack_int32()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.max_id = data.unpack_int32()
        self.still_unread_count = data.unpack_int32()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateReadHistoryOutbox(TLObject):
    ID = 0x2f2f21bf
    def __init__(self, peer = None, max_id = None, pts = None, pts_count = None):
        self.peer = peer
        self.max_id = max_id
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateReadHistoryOutbox'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.max_id = data.unpack_int32()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateWebPage(TLObject):
    ID = 0x7f891213
    def __init__(self, webpage = None, pts = None, pts_count = None):
        self.webpage = webpage
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateWebPage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.webpage.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.webpage = WebPage()
        self.webpage = self.webpage.read(data)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateReadMessagesContents(TLObject):
    ID = 0x68c13933
    def __init__(self, messages = None, pts = None, pts_count = None):
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateReadMessagesContents'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateChannelTooLong(TLObject):
    ID = 0x108d941f
    def __init__(self, flags = None, channel_id = None, pts = None):
        self.flags = flags
        self.channel_id = channel_id
        self.pts = pts
    def __str__(self):
        return 'updateChannelTooLong'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        flags = 0x0
        if self.pts:
            flags |= (1 << 0)
            stream.pack_int32(self.pts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pts = data.unpack_int32()
        return self

class updateChannel(TLObject):
    ID = 0x635b4c09
    def __init__(self, channel_id = None):
        self.channel_id = channel_id
    def __str__(self):
        return 'updateChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        return self

class updateNewChannelMessage(TLObject):
    ID = 0x62ba04d9
    def __init__(self, message = None, pts = None, pts_count = None):
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateNewChannelMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateReadChannelInbox(TLObject):
    ID = 0x922e6e10
    def __init__(self, flags = None, folder_id = None, channel_id = None, max_id = None, still_unread_count = None, pts = None):
        self.flags = flags
        self.folder_id = folder_id
        self.channel_id = channel_id
        self.max_id = max_id
        self.still_unread_count = still_unread_count
        self.pts = pts
    def __str__(self):
        return 'updateReadChannelInbox'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.folder_id:
            flags |= (1 << 0)
            stream.pack_int32(self.folder_id)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.max_id)
        stream.pack_int32(self.still_unread_count)
        stream.pack_int32(self.pts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.folder_id = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        self.max_id = data.unpack_int32()
        self.still_unread_count = data.unpack_int32()
        self.pts = data.unpack_int32()
        return self

class updateDeleteChannelMessages(TLObject):
    ID = 0xc32d5b12
    def __init__(self, channel_id = None, messages = None, pts = None, pts_count = None):
        self.channel_id = channel_id
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateDeleteChannelMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateChannelMessageViews(TLObject):
    ID = 0xf226ac08
    def __init__(self, channel_id = None, id = None, views = None):
        self.channel_id = channel_id
        self.id = id
        self.views = views
    def __str__(self):
        return 'updateChannelMessageViews'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.id)
        stream.pack_int32(self.views)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.id = data.unpack_int32()
        self.views = data.unpack_int32()
        return self

class updateChatParticipantAdmin(TLObject):
    ID = 0xd7ca61a2
    def __init__(self, chat_id = None, user_id = None, is_admin = None, version = None):
        self.chat_id = chat_id
        self.user_id = user_id
        self.is_admin = is_admin
        self.version = version
    def __str__(self):
        return 'updateChatParticipantAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.is_admin.write())
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.is_admin = Bool()
        self.is_admin = self.is_admin.read(data)
        self.version = data.unpack_int32()
        return self

class updateNewStickerSet(TLObject):
    ID = 0x688a30aa
    def __init__(self, stickerset = None):
        self.stickerset = stickerset
    def __str__(self):
        return 'updateNewStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = messages_StickerSet()
        self.stickerset = self.stickerset.read(data)
        return self

class updateStickerSetsOrder(TLObject):
    ID = 0xbb2d201
    def __init__(self, flags = None, masks = None, order = None):
        self.flags = flags
        self.masks = masks
        self.order = order
    def __str__(self):
        return 'updateStickerSetsOrder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.masks:
            flags |= (1 << 0)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.order))
        for vec_k_2 in self.order:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.masks = True
        self.order = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.order.append(data.unpack_int64())
        return self

class updateStickerSets(TLObject):
    ID = 0x43ae3dec
    def __init__(self):
        pass
    def __str__(self):
        return 'updateStickerSets'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateSavedGifs(TLObject):
    ID = 0x9375341e
    def __init__(self):
        pass
    def __str__(self):
        return 'updateSavedGifs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateBotInlineQuery(TLObject):
    ID = 0x496f379c
    def __init__(self, flags = None, query_id = None, user_id = None, query = None, geo = None, peer_type = None, offset = None):
        self.flags = flags
        self.query_id = query_id
        self.user_id = user_id
        self.query = query
        self.geo = geo
        self.peer_type = peer_type
        self.offset = offset
    def __str__(self):
        return 'updateBotInlineQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.query)
        flags = 0x0
        if self.geo:
            flags |= (1 << 0)
            stream.pack_bytes(self.geo.write())
        if self.peer_type:
            flags |= (1 << 1)
            stream.pack_bytes(self.peer_type.write())
        stream.pack_string(self.offset)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.query_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.query = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.geo = GeoPoint()
            self.geo = self.geo.read(data)
        if flags.check_bit(1):
            self.peer_type = InlineQueryPeerType()
            self.peer_type = self.peer_type.read(data)
        self.offset = data.unpack_string()
        return self

class updateBotInlineSend(TLObject):
    ID = 0x12f12a07
    def __init__(self, flags = None, user_id = None, query = None, geo = None, id = None, msg_id = None):
        self.flags = flags
        self.user_id = user_id
        self.query = query
        self.geo = geo
        self.id = id
        self.msg_id = msg_id
    def __str__(self):
        return 'updateBotInlineSend'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.query)
        flags = 0x0
        if self.geo:
            flags |= (1 << 0)
            stream.pack_bytes(self.geo.write())
        stream.pack_string(self.id)
        if self.msg_id:
            flags |= (1 << 1)
            stream.pack_bytes(self.msg_id.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.user_id = data.unpack_int64()
        self.query = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.geo = GeoPoint()
            self.geo = self.geo.read(data)
        self.id = data.unpack_string()
        if flags.check_bit(1):
            self.msg_id = InputBotInlineMessageID()
            self.msg_id = self.msg_id.read(data)
        return self

class updateEditChannelMessage(TLObject):
    ID = 0x1b3f4df7
    def __init__(self, message = None, pts = None, pts_count = None):
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateEditChannelMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateBotCallbackQuery(TLObject):
    ID = 0xb9cfc48d
    def __init__(self, flags = None, query_id = None, user_id = None, peer = None, msg_id = None, chat_instance = None, data = None, game_short_name = None):
        self.flags = flags
        self.query_id = query_id
        self.user_id = user_id
        self.peer = peer
        self.msg_id = msg_id
        self.chat_instance = chat_instance
        self.data = data
        self.game_short_name = game_short_name
    def __str__(self):
        return 'updateBotCallbackQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int64(self.chat_instance)
        flags = 0x0
        if self.data:
            flags |= (1 << 0)
            stream.pack_string(self.data)
        if self.game_short_name:
            flags |= (1 << 1)
            stream.pack_string(self.game_short_name)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.query_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.chat_instance = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.data = data.unpack_string()
        if flags.check_bit(1):
            self.game_short_name = data.unpack_string()
        return self

class updateEditMessage(TLObject):
    ID = 0xe40370a3
    def __init__(self, message = None, pts = None, pts_count = None):
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateEditMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateInlineBotCallbackQuery(TLObject):
    ID = 0x691e9052
    def __init__(self, flags = None, query_id = None, user_id = None, msg_id = None, chat_instance = None, data = None, game_short_name = None):
        self.flags = flags
        self.query_id = query_id
        self.user_id = user_id
        self.msg_id = msg_id
        self.chat_instance = chat_instance
        self.data = data
        self.game_short_name = game_short_name
    def __str__(self):
        return 'updateInlineBotCallbackQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.msg_id.write())
        stream.pack_int64(self.chat_instance)
        flags = 0x0
        if self.data:
            flags |= (1 << 0)
            stream.pack_string(self.data)
        if self.game_short_name:
            flags |= (1 << 1)
            stream.pack_string(self.game_short_name)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.query_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.msg_id = InputBotInlineMessageID()
        self.msg_id = self.msg_id.read(data)
        self.chat_instance = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.data = data.unpack_string()
        if flags.check_bit(1):
            self.game_short_name = data.unpack_string()
        return self

class updateReadChannelOutbox(TLObject):
    ID = 0xb75f99a9
    def __init__(self, channel_id = None, max_id = None):
        self.channel_id = channel_id
        self.max_id = max_id
    def __str__(self):
        return 'updateReadChannelOutbox'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.max_id = data.unpack_int32()
        return self

class updateDraftMessage(TLObject):
    ID = 0xee2bb969
    def __init__(self, peer = None, draft = None):
        self.peer = peer
        self.draft = draft
    def __str__(self):
        return 'updateDraftMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.draft.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.draft = DraftMessage()
        self.draft = self.draft.read(data)
        return self

class updateReadFeaturedStickers(TLObject):
    ID = 0x571d2742
    def __init__(self):
        pass
    def __str__(self):
        return 'updateReadFeaturedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateRecentStickers(TLObject):
    ID = 0x9a422c20
    def __init__(self):
        pass
    def __str__(self):
        return 'updateRecentStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateConfig(TLObject):
    ID = 0xa229dd06
    def __init__(self):
        pass
    def __str__(self):
        return 'updateConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updatePtsChanged(TLObject):
    ID = 0x3354678f
    def __init__(self):
        pass
    def __str__(self):
        return 'updatePtsChanged'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateChannelWebPage(TLObject):
    ID = 0x2f2ba99f
    def __init__(self, channel_id = None, webpage = None, pts = None, pts_count = None):
        self.channel_id = channel_id
        self.webpage = webpage
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateChannelWebPage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_bytes(self.webpage.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.webpage = WebPage()
        self.webpage = self.webpage.read(data)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateDialogPinned(TLObject):
    ID = 0x6e6fe51c
    def __init__(self, flags = None, pinned = None, folder_id = None, peer = None):
        self.flags = flags
        self.pinned = pinned
        self.folder_id = folder_id
        self.peer = peer
    def __str__(self):
        return 'updateDialogPinned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pinned:
            flags |= (1 << 0)
        if self.folder_id:
            flags |= (1 << 1)
            stream.pack_int32(self.folder_id)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pinned = True
        if flags.check_bit(1):
            self.folder_id = data.unpack_int32()
        self.peer = DialogPeer()
        self.peer = self.peer.read(data)
        return self

class updatePinnedDialogs(TLObject):
    ID = 0xfa0f3ca2
    def __init__(self, flags = None, folder_id = None, order = None):
        self.flags = flags
        self.folder_id = folder_id
        self.order = order
    def __str__(self):
        return 'updatePinnedDialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.folder_id:
            flags |= (1 << 1)
            stream.pack_int32(self.folder_id)
        if self.order:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.order))
            for vec_k_2 in self.order:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.folder_id = data.unpack_int32()
        if flags.check_bit(0):
            self.order = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = DialogPeer()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.order.append(elem_of_1_vec)
        return self

class updateBotWebhookJSON(TLObject):
    ID = 0x8317c0c3
    def __init__(self, data = None):
        self.data = data
    def __str__(self):
        return 'updateBotWebhookJSON'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.data.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.data = DataJSON()
        self.data = self.data.read(data)
        return self

class updateBotWebhookJSONQuery(TLObject):
    ID = 0x9b9240a6
    def __init__(self, query_id = None, data = None, timeout = None):
        self.query_id = query_id
        self.data = data
        self.timeout = timeout
    def __str__(self):
        return 'updateBotWebhookJSONQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_bytes(self.data.write())
        stream.pack_int32(self.timeout)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.query_id = data.unpack_int64()
        self.data = DataJSON()
        self.data = self.data.read(data)
        self.timeout = data.unpack_int32()
        return self

class updateBotShippingQuery(TLObject):
    ID = 0xb5aefd7d
    def __init__(self, query_id = None, user_id = None, payload = None, shipping_address = None):
        self.query_id = query_id
        self.user_id = user_id
        self.payload = payload
        self.shipping_address = shipping_address
    def __str__(self):
        return 'updateBotShippingQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.payload)
        stream.pack_bytes(self.shipping_address.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.query_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.payload = data.unpack_string()
        self.shipping_address = PostAddress()
        self.shipping_address = self.shipping_address.read(data)
        return self

class updateBotPrecheckoutQuery(TLObject):
    ID = 0x8caa9a96
    def __init__(self, flags = None, query_id = None, user_id = None, payload = None, info = None, shipping_option_id = None, currency = None, total_amount = None):
        self.flags = flags
        self.query_id = query_id
        self.user_id = user_id
        self.payload = payload
        self.info = info
        self.shipping_option_id = shipping_option_id
        self.currency = currency
        self.total_amount = total_amount
    def __str__(self):
        return 'updateBotPrecheckoutQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.query_id)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.payload)
        flags = 0x0
        if self.info:
            flags |= (1 << 0)
            stream.pack_bytes(self.info.write())
        if self.shipping_option_id:
            flags |= (1 << 1)
            stream.pack_string(self.shipping_option_id)
        stream.pack_string(self.currency)
        stream.pack_int64(self.total_amount)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.query_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.payload = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.info = PaymentRequestedInfo()
            self.info = self.info.read(data)
        if flags.check_bit(1):
            self.shipping_option_id = data.unpack_string()
        self.currency = data.unpack_string()
        self.total_amount = data.unpack_int64()
        return self

class updatePhoneCall(TLObject):
    ID = 0xab0f6b1e
    def __init__(self, phone_call = None):
        self.phone_call = phone_call
    def __str__(self):
        return 'updatePhoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.phone_call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_call = PhoneCall()
        self.phone_call = self.phone_call.read(data)
        return self

class updateLangPackTooLong(TLObject):
    ID = 0x46560264
    def __init__(self, lang_code = None):
        self.lang_code = lang_code
    def __str__(self):
        return 'updateLangPackTooLong'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        return self

class updateLangPack(TLObject):
    ID = 0x56022f4d
    def __init__(self, difference = None):
        self.difference = difference
    def __str__(self):
        return 'updateLangPack'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.difference.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.difference = LangPackDifference()
        self.difference = self.difference.read(data)
        return self

class updateFavedStickers(TLObject):
    ID = 0xe511996d
    def __init__(self):
        pass
    def __str__(self):
        return 'updateFavedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateChannelReadMessagesContents(TLObject):
    ID = 0x44bdd535
    def __init__(self, channel_id = None, messages = None):
        self.channel_id = channel_id
        self.messages = messages
    def __str__(self):
        return 'updateChannelReadMessagesContents'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        return self

class updateContactsReset(TLObject):
    ID = 0x7084a7be
    def __init__(self):
        pass
    def __str__(self):
        return 'updateContactsReset'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateChannelAvailableMessages(TLObject):
    ID = 0xb23fc698
    def __init__(self, channel_id = None, available_min_id = None):
        self.channel_id = channel_id
        self.available_min_id = available_min_id
    def __str__(self):
        return 'updateChannelAvailableMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.available_min_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.available_min_id = data.unpack_int32()
        return self

class updateDialogUnreadMark(TLObject):
    ID = 0xe16459c3
    def __init__(self, flags = None, unread = None, peer = None):
        self.flags = flags
        self.unread = unread
        self.peer = peer
    def __str__(self):
        return 'updateDialogUnreadMark'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.unread:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.unread = True
        self.peer = DialogPeer()
        self.peer = self.peer.read(data)
        return self

class updateMessagePoll(TLObject):
    ID = 0xaca1657b
    def __init__(self, flags = None, poll_id = None, poll = None, results = None):
        self.flags = flags
        self.poll_id = poll_id
        self.poll = poll
        self.results = results
    def __str__(self):
        return 'updateMessagePoll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.poll_id)
        flags = 0x0
        if self.poll:
            flags |= (1 << 0)
            stream.pack_bytes(self.poll.write())
        stream.pack_bytes(self.results.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.poll_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.poll = Poll()
            self.poll = self.poll.read(data)
        self.results = PollResults()
        self.results = self.results.read(data)
        return self

class updateChatDefaultBannedRights(TLObject):
    ID = 0x54c01850
    def __init__(self, peer = None, default_banned_rights = None, version = None):
        self.peer = peer
        self.default_banned_rights = default_banned_rights
        self.version = version
    def __str__(self):
        return 'updateChatDefaultBannedRights'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.default_banned_rights.write())
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.default_banned_rights = ChatBannedRights()
        self.default_banned_rights = self.default_banned_rights.read(data)
        self.version = data.unpack_int32()
        return self

class updateFolderPeers(TLObject):
    ID = 0x19360dc0
    def __init__(self, folder_peers = None, pts = None, pts_count = None):
        self.folder_peers = folder_peers
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updateFolderPeers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.folder_peers))
        for vec_k_2 in self.folder_peers:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.folder_peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = FolderPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.folder_peers.append(elem_of_1_vec)
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updatePeerSettings(TLObject):
    ID = 0x6a7e7366
    def __init__(self, peer = None, settings = None):
        self.peer = peer
        self.settings = settings
    def __str__(self):
        return 'updatePeerSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.settings = PeerSettings()
        self.settings = self.settings.read(data)
        return self

class updatePeerLocated(TLObject):
    ID = 0xb4afcfb0
    def __init__(self, peers = None):
        self.peers = peers
    def __str__(self):
        return 'updatePeerLocated'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.peers))
        for vec_k_2 in self.peers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PeerLocated()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.peers.append(elem_of_1_vec)
        return self

class updateNewScheduledMessage(TLObject):
    ID = 0x39a51dfb
    def __init__(self, message = None):
        self.message = message
    def __str__(self):
        return 'updateNewScheduledMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        return self

class updateDeleteScheduledMessages(TLObject):
    ID = 0x90866cee
    def __init__(self, peer = None, messages = None):
        self.peer = peer
        self.messages = messages
    def __str__(self):
        return 'updateDeleteScheduledMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        return self

class updateTheme(TLObject):
    ID = 0x8216fba3
    def __init__(self, theme = None):
        self.theme = theme
    def __str__(self):
        return 'updateTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.theme.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.theme = Theme()
        self.theme = self.theme.read(data)
        return self

class updateGeoLiveViewed(TLObject):
    ID = 0x871fb939
    def __init__(self, peer = None, msg_id = None):
        self.peer = peer
        self.msg_id = msg_id
    def __str__(self):
        return 'updateGeoLiveViewed'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        return self

class updateLoginToken(TLObject):
    ID = 0x564fe691
    def __init__(self):
        pass
    def __str__(self):
        return 'updateLoginToken'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateMessagePollVote(TLObject):
    ID = 0x106395c9
    def __init__(self, poll_id = None, user_id = None, options = None, qts = None):
        self.poll_id = poll_id
        self.user_id = user_id
        self.options = options
        self.qts = qts
    def __str__(self):
        return 'updateMessagePollVote'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.poll_id)
        stream.pack_int64(self.user_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.options))
        for vec_k_2 in self.options:
            stream.pack_string(vec_k_2)
        stream.pack_int32(self.qts)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.poll_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        self.options = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.options.append(data.unpack_string())
        self.qts = data.unpack_int32()
        return self

class updateDialogFilter(TLObject):
    ID = 0x26ffde7d
    def __init__(self, flags = None, id = None, filter = None):
        self.flags = flags
        self.id = id
        self.filter = filter
    def __str__(self):
        return 'updateDialogFilter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        flags = 0x0
        if self.filter:
            flags |= (1 << 0)
            stream.pack_bytes(self.filter.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.filter = DialogFilter()
            self.filter = self.filter.read(data)
        return self

class updateDialogFilterOrder(TLObject):
    ID = 0xa5d72105
    def __init__(self, order = None):
        self.order = order
    def __str__(self):
        return 'updateDialogFilterOrder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.order))
        for vec_k_2 in self.order:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.order = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.order.append(data.unpack_int32())
        return self

class updateDialogFilters(TLObject):
    ID = 0x3504914f
    def __init__(self):
        pass
    def __str__(self):
        return 'updateDialogFilters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updatePhoneCallSignalingData(TLObject):
    ID = 0x2661bf09
    def __init__(self, phone_call_id = None, data = None):
        self.phone_call_id = phone_call_id
        self.data = data
    def __str__(self):
        return 'updatePhoneCallSignalingData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.phone_call_id)
        stream.pack_string(self.data)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_call_id = data.unpack_int64()
        self.data = data.unpack_string()
        return self

class updateChannelMessageForwards(TLObject):
    ID = 0xd29a27f4
    def __init__(self, channel_id = None, id = None, forwards = None):
        self.channel_id = channel_id
        self.id = id
        self.forwards = forwards
    def __str__(self):
        return 'updateChannelMessageForwards'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.id)
        stream.pack_int32(self.forwards)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.id = data.unpack_int32()
        self.forwards = data.unpack_int32()
        return self

class updateReadChannelDiscussionInbox(TLObject):
    ID = 0xd6b19546
    def __init__(self, flags = None, channel_id = None, top_msg_id = None, read_max_id = None, broadcast_id = None, broadcast_post = None):
        self.flags = flags
        self.channel_id = channel_id
        self.top_msg_id = top_msg_id
        self.read_max_id = read_max_id
        self.broadcast_id = broadcast_id
        self.broadcast_post = broadcast_post
    def __str__(self):
        return 'updateReadChannelDiscussionInbox'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.top_msg_id)
        stream.pack_int32(self.read_max_id)
        flags = 0x0
        if self.broadcast_id:
            flags |= (1 << 0)
            stream.pack_int64(self.broadcast_id)
        if self.broadcast_post:
            flags |= (1 << 0)
            stream.pack_int32(self.broadcast_post)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        self.top_msg_id = data.unpack_int32()
        self.read_max_id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.broadcast_id = data.unpack_int64()
        if flags.check_bit(0):
            self.broadcast_post = data.unpack_int32()
        return self

class updateReadChannelDiscussionOutbox(TLObject):
    ID = 0x695c9e7c
    def __init__(self, channel_id = None, top_msg_id = None, read_max_id = None):
        self.channel_id = channel_id
        self.top_msg_id = top_msg_id
        self.read_max_id = read_max_id
    def __str__(self):
        return 'updateReadChannelDiscussionOutbox'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.top_msg_id)
        stream.pack_int32(self.read_max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.top_msg_id = data.unpack_int32()
        self.read_max_id = data.unpack_int32()
        return self

class updatePeerBlocked(TLObject):
    ID = 0x246a4b22
    def __init__(self, peer_id = None, blocked = None):
        self.peer_id = peer_id
        self.blocked = blocked
    def __str__(self):
        return 'updatePeerBlocked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer_id.write())
        stream.pack_bytes(self.blocked.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer_id = Peer()
        self.peer_id = self.peer_id.read(data)
        self.blocked = Bool()
        self.blocked = self.blocked.read(data)
        return self

class updateChannelUserTyping(TLObject):
    ID = 0x8c88c923
    def __init__(self, flags = None, channel_id = None, top_msg_id = None, from_id = None, action = None):
        self.flags = flags
        self.channel_id = channel_id
        self.top_msg_id = top_msg_id
        self.from_id = from_id
        self.action = action
    def __str__(self):
        return 'updateChannelUserTyping'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        flags = 0x0
        if self.top_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.top_msg_id)
        stream.pack_bytes(self.from_id.write())
        stream.pack_bytes(self.action.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.top_msg_id = data.unpack_int32()
        self.from_id = Peer()
        self.from_id = self.from_id.read(data)
        self.action = SendMessageAction()
        self.action = self.action.read(data)
        return self

class updatePinnedMessages(TLObject):
    ID = 0xed85eab5
    def __init__(self, flags = None, pinned = None, peer = None, messages = None, pts = None, pts_count = None):
        self.flags = flags
        self.pinned = pinned
        self.peer = peer
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updatePinnedMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pinned:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pinned = True
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updatePinnedChannelMessages(TLObject):
    ID = 0x5bb98608
    def __init__(self, flags = None, pinned = None, channel_id = None, messages = None, pts = None, pts_count = None):
        self.flags = flags
        self.pinned = pinned
        self.channel_id = channel_id
        self.messages = messages
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'updatePinnedChannelMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pinned:
            flags |= (1 << 0)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pinned = True
        self.channel_id = data.unpack_int64()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class updateChat(TLObject):
    ID = 0xf89a6a4e
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'updateChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        return self

class updateGroupCallParticipants(TLObject):
    ID = 0xf2ebdb4e
    def __init__(self, call = None, participants = None, version = None):
        self.call = call
        self.participants = participants
        self.version = version
    def __str__(self):
        return 'updateGroupCallParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.participants))
        for vec_k_2 in self.participants:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.participants = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = GroupCallParticipant()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.participants.append(elem_of_1_vec)
        self.version = data.unpack_int32()
        return self

class updateGroupCall(TLObject):
    ID = 0x14b24500
    def __init__(self, chat_id = None, call = None):
        self.chat_id = chat_id
        self.call = call
    def __str__(self):
        return 'updateGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.call = GroupCall()
        self.call = self.call.read(data)
        return self

class updatePeerHistoryTTL(TLObject):
    ID = 0xbb9bb9a5
    def __init__(self, flags = None, peer = None, ttl_period = None):
        self.flags = flags
        self.peer = peer
        self.ttl_period = ttl_period
    def __str__(self):
        return 'updatePeerHistoryTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        flags = 0x0
        if self.ttl_period:
            flags |= (1 << 0)
            stream.pack_int32(self.ttl_period)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.ttl_period = data.unpack_int32()
        return self

class updateChatParticipant(TLObject):
    ID = 0xd087663a
    def __init__(self, flags = None, chat_id = None, date = None, actor_id = None, user_id = None, prev_participant = None, new_participant = None, invite = None, qts = None):
        self.flags = flags
        self.chat_id = chat_id
        self.date = date
        self.actor_id = actor_id
        self.user_id = user_id
        self.prev_participant = prev_participant
        self.new_participant = new_participant
        self.invite = invite
        self.qts = qts
    def __str__(self):
        return 'updateChatParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_int32(self.date)
        stream.pack_int64(self.actor_id)
        stream.pack_int64(self.user_id)
        flags = 0x0
        if self.prev_participant:
            flags |= (1 << 0)
            stream.pack_bytes(self.prev_participant.write())
        if self.new_participant:
            flags |= (1 << 1)
            stream.pack_bytes(self.new_participant.write())
        if self.invite:
            flags |= (1 << 2)
            stream.pack_bytes(self.invite.write())
        stream.pack_int32(self.qts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.chat_id = data.unpack_int64()
        self.date = data.unpack_int32()
        self.actor_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.prev_participant = ChatParticipant()
            self.prev_participant = self.prev_participant.read(data)
        if flags.check_bit(1):
            self.new_participant = ChatParticipant()
            self.new_participant = self.new_participant.read(data)
        if flags.check_bit(2):
            self.invite = ExportedChatInvite()
            self.invite = self.invite.read(data)
        self.qts = data.unpack_int32()
        return self

class updateChannelParticipant(TLObject):
    ID = 0x985d3abb
    def __init__(self, flags = None, channel_id = None, date = None, actor_id = None, user_id = None, prev_participant = None, new_participant = None, invite = None, qts = None):
        self.flags = flags
        self.channel_id = channel_id
        self.date = date
        self.actor_id = actor_id
        self.user_id = user_id
        self.prev_participant = prev_participant
        self.new_participant = new_participant
        self.invite = invite
        self.qts = qts
    def __str__(self):
        return 'updateChannelParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int32(self.date)
        stream.pack_int64(self.actor_id)
        stream.pack_int64(self.user_id)
        flags = 0x0
        if self.prev_participant:
            flags |= (1 << 0)
            stream.pack_bytes(self.prev_participant.write())
        if self.new_participant:
            flags |= (1 << 1)
            stream.pack_bytes(self.new_participant.write())
        if self.invite:
            flags |= (1 << 2)
            stream.pack_bytes(self.invite.write())
        stream.pack_int32(self.qts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        self.date = data.unpack_int32()
        self.actor_id = data.unpack_int64()
        self.user_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.prev_participant = ChannelParticipant()
            self.prev_participant = self.prev_participant.read(data)
        if flags.check_bit(1):
            self.new_participant = ChannelParticipant()
            self.new_participant = self.new_participant.read(data)
        if flags.check_bit(2):
            self.invite = ExportedChatInvite()
            self.invite = self.invite.read(data)
        self.qts = data.unpack_int32()
        return self

class updateBotStopped(TLObject):
    ID = 0xc4870a49
    def __init__(self, user_id = None, date = None, stopped = None, qts = None):
        self.user_id = user_id
        self.date = date
        self.stopped = stopped
        self.qts = qts
    def __str__(self):
        return 'updateBotStopped'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.date)
        stream.pack_bytes(self.stopped.write())
        stream.pack_int32(self.qts)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.date = data.unpack_int32()
        self.stopped = Bool()
        self.stopped = self.stopped.read(data)
        self.qts = data.unpack_int32()
        return self

class updateGroupCallConnection(TLObject):
    ID = 0xb783982
    def __init__(self, flags = None, presentation = None, params = None):
        self.flags = flags
        self.presentation = presentation
        self.params = params
    def __str__(self):
        return 'updateGroupCallConnection'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.presentation:
            flags |= (1 << 0)
        stream.pack_bytes(self.params.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.presentation = True
        self.params = DataJSON()
        self.params = self.params.read(data)
        return self

class updateBotCommands(TLObject):
    ID = 0x4d712f2e
    def __init__(self, peer = None, bot_id = None, commands = None):
        self.peer = peer
        self.bot_id = bot_id
        self.commands = commands
    def __str__(self):
        return 'updateBotCommands'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.bot_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.commands))
        for vec_k_2 in self.commands:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.bot_id = data.unpack_int64()
        self.commands = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = BotCommand()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.commands.append(elem_of_1_vec)
        return self

class Update(TLObject):
    DERIVED_OBJECTS = {0x1f2b0afd: updateNewMessage, 0x4e90bfd6: updateMessageID, 0xa20db0e5: updateDeleteMessages, 0xc01e857f: updateUserTyping, 0x83487af0: updateChatUserTyping, 0x7761198: updateChatParticipants, 0xe5bdf8de: updateUserStatus, 0xc3f202e0: updateUserName, 0xf227868c: updateUserPhoto, 0x12bcbd9a: updateNewEncryptedMessage, 0x1710f156: updateEncryptedChatTyping, 0xb4a2e88d: updateEncryption, 0x38fe25b7: updateEncryptedMessagesRead, 0x3dda5451: updateChatParticipantAdd, 0xe32f3d77: updateChatParticipantDelete, 0x8e5e9873: updateDcOptions, 0xbec268ef: updateNotifySettings, 0xebe46819: updateServiceNotification, 0xee3b272a: updatePrivacy, 0x5492a13: updateUserPhone, 0x9c974fdf: updateReadHistoryInbox, 0x2f2f21bf: updateReadHistoryOutbox, 0x7f891213: updateWebPage, 0x68c13933: updateReadMessagesContents, 0x108d941f: updateChannelTooLong, 0x635b4c09: updateChannel, 0x62ba04d9: updateNewChannelMessage, 0x922e6e10: updateReadChannelInbox, 0xc32d5b12: updateDeleteChannelMessages, 0xf226ac08: updateChannelMessageViews, 0xd7ca61a2: updateChatParticipantAdmin, 0x688a30aa: updateNewStickerSet, 0xbb2d201: updateStickerSetsOrder, 0x43ae3dec: updateStickerSets, 0x9375341e: updateSavedGifs, 0x496f379c: updateBotInlineQuery, 0x12f12a07: updateBotInlineSend, 0x1b3f4df7: updateEditChannelMessage, 0xb9cfc48d: updateBotCallbackQuery, 0xe40370a3: updateEditMessage, 0x691e9052: updateInlineBotCallbackQuery, 0xb75f99a9: updateReadChannelOutbox, 0xee2bb969: updateDraftMessage, 0x571d2742: updateReadFeaturedStickers, 0x9a422c20: updateRecentStickers, 0xa229dd06: updateConfig, 0x3354678f: updatePtsChanged, 0x2f2ba99f: updateChannelWebPage, 0x6e6fe51c: updateDialogPinned, 0xfa0f3ca2: updatePinnedDialogs, 0x8317c0c3: updateBotWebhookJSON, 0x9b9240a6: updateBotWebhookJSONQuery, 0xb5aefd7d: updateBotShippingQuery, 0x8caa9a96: updateBotPrecheckoutQuery, 0xab0f6b1e: updatePhoneCall, 0x46560264: updateLangPackTooLong, 0x56022f4d: updateLangPack, 0xe511996d: updateFavedStickers, 0x44bdd535: updateChannelReadMessagesContents, 0x7084a7be: updateContactsReset, 0xb23fc698: updateChannelAvailableMessages, 0xe16459c3: updateDialogUnreadMark, 0xaca1657b: updateMessagePoll, 0x54c01850: updateChatDefaultBannedRights, 0x19360dc0: updateFolderPeers, 0x6a7e7366: updatePeerSettings, 0xb4afcfb0: updatePeerLocated, 0x39a51dfb: updateNewScheduledMessage, 0x90866cee: updateDeleteScheduledMessages, 0x8216fba3: updateTheme, 0x871fb939: updateGeoLiveViewed, 0x564fe691: updateLoginToken, 0x106395c9: updateMessagePollVote, 0x26ffde7d: updateDialogFilter, 0xa5d72105: updateDialogFilterOrder, 0x3504914f: updateDialogFilters, 0x2661bf09: updatePhoneCallSignalingData, 0xd29a27f4: updateChannelMessageForwards, 0xd6b19546: updateReadChannelDiscussionInbox, 0x695c9e7c: updateReadChannelDiscussionOutbox, 0x246a4b22: updatePeerBlocked, 0x8c88c923: updateChannelUserTyping, 0xed85eab5: updatePinnedMessages, 0x5bb98608: updatePinnedChannelMessages, 0xf89a6a4e: updateChat, 0xf2ebdb4e: updateGroupCallParticipants, 0x14b24500: updateGroupCall, 0xbb9bb9a5: updatePeerHistoryTTL, 0xd087663a: updateChatParticipant, 0x985d3abb: updateChannelParticipant, 0xc4870a49: updateBotStopped, 0xb783982: updateGroupCallConnection, 0x4d712f2e: updateBotCommands}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class updates_state(TLObject):
    ID = 0xa56c2a3e
    def __init__(self, pts = None, qts = None, date = None, seq = None, unread_count = None):
        self.pts = pts
        self.qts = qts
        self.date = date
        self.seq = seq
        self.unread_count = unread_count
    def __str__(self):
        return 'updates_state'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.qts)
        stream.pack_int32(self.date)
        stream.pack_int32(self.seq)
        stream.pack_int32(self.unread_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pts = data.unpack_int32()
        self.qts = data.unpack_int32()
        self.date = data.unpack_int32()
        self.seq = data.unpack_int32()
        self.unread_count = data.unpack_int32()
        return self

class updates_getState(TLObject):
    ID = 0xedd4882a
    def __init__(self):
        pass
    def __str__(self):
        return 'updates_getState'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updates_State(TLObject):
    DERIVED_OBJECTS = {0xa56c2a3e: updates_state, 0xedd4882a: updates_getState}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class updates_differenceEmpty(TLObject):
    ID = 0x5d75a138
    def __init__(self, date = None, seq = None):
        self.date = date
        self.seq = seq
    def __str__(self):
        return 'updates_differenceEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.date)
        stream.pack_int32(self.seq)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.date = data.unpack_int32()
        self.seq = data.unpack_int32()
        return self

class updates_difference(TLObject):
    ID = 0xf49ca0
    def __init__(self, new_messages = None, new_encrypted_messages = None, other_updates = None, chats = None, users = None, state = None):
        self.new_messages = new_messages
        self.new_encrypted_messages = new_encrypted_messages
        self.other_updates = other_updates
        self.chats = chats
        self.users = users
        self.state = state
    def __str__(self):
        return 'updates_difference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.new_messages))
        for vec_k_2 in self.new_messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.new_encrypted_messages))
        for vec_k_3 in self.new_encrypted_messages:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.other_updates))
        for vec_k_4 in self.other_updates:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_5 in self.chats:
            stream.pack_bytes(vec_k_5.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_6 in self.users:
            stream.pack_bytes(vec_k_6.write())
        stream.pack_bytes(self.state.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.new_messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.new_messages.append(elem_of_1_vec)
        self.new_encrypted_messages = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = EncryptedMessage()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.new_encrypted_messages.append(elem_of_2_vec)
        self.other_updates = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Update()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.other_updates.append(elem_of_3_vec)
        self.chats = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = Chat()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.chats.append(elem_of_4_vec)
        self.users = list()
        data.unpack_int32()
        vector_5_size = data.unpack_int32()
        for vec_i_5 in range(vector_5_size):
            elem_of_5_vec = User()
            elem_of_5_vec = elem_of_5_vec.read(data)
            self.users.append(elem_of_5_vec)
        self.state = updates_State()
        self.state = self.state.read(data)
        return self

class updates_differenceSlice(TLObject):
    ID = 0xa8fb1981
    def __init__(self, new_messages = None, new_encrypted_messages = None, other_updates = None, chats = None, users = None, intermediate_state = None):
        self.new_messages = new_messages
        self.new_encrypted_messages = new_encrypted_messages
        self.other_updates = other_updates
        self.chats = chats
        self.users = users
        self.intermediate_state = intermediate_state
    def __str__(self):
        return 'updates_differenceSlice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.new_messages))
        for vec_k_2 in self.new_messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.new_encrypted_messages))
        for vec_k_3 in self.new_encrypted_messages:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.other_updates))
        for vec_k_4 in self.other_updates:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_5 in self.chats:
            stream.pack_bytes(vec_k_5.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_6 in self.users:
            stream.pack_bytes(vec_k_6.write())
        stream.pack_bytes(self.intermediate_state.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.new_messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.new_messages.append(elem_of_1_vec)
        self.new_encrypted_messages = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = EncryptedMessage()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.new_encrypted_messages.append(elem_of_2_vec)
        self.other_updates = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Update()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.other_updates.append(elem_of_3_vec)
        self.chats = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = Chat()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.chats.append(elem_of_4_vec)
        self.users = list()
        data.unpack_int32()
        vector_5_size = data.unpack_int32()
        for vec_i_5 in range(vector_5_size):
            elem_of_5_vec = User()
            elem_of_5_vec = elem_of_5_vec.read(data)
            self.users.append(elem_of_5_vec)
        self.intermediate_state = updates_State()
        self.intermediate_state = self.intermediate_state.read(data)
        return self

class updates_differenceTooLong(TLObject):
    ID = 0x4afe8f6d
    def __init__(self, pts = None):
        self.pts = pts
    def __str__(self):
        return 'updates_differenceTooLong'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pts)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pts = data.unpack_int32()
        return self

class updates_getDifference(TLObject):
    ID = 0x25939651
    def __init__(self, flags = None, pts = None, pts_total_limit = None, date = None, qts = None):
        self.flags = flags
        self.pts = pts
        self.pts_total_limit = pts_total_limit
        self.date = date
        self.qts = qts
    def __str__(self):
        return 'updates_getDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pts)
        flags = 0x0
        if self.pts_total_limit:
            flags |= (1 << 0)
            stream.pack_int32(self.pts_total_limit)
        stream.pack_int32(self.date)
        stream.pack_int32(self.qts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.pts = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pts_total_limit = data.unpack_int32()
        self.date = data.unpack_int32()
        self.qts = data.unpack_int32()
        return self

class updates_Difference(TLObject):
    DERIVED_OBJECTS = {0x5d75a138: updates_differenceEmpty, 0xf49ca0: updates_difference, 0xa8fb1981: updates_differenceSlice, 0x4afe8f6d: updates_differenceTooLong, 0x25939651: updates_getDifference}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            print(hex(packet_id))
            print(data)
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class updatesTooLong(TLObject):
    ID = 0xe317af7e
    def __init__(self):
        pass
    def __str__(self):
        return 'updatesTooLong'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class updateShortMessage(TLObject):
    ID = 0x313bc7f8
    def __init__(self, flags = None, out = None, mentioned = None, media_unread = None, silent = None, id = None, user_id = None, message = None, pts = None, pts_count = None, date = None, fwd_from = None, via_bot_id = None, reply_to = None, entities = None, ttl_period = None):
        self.flags = flags
        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.id = id
        self.user_id = user_id
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to = reply_to
        self.entities = entities
        self.ttl_period = ttl_period
    def __str__(self):
        return 'updateShortMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.out:
            flags |= (1 << 1)
        if self.mentioned:
            flags |= (1 << 4)
        if self.media_unread:
            flags |= (1 << 5)
        if self.silent:
            flags |= (1 << 13)
        stream.pack_int32(self.id)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.message)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        stream.pack_int32(self.date)
        if self.fwd_from:
            flags |= (1 << 2)
            stream.pack_bytes(self.fwd_from.write())
        if self.via_bot_id:
            flags |= (1 << 11)
            stream.pack_int64(self.via_bot_id)
        if self.reply_to:
            flags |= (1 << 3)
            stream.pack_bytes(self.reply_to.write())
        if self.entities:
            flags |= (1 << 7)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.ttl_period:
            flags |= (1 << 25)
            stream.pack_int32(self.ttl_period)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.out = True
        if flags.check_bit(4):
            self.mentioned = True
        if flags.check_bit(5):
            self.media_unread = True
        if flags.check_bit(13):
            self.silent = True
        self.id = data.unpack_int32()
        self.user_id = data.unpack_int64()
        self.message = data.unpack_string()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        self.date = data.unpack_int32()
        if flags.check_bit(2):
            self.fwd_from = MessageFwdHeader()
            self.fwd_from = self.fwd_from.read(data)
        if flags.check_bit(11):
            self.via_bot_id = data.unpack_int64()
        if flags.check_bit(3):
            self.reply_to = MessageReplyHeader()
            self.reply_to = self.reply_to.read(data)
        if flags.check_bit(7):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(25):
            self.ttl_period = data.unpack_int32()
        return self

class updateShortChatMessage(TLObject):
    ID = 0x4d6deea5
    def __init__(self, flags = None, out = None, mentioned = None, media_unread = None, silent = None, id = None, from_id = None, chat_id = None, message = None, pts = None, pts_count = None, date = None, fwd_from = None, via_bot_id = None, reply_to = None, entities = None, ttl_period = None):
        self.flags = flags
        self.out = out
        self.mentioned = mentioned
        self.media_unread = media_unread
        self.silent = silent
        self.id = id
        self.from_id = from_id
        self.chat_id = chat_id
        self.message = message
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.fwd_from = fwd_from
        self.via_bot_id = via_bot_id
        self.reply_to = reply_to
        self.entities = entities
        self.ttl_period = ttl_period
    def __str__(self):
        return 'updateShortChatMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.out:
            flags |= (1 << 1)
        if self.mentioned:
            flags |= (1 << 4)
        if self.media_unread:
            flags |= (1 << 5)
        if self.silent:
            flags |= (1 << 13)
        stream.pack_int32(self.id)
        stream.pack_int64(self.from_id)
        stream.pack_int64(self.chat_id)
        stream.pack_string(self.message)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        stream.pack_int32(self.date)
        if self.fwd_from:
            flags |= (1 << 2)
            stream.pack_bytes(self.fwd_from.write())
        if self.via_bot_id:
            flags |= (1 << 11)
            stream.pack_int64(self.via_bot_id)
        if self.reply_to:
            flags |= (1 << 3)
            stream.pack_bytes(self.reply_to.write())
        if self.entities:
            flags |= (1 << 7)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.ttl_period:
            flags |= (1 << 25)
            stream.pack_int32(self.ttl_period)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.out = True
        if flags.check_bit(4):
            self.mentioned = True
        if flags.check_bit(5):
            self.media_unread = True
        if flags.check_bit(13):
            self.silent = True
        self.id = data.unpack_int32()
        self.from_id = data.unpack_int64()
        self.chat_id = data.unpack_int64()
        self.message = data.unpack_string()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        self.date = data.unpack_int32()
        if flags.check_bit(2):
            self.fwd_from = MessageFwdHeader()
            self.fwd_from = self.fwd_from.read(data)
        if flags.check_bit(11):
            self.via_bot_id = data.unpack_int64()
        if flags.check_bit(3):
            self.reply_to = MessageReplyHeader()
            self.reply_to = self.reply_to.read(data)
        if flags.check_bit(7):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(25):
            self.ttl_period = data.unpack_int32()
        return self

class updateShort(TLObject):
    ID = 0x78d4dec1
    def __init__(self, update = None, date = None):
        self.update = update
        self.date = date
    def __str__(self):
        return 'updateShort'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.update.write())
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.update = Update()
        self.update = self.update.read(data)
        self.date = data.unpack_int32()
        return self

class updatesCombined(TLObject):
    ID = 0x725b04c3
    def __init__(self, updates = None, users = None, chats = None, date = None, seq_start = None, seq = None):
        self.updates = updates
        self.users = users
        self.chats = chats
        self.date = date
        self.seq_start = seq_start
        self.seq = seq
    def __str__(self):
        return 'updatesCombined'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.updates))
        for vec_k_2 in self.updates:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(self.date)
        stream.pack_int32(self.seq_start)
        stream.pack_int32(self.seq)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.updates = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Update()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.updates.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.date = data.unpack_int32()
        self.seq_start = data.unpack_int32()
        self.seq = data.unpack_int32()
        return self

class updates(TLObject):
    ID = 0x74ae4240
    def __init__(self, updates = None, users = None, chats = None, date = None, seq = None):
        self.updates = updates
        self.users = users
        self.chats = chats
        self.date = date
        self.seq = seq
    def __str__(self):
        return 'updates'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.updates))
        for vec_k_2 in self.updates:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(self.date)
        stream.pack_int32(self.seq)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.updates = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Update()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.updates.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.date = data.unpack_int32()
        self.seq = data.unpack_int32()
        return self

class updateShortSentMessage(TLObject):
    ID = 0x9015e101
    def __init__(self, flags = None, out = None, id = None, pts = None, pts_count = None, date = None, media = None, entities = None, ttl_period = None):
        self.flags = flags
        self.out = out
        self.id = id
        self.pts = pts
        self.pts_count = pts_count
        self.date = date
        self.media = media
        self.entities = entities
        self.ttl_period = ttl_period
    def __str__(self):
        return 'updateShortSentMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.out:
            flags |= (1 << 1)
        stream.pack_int32(self.id)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        stream.pack_int32(self.date)
        if self.media:
            flags |= (1 << 9)
            stream.pack_bytes(self.media.write())
        if self.entities:
            flags |= (1 << 7)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.ttl_period:
            flags |= (1 << 25)
            stream.pack_int32(self.ttl_period)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.out = True
        self.id = data.unpack_int32()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        self.date = data.unpack_int32()
        if flags.check_bit(9):
            self.media = MessageMedia()
            self.media = self.media.read(data)
        if flags.check_bit(7):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(25):
            self.ttl_period = data.unpack_int32()
        return self

class account_getNotifyExceptions(TLObject):
    ID = 0x53577479
    def __init__(self, flags = None, compare_sound = None, peer = None):
        self.flags = flags
        self.compare_sound = compare_sound
        self.peer = peer
    def __str__(self):
        return 'account_getNotifyExceptions'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.compare_sound:
            flags |= (1 << 1)
        if self.peer:
            flags |= (1 << 0)
            stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.compare_sound = True
        if flags.check_bit(0):
            self.peer = InputNotifyPeer()
            self.peer = self.peer.read(data)
        return self

class contacts_deleteContacts(TLObject):
    ID = 0x96a0e00
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'contacts_deleteContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.id.append(elem_of_1_vec)
        return self

class contacts_addContact(TLObject):
    ID = 0xe8f463d0
    def __init__(self, flags = None, add_phone_privacy_exception = None, id = None, first_name = None, last_name = None, phone = None):
        self.flags = flags
        self.add_phone_privacy_exception = add_phone_privacy_exception
        self.id = id
        self.first_name = first_name
        self.last_name = last_name
        self.phone = phone
    def __str__(self):
        return 'contacts_addContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.add_phone_privacy_exception:
            flags |= (1 << 0)
        stream.pack_bytes(self.id.write())
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_string(self.phone)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.add_phone_privacy_exception = True
        self.id = InputUser()
        self.id = self.id.read(data)
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.phone = data.unpack_string()
        return self

class contacts_acceptContact(TLObject):
    ID = 0xf831a20f
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'contacts_acceptContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputUser()
        self.id = self.id.read(data)
        return self

class contacts_getLocated(TLObject):
    ID = 0xd348bc44
    def __init__(self, flags = None, background = None, geo_point = None, self_expires = None):
        self.flags = flags
        self.background = background
        self.geo_point = geo_point
        self.self_expires = self_expires
    def __str__(self):
        return 'contacts_getLocated'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.background:
            flags |= (1 << 1)
        stream.pack_bytes(self.geo_point.write())
        if self.self_expires:
            flags |= (1 << 0)
            stream.pack_int32(self.self_expires)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.background = True
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        if flags.check_bit(0):
            self.self_expires = data.unpack_int32()
        return self

class contacts_blockFromReplies(TLObject):
    ID = 0x29a8962c
    def __init__(self, flags = None, delete_message = None, delete_history = None, report_spam = None, msg_id = None):
        self.flags = flags
        self.delete_message = delete_message
        self.delete_history = delete_history
        self.report_spam = report_spam
        self.msg_id = msg_id
    def __str__(self):
        return 'contacts_blockFromReplies'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.delete_message:
            flags |= (1 << 0)
        if self.delete_history:
            flags |= (1 << 1)
        if self.report_spam:
            flags |= (1 << 2)
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.delete_message = True
        if flags.check_bit(1):
            self.delete_history = True
        if flags.check_bit(2):
            self.report_spam = True
        self.msg_id = data.unpack_int32()
        return self

class messages_sendMessage(TLObject):
    ID = 0x520c3870
    def __init__(self, flags = None, no_webpage = None, silent = None, background = None, clear_draft = None, peer = None, reply_to_msg_id = None, message = None, random_id = None, reply_markup = None, entities = None, schedule_date = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = peer
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.random_id = random_id
        self.reply_markup = reply_markup
        self.entities = entities
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messages_sendMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 1)
        if self.silent:
            flags |= (1 << 5)
        if self.background:
            flags |= (1 << 6)
        if self.clear_draft:
            flags |= (1 << 7)
        stream.pack_bytes(self.peer.write())
        if self.reply_to_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.reply_to_msg_id)
        stream.pack_string(self.message)
        stream.pack_int64(self.random_id)
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.schedule_date:
            flags |= (1 << 10)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.no_webpage = True
        if flags.check_bit(5):
            self.silent = True
        if flags.check_bit(6):
            self.background = True
        if flags.check_bit(7):
            self.clear_draft = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        if flags.check_bit(0):
            self.reply_to_msg_id = data.unpack_int32()
        self.message = data.unpack_string()
        self.random_id = data.unpack_int64()
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(10):
            self.schedule_date = data.unpack_int32()
        return self

class messages_sendMedia(TLObject):
    ID = 0x3491eba9
    def __init__(self, flags = None, silent = None, background = None, clear_draft = None, peer = None, reply_to_msg_id = None, media = None, message = None, random_id = None, reply_markup = None, entities = None, schedule_date = None):
        self.flags = flags
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = peer
        self.reply_to_msg_id = reply_to_msg_id
        self.media = media
        self.message = message
        self.random_id = random_id
        self.reply_markup = reply_markup
        self.entities = entities
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messages_sendMedia'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 5)
        if self.background:
            flags |= (1 << 6)
        if self.clear_draft:
            flags |= (1 << 7)
        stream.pack_bytes(self.peer.write())
        if self.reply_to_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.reply_to_msg_id)
        stream.pack_bytes(self.media.write())
        stream.pack_string(self.message)
        stream.pack_int64(self.random_id)
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.schedule_date:
            flags |= (1 << 10)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(5):
            self.silent = True
        if flags.check_bit(6):
            self.background = True
        if flags.check_bit(7):
            self.clear_draft = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        if flags.check_bit(0):
            self.reply_to_msg_id = data.unpack_int32()
        self.media = InputMedia()
        self.media = self.media.read(data)
        self.message = data.unpack_string()
        self.random_id = data.unpack_int64()
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(10):
            self.schedule_date = data.unpack_int32()
        return self

class messages_forwardMessages(TLObject):
    ID = 0xd9fee60e
    def __init__(self, flags = None, silent = None, background = None, with_my_score = None, drop_author = None, drop_media_captions = None, from_peer = None, id = None, random_id = None, to_peer = None, schedule_date = None):
        self.flags = flags
        self.silent = silent
        self.background = background
        self.with_my_score = with_my_score
        self.drop_author = drop_author
        self.drop_media_captions = drop_media_captions
        self.from_peer = from_peer
        self.id = id
        self.random_id = random_id
        self.to_peer = to_peer
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messages_forwardMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 5)
        if self.background:
            flags |= (1 << 6)
        if self.with_my_score:
            flags |= (1 << 8)
        if self.drop_author:
            flags |= (1 << 11)
        if self.drop_media_captions:
            flags |= (1 << 12)
        stream.pack_bytes(self.from_peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.random_id))
        for vec_k_3 in self.random_id:
            stream.pack_int64(vec_k_3)
        stream.pack_bytes(self.to_peer.write())
        if self.schedule_date:
            flags |= (1 << 10)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(5):
            self.silent = True
        if flags.check_bit(6):
            self.background = True
        if flags.check_bit(8):
            self.with_my_score = True
        if flags.check_bit(11):
            self.drop_author = True
        if flags.check_bit(12):
            self.drop_media_captions = True
        self.from_peer = InputPeer()
        self.from_peer = self.from_peer.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        self.random_id = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            self.random_id.append(data.unpack_int64())
        self.to_peer = InputPeer()
        self.to_peer = self.to_peer.read(data)
        if flags.check_bit(10):
            self.schedule_date = data.unpack_int32()
        return self

class messages_editChatTitle(TLObject):
    ID = 0x73783ffd
    def __init__(self, chat_id = None, title = None):
        self.chat_id = chat_id
        self.title = title
    def __str__(self):
        return 'messages_editChatTitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.title = data.unpack_string()
        return self

class messages_editChatPhoto(TLObject):
    ID = 0x35ddd674
    def __init__(self, chat_id = None, photo = None):
        self.chat_id = chat_id
        self.photo = photo
    def __str__(self):
        return 'messages_editChatPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_bytes(self.photo.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.photo = InputChatPhoto()
        self.photo = self.photo.read(data)
        return self

class messages_addChatUser(TLObject):
    ID = 0xf24753e3
    def __init__(self, chat_id = None, user_id = None, fwd_limit = None):
        self.chat_id = chat_id
        self.user_id = user_id
        self.fwd_limit = fwd_limit
    def __str__(self):
        return 'messages_addChatUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(self.fwd_limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.fwd_limit = data.unpack_int32()
        return self

class messages_deleteChatUser(TLObject):
    ID = 0xa2185cab
    def __init__(self, flags = None, revoke_history = None, chat_id = None, user_id = None):
        self.flags = flags
        self.revoke_history = revoke_history
        self.chat_id = chat_id
        self.user_id = user_id
    def __str__(self):
        return 'messages_deleteChatUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.revoke_history:
            flags |= (1 << 0)
        stream.pack_int64(self.chat_id)
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.revoke_history = True
        self.chat_id = data.unpack_int64()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class messages_createChat(TLObject):
    ID = 0x9cb126e
    def __init__(self, users = None, title = None):
        self.users = users
        self.title = title
    def __str__(self):
        return 'messages_createChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        self.title = data.unpack_string()
        return self

class messages_importChatInvite(TLObject):
    ID = 0x6c50051c
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_importChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_string()
        return self

class messages_startBot(TLObject):
    ID = 0xe6df7378
    def __init__(self, bot = None, peer = None, random_id = None, start_param = None):
        self.bot = bot
        self.peer = peer
        self.random_id = random_id
        self.start_param = start_param
    def __str__(self):
        return 'messages_startBot'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.bot.write())
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.random_id)
        stream.pack_string(self.start_param)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.bot = InputUser()
        self.bot = self.bot.read(data)
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.random_id = data.unpack_int64()
        self.start_param = data.unpack_string()
        return self

class messages_migrateChat(TLObject):
    ID = 0xa2875319
    def __init__(self, chat_id = None):
        self.chat_id = chat_id
    def __str__(self):
        return 'messages_migrateChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int64()
        return self

class messages_sendInlineBotResult(TLObject):
    ID = 0x220815b0
    def __init__(self, flags = None, silent = None, background = None, clear_draft = None, hide_via = None, peer = None, reply_to_msg_id = None, random_id = None, query_id = None, id = None, schedule_date = None):
        self.flags = flags
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.hide_via = hide_via
        self.peer = peer
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id
        self.query_id = query_id
        self.id = id
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messages_sendInlineBotResult'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 5)
        if self.background:
            flags |= (1 << 6)
        if self.clear_draft:
            flags |= (1 << 7)
        if self.hide_via:
            flags |= (1 << 11)
        stream.pack_bytes(self.peer.write())
        if self.reply_to_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.reply_to_msg_id)
        stream.pack_int64(self.random_id)
        stream.pack_int64(self.query_id)
        stream.pack_string(self.id)
        if self.schedule_date:
            flags |= (1 << 10)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(5):
            self.silent = True
        if flags.check_bit(6):
            self.background = True
        if flags.check_bit(7):
            self.clear_draft = True
        if flags.check_bit(11):
            self.hide_via = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        if flags.check_bit(0):
            self.reply_to_msg_id = data.unpack_int32()
        self.random_id = data.unpack_int64()
        self.query_id = data.unpack_int64()
        self.id = data.unpack_string()
        if flags.check_bit(10):
            self.schedule_date = data.unpack_int32()
        return self

class messages_editMessage(TLObject):
    ID = 0x48f71778
    def __init__(self, flags = None, no_webpage = None, peer = None, id = None, message = None, media = None, reply_markup = None, entities = None, schedule_date = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.peer = peer
        self.id = id
        self.message = message
        self.media = media
        self.reply_markup = reply_markup
        self.entities = entities
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messages_editMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 1)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.id)
        if self.message:
            flags |= (1 << 11)
            stream.pack_string(self.message)
        if self.media:
            flags |= (1 << 14)
            stream.pack_bytes(self.media.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.schedule_date:
            flags |= (1 << 15)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.no_webpage = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = data.unpack_int32()
        if flags.check_bit(11):
            self.message = data.unpack_string()
        if flags.check_bit(14):
            self.media = InputMedia()
            self.media = self.media.read(data)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(15):
            self.schedule_date = data.unpack_int32()
        return self

class messages_getAllDrafts(TLObject):
    ID = 0x6a3f8d65
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_getAllDrafts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_setGameScore(TLObject):
    ID = 0x8ef8ecc0
    def __init__(self, flags = None, edit_message = None, force = None, peer = None, id = None, user_id = None, score = None):
        self.flags = flags
        self.edit_message = edit_message
        self.force = force
        self.peer = peer
        self.id = id
        self.user_id = user_id
        self.score = score
    def __str__(self):
        return 'messages_setGameScore'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.edit_message:
            flags |= (1 << 0)
        if self.force:
            flags |= (1 << 1)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.id)
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(self.score)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.edit_message = True
        if flags.check_bit(1):
            self.force = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = data.unpack_int32()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.score = data.unpack_int32()
        return self

class messages_sendScreenshotNotification(TLObject):
    ID = 0xc97df020
    def __init__(self, peer = None, reply_to_msg_id = None, random_id = None):
        self.peer = peer
        self.reply_to_msg_id = reply_to_msg_id
        self.random_id = random_id
    def __str__(self):
        return 'messages_sendScreenshotNotification'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.reply_to_msg_id)
        stream.pack_int64(self.random_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.reply_to_msg_id = data.unpack_int32()
        self.random_id = data.unpack_int64()
        return self

class messages_sendMultiMedia(TLObject):
    ID = 0xcc0110cb
    def __init__(self, flags = None, silent = None, background = None, clear_draft = None, peer = None, reply_to_msg_id = None, multi_media = None, schedule_date = None):
        self.flags = flags
        self.silent = silent
        self.background = background
        self.clear_draft = clear_draft
        self.peer = peer
        self.reply_to_msg_id = reply_to_msg_id
        self.multi_media = multi_media
        self.schedule_date = schedule_date
    def __str__(self):
        return 'messages_sendMultiMedia'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 5)
        if self.background:
            flags |= (1 << 6)
        if self.clear_draft:
            flags |= (1 << 7)
        stream.pack_bytes(self.peer.write())
        if self.reply_to_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.reply_to_msg_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.multi_media))
        for vec_k_2 in self.multi_media:
            stream.pack_bytes(vec_k_2.write())
        if self.schedule_date:
            flags |= (1 << 10)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(5):
            self.silent = True
        if flags.check_bit(6):
            self.background = True
        if flags.check_bit(7):
            self.clear_draft = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        if flags.check_bit(0):
            self.reply_to_msg_id = data.unpack_int32()
        self.multi_media = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputSingleMedia()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.multi_media.append(elem_of_1_vec)
        if flags.check_bit(10):
            self.schedule_date = data.unpack_int32()
        return self

class messages_updatePinnedMessage(TLObject):
    ID = 0xd2aaf7ec
    def __init__(self, flags = None, silent = None, unpin = None, pm_oneside = None, peer = None, id = None):
        self.flags = flags
        self.silent = silent
        self.unpin = unpin
        self.pm_oneside = pm_oneside
        self.peer = peer
        self.id = id
    def __str__(self):
        return 'messages_updatePinnedMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 0)
        if self.unpin:
            flags |= (1 << 1)
        if self.pm_oneside:
            flags |= (1 << 2)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.silent = True
        if flags.check_bit(1):
            self.unpin = True
        if flags.check_bit(2):
            self.pm_oneside = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = data.unpack_int32()
        return self

class messages_sendVote(TLObject):
    ID = 0x10ea6184
    def __init__(self, peer = None, msg_id = None, options = None):
        self.peer = peer
        self.msg_id = msg_id
        self.options = options
    def __str__(self):
        return 'messages_sendVote'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.options))
        for vec_k_2 in self.options:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.options = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.options.append(data.unpack_string())
        return self

class messages_getPollResults(TLObject):
    ID = 0x73bb643b
    def __init__(self, peer = None, msg_id = None):
        self.peer = peer
        self.msg_id = msg_id
    def __str__(self):
        return 'messages_getPollResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        return self

class messages_editChatDefaultBannedRights(TLObject):
    ID = 0xa5866b41
    def __init__(self, peer = None, banned_rights = None):
        self.peer = peer
        self.banned_rights = banned_rights
    def __str__(self):
        return 'messages_editChatDefaultBannedRights'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.banned_rights.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.banned_rights = ChatBannedRights()
        self.banned_rights = self.banned_rights.read(data)
        return self

class messages_sendScheduledMessages(TLObject):
    ID = 0xbd38850a
    def __init__(self, peer = None, id = None):
        self.peer = peer
        self.id = id
    def __str__(self):
        return 'messages_sendScheduledMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class messages_deleteScheduledMessages(TLObject):
    ID = 0x59ae2b16
    def __init__(self, peer = None, id = None):
        self.peer = peer
        self.id = id
    def __str__(self):
        return 'messages_deleteScheduledMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class messages_setHistoryTTL(TLObject):
    ID = 0xb80e5fe4
    def __init__(self, peer = None, period = None):
        self.peer = peer
        self.period = period
    def __str__(self):
        return 'messages_setHistoryTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.period)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.period = data.unpack_int32()
        return self

class messages_setChatTheme(TLObject):
    ID = 0xe63be13f
    def __init__(self, peer = None, emoticon = None):
        self.peer = peer
        self.emoticon = emoticon
    def __str__(self):
        return 'messages_setChatTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.emoticon)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.emoticon = data.unpack_string()
        return self

class help_getAppChangelog(TLObject):
    ID = 0x9010ef6f
    def __init__(self, prev_app_version = None):
        self.prev_app_version = prev_app_version
    def __str__(self):
        return 'help_getAppChangelog'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.prev_app_version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_app_version = data.unpack_string()
        return self

class channels_createChannel(TLObject):
    ID = 0x3d5fb10f
    def __init__(self, flags = None, broadcast = None, megagroup = None, for_import = None, title = None, about = None, geo_point = None, address = None):
        self.flags = flags
        self.broadcast = broadcast
        self.megagroup = megagroup
        self.for_import = for_import
        self.title = title
        self.about = about
        self.geo_point = geo_point
        self.address = address
    def __str__(self):
        return 'channels_createChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.broadcast:
            flags |= (1 << 0)
        if self.megagroup:
            flags |= (1 << 1)
        if self.for_import:
            flags |= (1 << 3)
        stream.pack_string(self.title)
        stream.pack_string(self.about)
        if self.geo_point:
            flags |= (1 << 2)
            stream.pack_bytes(self.geo_point.write())
        if self.address:
            flags |= (1 << 2)
            stream.pack_string(self.address)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.broadcast = True
        if flags.check_bit(1):
            self.megagroup = True
        if flags.check_bit(3):
            self.for_import = True
        self.title = data.unpack_string()
        self.about = data.unpack_string()
        if flags.check_bit(2):
            self.geo_point = InputGeoPoint()
            self.geo_point = self.geo_point.read(data)
        if flags.check_bit(2):
            self.address = data.unpack_string()
        return self

class channels_editAdmin(TLObject):
    ID = 0xd33c8902
    def __init__(self, channel = None, user_id = None, admin_rights = None, rank = None):
        self.channel = channel
        self.user_id = user_id
        self.admin_rights = admin_rights
        self.rank = rank
    def __str__(self):
        return 'channels_editAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.user_id.write())
        stream.pack_bytes(self.admin_rights.write())
        stream.pack_string(self.rank)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.admin_rights = ChatAdminRights()
        self.admin_rights = self.admin_rights.read(data)
        self.rank = data.unpack_string()
        return self

class channels_editTitle(TLObject):
    ID = 0x566decd0
    def __init__(self, channel = None, title = None):
        self.channel = channel
        self.title = title
    def __str__(self):
        return 'channels_editTitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.title = data.unpack_string()
        return self

class channels_editPhoto(TLObject):
    ID = 0xf12e57c9
    def __init__(self, channel = None, photo = None):
        self.channel = channel
        self.photo = photo
    def __str__(self):
        return 'channels_editPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.photo.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.photo = InputChatPhoto()
        self.photo = self.photo.read(data)
        return self

class channels_joinChannel(TLObject):
    ID = 0x24b524c5
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'channels_joinChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class channels_leaveChannel(TLObject):
    ID = 0xf836aa95
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'channels_leaveChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class channels_inviteToChannel(TLObject):
    ID = 0x199f3a6c
    def __init__(self, channel = None, users = None):
        self.channel = channel
        self.users = users
    def __str__(self):
        return 'channels_inviteToChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class channels_deleteChannel(TLObject):
    ID = 0xc0111fe3
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'channels_deleteChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class channels_toggleSignatures(TLObject):
    ID = 0x1f69b606
    def __init__(self, channel = None, enabled = None):
        self.channel = channel
        self.enabled = enabled
    def __str__(self):
        return 'channels_toggleSignatures'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.enabled.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.enabled = Bool()
        self.enabled = self.enabled.read(data)
        return self

class channels_editBanned(TLObject):
    ID = 0x96e6cd81
    def __init__(self, channel = None, participant = None, banned_rights = None):
        self.channel = channel
        self.participant = participant
        self.banned_rights = banned_rights
    def __str__(self):
        return 'channels_editBanned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.participant.write())
        stream.pack_bytes(self.banned_rights.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.participant = InputPeer()
        self.participant = self.participant.read(data)
        self.banned_rights = ChatBannedRights()
        self.banned_rights = self.banned_rights.read(data)
        return self

class channels_togglePreHistoryHidden(TLObject):
    ID = 0xeabbb94c
    def __init__(self, channel = None, enabled = None):
        self.channel = channel
        self.enabled = enabled
    def __str__(self):
        return 'channels_togglePreHistoryHidden'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.enabled.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.enabled = Bool()
        self.enabled = self.enabled.read(data)
        return self

class channels_editCreator(TLObject):
    ID = 0x8f38cd1f
    def __init__(self, channel = None, user_id = None, password = None):
        self.channel = channel
        self.user_id = user_id
        self.password = password
    def __str__(self):
        return 'channels_editCreator'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.user_id.write())
        stream.pack_bytes(self.password.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.password = InputCheckPasswordSRP()
        self.password = self.password.read(data)
        return self

class channels_toggleSlowMode(TLObject):
    ID = 0xedd49ef0
    def __init__(self, channel = None, seconds = None):
        self.channel = channel
        self.seconds = seconds
    def __str__(self):
        return 'channels_toggleSlowMode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(self.seconds)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.seconds = data.unpack_int32()
        return self

class channels_convertToGigagroup(TLObject):
    ID = 0xb290c69
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'channels_convertToGigagroup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class phone_discardCall(TLObject):
    ID = 0xb2cbc1c0
    def __init__(self, flags = None, video = None, peer = None, duration = None, reason = None, connection_id = None):
        self.flags = flags
        self.video = video
        self.peer = peer
        self.duration = duration
        self.reason = reason
        self.connection_id = connection_id
    def __str__(self):
        return 'phone_discardCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.video:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.duration)
        stream.pack_bytes(self.reason.write())
        stream.pack_int64(self.connection_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.video = True
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        self.duration = data.unpack_int32()
        self.reason = PhoneCallDiscardReason()
        self.reason = self.reason.read(data)
        self.connection_id = data.unpack_int64()
        return self

class phone_setCallRating(TLObject):
    ID = 0x59ead627
    def __init__(self, flags = None, user_initiative = None, peer = None, rating = None, comment = None):
        self.flags = flags
        self.user_initiative = user_initiative
        self.peer = peer
        self.rating = rating
        self.comment = comment
    def __str__(self):
        return 'phone_setCallRating'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.user_initiative:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.rating)
        stream.pack_string(self.comment)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.user_initiative = True
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        self.rating = data.unpack_int32()
        self.comment = data.unpack_string()
        return self

class phone_createGroupCall(TLObject):
    ID = 0x48cdc6d8
    def __init__(self, flags = None, peer = None, random_id = None, title = None, schedule_date = None):
        self.flags = flags
        self.peer = peer
        self.random_id = random_id
        self.title = title
        self.schedule_date = schedule_date
    def __str__(self):
        return 'phone_createGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.random_id)
        flags = 0x0
        if self.title:
            flags |= (1 << 0)
            stream.pack_string(self.title)
        if self.schedule_date:
            flags |= (1 << 1)
            stream.pack_int32(self.schedule_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.random_id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.title = data.unpack_string()
        if flags.check_bit(1):
            self.schedule_date = data.unpack_int32()
        return self

class phone_joinGroupCall(TLObject):
    ID = 0xb132ff7b
    def __init__(self, flags = None, muted = None, video_stopped = None, call = None, join_as = None, invite_hash = None, params = None):
        self.flags = flags
        self.muted = muted
        self.video_stopped = video_stopped
        self.call = call
        self.join_as = join_as
        self.invite_hash = invite_hash
        self.params = params
    def __str__(self):
        return 'phone_joinGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.muted:
            flags |= (1 << 0)
        if self.video_stopped:
            flags |= (1 << 2)
        stream.pack_bytes(self.call.write())
        stream.pack_bytes(self.join_as.write())
        if self.invite_hash:
            flags |= (1 << 1)
            stream.pack_string(self.invite_hash)
        stream.pack_bytes(self.params.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.muted = True
        if flags.check_bit(2):
            self.video_stopped = True
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.join_as = InputPeer()
        self.join_as = self.join_as.read(data)
        if flags.check_bit(1):
            self.invite_hash = data.unpack_string()
        self.params = DataJSON()
        self.params = self.params.read(data)
        return self

class phone_leaveGroupCall(TLObject):
    ID = 0x500377f9
    def __init__(self, call = None, source = None):
        self.call = call
        self.source = source
    def __str__(self):
        return 'phone_leaveGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(self.source)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.source = data.unpack_int32()
        return self

class phone_inviteToGroupCall(TLObject):
    ID = 0x7b393160
    def __init__(self, call = None, users = None):
        self.call = call
        self.users = users
    def __str__(self):
        return 'phone_inviteToGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class phone_discardGroupCall(TLObject):
    ID = 0x7a777135
    def __init__(self, call = None):
        self.call = call
    def __str__(self):
        return 'phone_discardGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        return self

class phone_toggleGroupCallSettings(TLObject):
    ID = 0x74bbb43d
    def __init__(self, flags = None, reset_invite_hash = None, call = None, join_muted = None):
        self.flags = flags
        self.reset_invite_hash = reset_invite_hash
        self.call = call
        self.join_muted = join_muted
    def __str__(self):
        return 'phone_toggleGroupCallSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.reset_invite_hash:
            flags |= (1 << 1)
        stream.pack_bytes(self.call.write())
        if self.join_muted:
            flags |= (1 << 0)
            stream.pack_bytes(self.join_muted.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.reset_invite_hash = True
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        if flags.check_bit(0):
            self.join_muted = Bool()
            self.join_muted = self.join_muted.read(data)
        return self

class phone_toggleGroupCallRecord(TLObject):
    ID = 0xf128c708
    def __init__(self, flags = None, start = None, video = None, call = None, title = None, video_portrait = None):
        self.flags = flags
        self.start = start
        self.video = video
        self.call = call
        self.title = title
        self.video_portrait = video_portrait
    def __str__(self):
        return 'phone_toggleGroupCallRecord'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.start:
            flags |= (1 << 0)
        if self.video:
            flags |= (1 << 2)
        stream.pack_bytes(self.call.write())
        if self.title:
            flags |= (1 << 1)
            stream.pack_string(self.title)
        if self.video_portrait:
            flags |= (1 << 2)
            stream.pack_bytes(self.video_portrait.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.start = True
        if flags.check_bit(2):
            self.video = True
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        if flags.check_bit(1):
            self.title = data.unpack_string()
        if flags.check_bit(2):
            self.video_portrait = Bool()
            self.video_portrait = self.video_portrait.read(data)
        return self

class phone_editGroupCallParticipant(TLObject):
    ID = 0xa5273abf
    def __init__(self, flags = None, call = None, participant = None, muted = None, volume = None, raise_hand = None, video_stopped = None, video_paused = None, presentation_paused = None):
        self.flags = flags
        self.call = call
        self.participant = participant
        self.muted = muted
        self.volume = volume
        self.raise_hand = raise_hand
        self.video_stopped = video_stopped
        self.video_paused = video_paused
        self.presentation_paused = presentation_paused
    def __str__(self):
        return 'phone_editGroupCallParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_bytes(self.participant.write())
        flags = 0x0
        if self.muted:
            flags |= (1 << 0)
            stream.pack_bytes(self.muted.write())
        if self.volume:
            flags |= (1 << 1)
            stream.pack_int32(self.volume)
        if self.raise_hand:
            flags |= (1 << 2)
            stream.pack_bytes(self.raise_hand.write())
        if self.video_stopped:
            flags |= (1 << 3)
            stream.pack_bytes(self.video_stopped.write())
        if self.video_paused:
            flags |= (1 << 4)
            stream.pack_bytes(self.video_paused.write())
        if self.presentation_paused:
            flags |= (1 << 5)
            stream.pack_bytes(self.presentation_paused.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.participant = InputPeer()
        self.participant = self.participant.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.muted = Bool()
            self.muted = self.muted.read(data)
        if flags.check_bit(1):
            self.volume = data.unpack_int32()
        if flags.check_bit(2):
            self.raise_hand = Bool()
            self.raise_hand = self.raise_hand.read(data)
        if flags.check_bit(3):
            self.video_stopped = Bool()
            self.video_stopped = self.video_stopped.read(data)
        if flags.check_bit(4):
            self.video_paused = Bool()
            self.video_paused = self.video_paused.read(data)
        if flags.check_bit(5):
            self.presentation_paused = Bool()
            self.presentation_paused = self.presentation_paused.read(data)
        return self

class phone_editGroupCallTitle(TLObject):
    ID = 0x1ca6ac0a
    def __init__(self, call = None, title = None):
        self.call = call
        self.title = title
    def __str__(self):
        return 'phone_editGroupCallTitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.title = data.unpack_string()
        return self

class phone_toggleGroupCallStartSubscription(TLObject):
    ID = 0x219c34e6
    def __init__(self, call = None, subscribed = None):
        self.call = call
        self.subscribed = subscribed
    def __str__(self):
        return 'phone_toggleGroupCallStartSubscription'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_bytes(self.subscribed.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.subscribed = Bool()
        self.subscribed = self.subscribed.read(data)
        return self

class phone_startScheduledGroupCall(TLObject):
    ID = 0x5680e342
    def __init__(self, call = None):
        self.call = call
    def __str__(self):
        return 'phone_startScheduledGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        return self

class phone_joinGroupCallPresentation(TLObject):
    ID = 0xcbea6bc4
    def __init__(self, call = None, params = None):
        self.call = call
        self.params = params
    def __str__(self):
        return 'phone_joinGroupCallPresentation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_bytes(self.params.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.params = DataJSON()
        self.params = self.params.read(data)
        return self

class phone_leaveGroupCallPresentation(TLObject):
    ID = 0x1c50d144
    def __init__(self, call = None):
        self.call = call
    def __str__(self):
        return 'phone_leaveGroupCallPresentation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        return self

class folders_editPeerFolders(TLObject):
    ID = 0x6847d0ab
    def __init__(self, folder_peers = None):
        self.folder_peers = folder_peers
    def __str__(self):
        return 'folders_editPeerFolders'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.folder_peers))
        for vec_k_2 in self.folder_peers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.folder_peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputFolderPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.folder_peers.append(elem_of_1_vec)
        return self

class folders_deleteFolder(TLObject):
    ID = 0x1c295881
    def __init__(self, folder_id = None):
        self.folder_id = folder_id
    def __str__(self):
        return 'folders_deleteFolder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.folder_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.folder_id = data.unpack_int32()
        return self

class Updates(TLObject):
    DERIVED_OBJECTS = {0xe317af7e: updatesTooLong, 0x313bc7f8: updateShortMessage, 0x4d6deea5: updateShortChatMessage, 0x78d4dec1: updateShort, 0x725b04c3: updatesCombined, 0x74ae4240: updates, 0x9015e101: updateShortSentMessage, 0x53577479: account_getNotifyExceptions, 0x96a0e00: contacts_deleteContacts, 0xe8f463d0: contacts_addContact, 0xf831a20f: contacts_acceptContact, 0xd348bc44: contacts_getLocated, 0x29a8962c: contacts_blockFromReplies, 0x520c3870: messages_sendMessage, 0x3491eba9: messages_sendMedia, 0xd9fee60e: messages_forwardMessages, 0x73783ffd: messages_editChatTitle, 0x35ddd674: messages_editChatPhoto, 0xf24753e3: messages_addChatUser, 0xa2185cab: messages_deleteChatUser, 0x9cb126e: messages_createChat, 0x6c50051c: messages_importChatInvite, 0xe6df7378: messages_startBot, 0xa2875319: messages_migrateChat, 0x220815b0: messages_sendInlineBotResult, 0x48f71778: messages_editMessage, 0x6a3f8d65: messages_getAllDrafts, 0x8ef8ecc0: messages_setGameScore, 0xc97df020: messages_sendScreenshotNotification, 0xcc0110cb: messages_sendMultiMedia, 0xd2aaf7ec: messages_updatePinnedMessage, 0x10ea6184: messages_sendVote, 0x73bb643b: messages_getPollResults, 0xa5866b41: messages_editChatDefaultBannedRights, 0xbd38850a: messages_sendScheduledMessages, 0x59ae2b16: messages_deleteScheduledMessages, 0xb80e5fe4: messages_setHistoryTTL, 0xe63be13f: messages_setChatTheme, 0x9010ef6f: help_getAppChangelog, 0x3d5fb10f: channels_createChannel, 0xd33c8902: channels_editAdmin, 0x566decd0: channels_editTitle, 0xf12e57c9: channels_editPhoto, 0x24b524c5: channels_joinChannel, 0xf836aa95: channels_leaveChannel, 0x199f3a6c: channels_inviteToChannel, 0xc0111fe3: channels_deleteChannel, 0x1f69b606: channels_toggleSignatures, 0x96e6cd81: channels_editBanned, 0xeabbb94c: channels_togglePreHistoryHidden, 0x8f38cd1f: channels_editCreator, 0xedd49ef0: channels_toggleSlowMode, 0xb290c69: channels_convertToGigagroup, 0xb2cbc1c0: phone_discardCall, 0x59ead627: phone_setCallRating, 0x48cdc6d8: phone_createGroupCall, 0xb132ff7b: phone_joinGroupCall, 0x500377f9: phone_leaveGroupCall, 0x7b393160: phone_inviteToGroupCall, 0x7a777135: phone_discardGroupCall, 0x74bbb43d: phone_toggleGroupCallSettings, 0xf128c708: phone_toggleGroupCallRecord, 0xa5273abf: phone_editGroupCallParticipant, 0x1ca6ac0a: phone_editGroupCallTitle, 0x219c34e6: phone_toggleGroupCallStartSubscription, 0x5680e342: phone_startScheduledGroupCall, 0xcbea6bc4: phone_joinGroupCallPresentation, 0x1c50d144: phone_leaveGroupCallPresentation, 0x6847d0ab: folders_editPeerFolders, 0x1c295881: folders_deleteFolder}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class photos_photos(TLObject):
    ID = 0x8dca6aa5
    def __init__(self, photos = None, users = None):
        self.photos = photos
        self.users = users
    def __str__(self):
        return 'photos_photos'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.photos))
        for vec_k_2 in self.photos:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.photos = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Photo()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.photos.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class photos_photosSlice(TLObject):
    ID = 0x15051f54
    def __init__(self, count = None, photos = None, users = None):
        self.count = count
        self.photos = photos
        self.users = users
    def __str__(self):
        return 'photos_photosSlice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.photos))
        for vec_k_2 in self.photos:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.photos = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Photo()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.photos.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class photos_getUserPhotos(TLObject):
    ID = 0x91cd32a8
    def __init__(self, user_id = None, offset = None, max_id = None, limit = None):
        self.user_id = user_id
        self.offset = offset
        self.max_id = max_id
        self.limit = limit
    def __str__(self):
        return 'photos_getUserPhotos'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(self.offset)
        stream.pack_int64(self.max_id)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.offset = data.unpack_int32()
        self.max_id = data.unpack_int64()
        self.limit = data.unpack_int32()
        return self

class photos_Photos(TLObject):
    DERIVED_OBJECTS = {0x8dca6aa5: photos_photos, 0x15051f54: photos_photosSlice, 0x91cd32a8: photos_getUserPhotos}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class photos_photo(TLObject):
    ID = 0x20212ca8
    def __init__(self, photo = None, users = None):
        self.photo = photo
        self.users = users
    def __str__(self):
        return 'photos_photo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.photo.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.photo = Photo()
        self.photo = self.photo.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = User()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class photos_updateProfilePhoto(TLObject):
    ID = 0x72d4742c
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'photos_updateProfilePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputPhoto()
        self.id = self.id.read(data)
        return self

class photos_uploadProfilePhoto(TLObject):
    ID = 0x89f30f69
    def __init__(self, flags = None, file = None, video = None, video_start_ts = None):
        self.flags = flags
        self.file = file
        self.video = video
        self.video_start_ts = video_start_ts
    def __str__(self):
        return 'photos_uploadProfilePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.file:
            flags |= (1 << 0)
            stream.pack_bytes(self.file.write())
        if self.video:
            flags |= (1 << 1)
            stream.pack_bytes(self.video.write())
        if self.video_start_ts:
            flags |= (1 << 2)
            stream.pack_double(self.video_start_ts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.file = InputFile()
            self.file = self.file.read(data)
        if flags.check_bit(1):
            self.video = InputFile()
            self.video = self.video.read(data)
        if flags.check_bit(2):
            self.video_start_ts = data.unpack_double()
        return self

class photos_Photo(TLObject):
    DERIVED_OBJECTS = {0x20212ca8: photos_photo, 0x72d4742c: photos_updateProfilePhoto, 0x89f30f69: photos_uploadProfilePhoto}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class upload_file(TLObject):
    ID = 0x96a18d5
    def __init__(self, type = None, mtime = None, bytes = None):
        self.type = type
        self.mtime = mtime
        self.bytes = bytes
    def __str__(self):
        return 'upload_file'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_int32(self.mtime)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = storage_FileType()
        self.type = self.type.read(data)
        self.mtime = data.unpack_int32()
        self.bytes = data.unpack_string()
        return self

class upload_fileCdnRedirect(TLObject):
    ID = 0xf18cda44
    def __init__(self, dc_id = None, file_token = None, encryption_key = None, encryption_iv = None, file_hashes = None):
        self.dc_id = dc_id
        self.file_token = file_token
        self.encryption_key = encryption_key
        self.encryption_iv = encryption_iv
        self.file_hashes = file_hashes
    def __str__(self):
        return 'upload_fileCdnRedirect'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.dc_id)
        stream.pack_string(self.file_token)
        stream.pack_string(self.encryption_key)
        stream.pack_string(self.encryption_iv)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.file_hashes))
        for vec_k_2 in self.file_hashes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_id = data.unpack_int32()
        self.file_token = data.unpack_string()
        self.encryption_key = data.unpack_string()
        self.encryption_iv = data.unpack_string()
        self.file_hashes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = FileHash()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.file_hashes.append(elem_of_1_vec)
        return self

class upload_getFile(TLObject):
    ID = 0xb15a9afc
    def __init__(self, flags = None, precise = None, cdn_supported = None, location = None, offset = None, limit = None):
        self.flags = flags
        self.precise = precise
        self.cdn_supported = cdn_supported
        self.location = location
        self.offset = offset
        self.limit = limit
    def __str__(self):
        return 'upload_getFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.precise:
            flags |= (1 << 0)
        if self.cdn_supported:
            flags |= (1 << 1)
        stream.pack_bytes(self.location.write())
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.precise = True
        if flags.check_bit(1):
            self.cdn_supported = True
        self.location = InputFileLocation()
        self.location = self.location.read(data)
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class upload_File(TLObject):
    DERIVED_OBJECTS = {0x96a18d5: upload_file, 0xf18cda44: upload_fileCdnRedirect, 0xb15a9afc: upload_getFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class dcOption(TLObject):
    ID = 0x18b7a10d
    def __init__(self, flags = None, ipv6 = None, media_only = None, tcpo_only = None, cdn = None, static = None, id = None, ip_address = None, port = None, secret = None):
        self.flags = flags
        self.ipv6 = ipv6
        self.media_only = media_only
        self.tcpo_only = tcpo_only
        self.cdn = cdn
        self.static = static
        self.id = id
        self.ip_address = ip_address
        self.port = port
        self.secret = secret
    def __str__(self):
        return 'dcOption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.ipv6:
            flags |= (1 << 0)
        if self.media_only:
            flags |= (1 << 1)
        if self.tcpo_only:
            flags |= (1 << 2)
        if self.cdn:
            flags |= (1 << 3)
        if self.static:
            flags |= (1 << 4)
        stream.pack_int32(self.id)
        stream.pack_string(self.ip_address)
        stream.pack_int32(self.port)
        if self.secret:
            flags |= (1 << 10)
            stream.pack_string(self.secret)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.ipv6 = True
        if flags.check_bit(1):
            self.media_only = True
        if flags.check_bit(2):
            self.tcpo_only = True
        if flags.check_bit(3):
            self.cdn = True
        if flags.check_bit(4):
            self.static = True
        self.id = data.unpack_int32()
        self.ip_address = data.unpack_string()
        self.port = data.unpack_int32()
        if flags.check_bit(10):
            self.secret = data.unpack_string()
        return self

class DcOption(TLObject):
    DERIVED_OBJECTS = {0x18b7a10d: dcOption}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class config(TLObject):
    ID = 0x330b4067
    def __init__(self, flags = None, phonecalls_enabled = None, default_p2p_contacts = None, preload_featured_stickers = None, ignore_phone_entities = None, revoke_pm_inbox = None, blocked_mode = None, pfs_enabled = None, date = None, expires = None, test_mode = None, this_dc = None, dc_options = None, dc_txt_domain_name = None, chat_size_max = None, megagroup_size_max = None, forwarded_count_max = None, online_update_period_ms = None, offline_blur_timeout_ms = None, offline_idle_timeout_ms = None, online_cloud_timeout_ms = None, notify_cloud_delay_ms = None, notify_default_delay_ms = None, push_chat_period_ms = None, push_chat_limit = None, saved_gifs_limit = None, edit_time_limit = None, revoke_time_limit = None, revoke_pm_time_limit = None, rating_e_decay = None, stickers_recent_limit = None, stickers_faved_limit = None, channels_read_media_period = None, tmp_sessions = None, pinned_dialogs_count_max = None, pinned_infolder_count_max = None, call_receive_timeout_ms = None, call_ring_timeout_ms = None, call_connect_timeout_ms = None, call_packet_timeout_ms = None, me_url_prefix = None, autoupdate_url_prefix = None, gif_search_username = None, venue_search_username = None, img_search_username = None, static_maps_provider = None, caption_length_max = None, message_length_max = None, webfile_dc_id = None, suggested_lang_code = None, lang_pack_version = None, base_lang_pack_version = None):
        self.flags = flags
        self.phonecalls_enabled = phonecalls_enabled
        self.default_p2p_contacts = default_p2p_contacts
        self.preload_featured_stickers = preload_featured_stickers
        self.ignore_phone_entities = ignore_phone_entities
        self.revoke_pm_inbox = revoke_pm_inbox
        self.blocked_mode = blocked_mode
        self.pfs_enabled = pfs_enabled
        self.date = date
        self.expires = expires
        self.test_mode = test_mode
        self.this_dc = this_dc
        self.dc_options = dc_options
        self.dc_txt_domain_name = dc_txt_domain_name
        self.chat_size_max = chat_size_max
        self.megagroup_size_max = megagroup_size_max
        self.forwarded_count_max = forwarded_count_max
        self.online_update_period_ms = online_update_period_ms
        self.offline_blur_timeout_ms = offline_blur_timeout_ms
        self.offline_idle_timeout_ms = offline_idle_timeout_ms
        self.online_cloud_timeout_ms = online_cloud_timeout_ms
        self.notify_cloud_delay_ms = notify_cloud_delay_ms
        self.notify_default_delay_ms = notify_default_delay_ms
        self.push_chat_period_ms = push_chat_period_ms
        self.push_chat_limit = push_chat_limit
        self.saved_gifs_limit = saved_gifs_limit
        self.edit_time_limit = edit_time_limit
        self.revoke_time_limit = revoke_time_limit
        self.revoke_pm_time_limit = revoke_pm_time_limit
        self.rating_e_decay = rating_e_decay
        self.stickers_recent_limit = stickers_recent_limit
        self.stickers_faved_limit = stickers_faved_limit
        self.channels_read_media_period = channels_read_media_period
        self.tmp_sessions = tmp_sessions
        self.pinned_dialogs_count_max = pinned_dialogs_count_max
        self.pinned_infolder_count_max = pinned_infolder_count_max
        self.call_receive_timeout_ms = call_receive_timeout_ms
        self.call_ring_timeout_ms = call_ring_timeout_ms
        self.call_connect_timeout_ms = call_connect_timeout_ms
        self.call_packet_timeout_ms = call_packet_timeout_ms
        self.me_url_prefix = me_url_prefix
        self.autoupdate_url_prefix = autoupdate_url_prefix
        self.gif_search_username = gif_search_username
        self.venue_search_username = venue_search_username
        self.img_search_username = img_search_username
        self.static_maps_provider = static_maps_provider
        self.caption_length_max = caption_length_max
        self.message_length_max = message_length_max
        self.webfile_dc_id = webfile_dc_id
        self.suggested_lang_code = suggested_lang_code
        self.lang_pack_version = lang_pack_version
        self.base_lang_pack_version = base_lang_pack_version
    def __str__(self):
        return 'config'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.phonecalls_enabled:
            flags |= (1 << 1)
        if self.default_p2p_contacts:
            flags |= (1 << 3)
        if self.preload_featured_stickers:
            flags |= (1 << 4)
        if self.ignore_phone_entities:
            flags |= (1 << 5)
        if self.revoke_pm_inbox:
            flags |= (1 << 6)
        if self.blocked_mode:
            flags |= (1 << 8)
        if self.pfs_enabled:
            flags |= (1 << 13)
        stream.pack_int32(self.date)
        stream.pack_int32(self.expires)
        stream.pack_bytes(self.test_mode.write())
        stream.pack_int32(self.this_dc)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dc_options))
        for vec_k_2 in self.dc_options:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_string(self.dc_txt_domain_name)
        stream.pack_int32(self.chat_size_max)
        stream.pack_int32(self.megagroup_size_max)
        stream.pack_int32(self.forwarded_count_max)
        stream.pack_int32(self.online_update_period_ms)
        stream.pack_int32(self.offline_blur_timeout_ms)
        stream.pack_int32(self.offline_idle_timeout_ms)
        stream.pack_int32(self.online_cloud_timeout_ms)
        stream.pack_int32(self.notify_cloud_delay_ms)
        stream.pack_int32(self.notify_default_delay_ms)
        stream.pack_int32(self.push_chat_period_ms)
        stream.pack_int32(self.push_chat_limit)
        stream.pack_int32(self.saved_gifs_limit)
        stream.pack_int32(self.edit_time_limit)
        stream.pack_int32(self.revoke_time_limit)
        stream.pack_int32(self.revoke_pm_time_limit)
        stream.pack_int32(self.rating_e_decay)
        stream.pack_int32(self.stickers_recent_limit)
        stream.pack_int32(self.stickers_faved_limit)
        stream.pack_int32(self.channels_read_media_period)
        if self.tmp_sessions:
            flags |= (1 << 0)
            stream.pack_int32(self.tmp_sessions)
        stream.pack_int32(self.pinned_dialogs_count_max)
        stream.pack_int32(self.pinned_infolder_count_max)
        stream.pack_int32(self.call_receive_timeout_ms)
        stream.pack_int32(self.call_ring_timeout_ms)
        stream.pack_int32(self.call_connect_timeout_ms)
        stream.pack_int32(self.call_packet_timeout_ms)
        stream.pack_string(self.me_url_prefix)
        if self.autoupdate_url_prefix:
            flags |= (1 << 7)
            stream.pack_string(self.autoupdate_url_prefix)
        if self.gif_search_username:
            flags |= (1 << 9)
            stream.pack_string(self.gif_search_username)
        if self.venue_search_username:
            flags |= (1 << 10)
            stream.pack_string(self.venue_search_username)
        if self.img_search_username:
            flags |= (1 << 11)
            stream.pack_string(self.img_search_username)
        if self.static_maps_provider:
            flags |= (1 << 12)
            stream.pack_string(self.static_maps_provider)
        stream.pack_int32(self.caption_length_max)
        stream.pack_int32(self.message_length_max)
        stream.pack_int32(self.webfile_dc_id)
        if self.suggested_lang_code:
            flags |= (1 << 2)
            stream.pack_string(self.suggested_lang_code)
        if self.lang_pack_version:
            flags |= (1 << 2)
            stream.pack_int32(self.lang_pack_version)
        if self.base_lang_pack_version:
            flags |= (1 << 2)
            stream.pack_int32(self.base_lang_pack_version)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.phonecalls_enabled = True
        if flags.check_bit(3):
            self.default_p2p_contacts = True
        if flags.check_bit(4):
            self.preload_featured_stickers = True
        if flags.check_bit(5):
            self.ignore_phone_entities = True
        if flags.check_bit(6):
            self.revoke_pm_inbox = True
        if flags.check_bit(8):
            self.blocked_mode = True
        if flags.check_bit(13):
            self.pfs_enabled = True
        self.date = data.unpack_int32()
        self.expires = data.unpack_int32()
        self.test_mode = Bool()
        self.test_mode = self.test_mode.read(data)
        self.this_dc = data.unpack_int32()
        self.dc_options = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = DcOption()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.dc_options.append(elem_of_1_vec)
        self.dc_txt_domain_name = data.unpack_string()
        self.chat_size_max = data.unpack_int32()
        self.megagroup_size_max = data.unpack_int32()
        self.forwarded_count_max = data.unpack_int32()
        self.online_update_period_ms = data.unpack_int32()
        self.offline_blur_timeout_ms = data.unpack_int32()
        self.offline_idle_timeout_ms = data.unpack_int32()
        self.online_cloud_timeout_ms = data.unpack_int32()
        self.notify_cloud_delay_ms = data.unpack_int32()
        self.notify_default_delay_ms = data.unpack_int32()
        self.push_chat_period_ms = data.unpack_int32()
        self.push_chat_limit = data.unpack_int32()
        self.saved_gifs_limit = data.unpack_int32()
        self.edit_time_limit = data.unpack_int32()
        self.revoke_time_limit = data.unpack_int32()
        self.revoke_pm_time_limit = data.unpack_int32()
        self.rating_e_decay = data.unpack_int32()
        self.stickers_recent_limit = data.unpack_int32()
        self.stickers_faved_limit = data.unpack_int32()
        self.channels_read_media_period = data.unpack_int32()
        if flags.check_bit(0):
            self.tmp_sessions = data.unpack_int32()
        self.pinned_dialogs_count_max = data.unpack_int32()
        self.pinned_infolder_count_max = data.unpack_int32()
        self.call_receive_timeout_ms = data.unpack_int32()
        self.call_ring_timeout_ms = data.unpack_int32()
        self.call_connect_timeout_ms = data.unpack_int32()
        self.call_packet_timeout_ms = data.unpack_int32()
        self.me_url_prefix = data.unpack_string()
        if flags.check_bit(7):
            self.autoupdate_url_prefix = data.unpack_string()
        if flags.check_bit(9):
            self.gif_search_username = data.unpack_string()
        if flags.check_bit(10):
            self.venue_search_username = data.unpack_string()
        if flags.check_bit(11):
            self.img_search_username = data.unpack_string()
        if flags.check_bit(12):
            self.static_maps_provider = data.unpack_string()
        self.caption_length_max = data.unpack_int32()
        self.message_length_max = data.unpack_int32()
        self.webfile_dc_id = data.unpack_int32()
        if flags.check_bit(2):
            self.suggested_lang_code = data.unpack_string()
        if flags.check_bit(2):
            self.lang_pack_version = data.unpack_int32()
        if flags.check_bit(2):
            self.base_lang_pack_version = data.unpack_int32()
        return self

class help_getConfig(TLObject):
    ID = 0xc4f9186b
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class Config(TLObject):
    DERIVED_OBJECTS = {0x330b4067: config, 0xc4f9186b: help_getConfig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class nearestDc(TLObject):
    ID = 0x8e1a1775
    def __init__(self, country = None, this_dc = None, nearest_dc = None):
        self.country = country
        self.this_dc = this_dc
        self.nearest_dc = nearest_dc
    def __str__(self):
        return 'nearestDc'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.country)
        stream.pack_int32(self.this_dc)
        stream.pack_int32(self.nearest_dc)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.country = data.unpack_string()
        self.this_dc = data.unpack_int32()
        self.nearest_dc = data.unpack_int32()
        return self

class help_getNearestDc(TLObject):
    ID = 0x1fb33026
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getNearestDc'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class NearestDc(TLObject):
    DERIVED_OBJECTS = {0x8e1a1775: nearestDc, 0x1fb33026: help_getNearestDc}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_appUpdate(TLObject):
    ID = 0xccbbce30
    def __init__(self, flags = None, can_not_skip = None, id = None, version = None, text = None, entities = None, document = None, url = None, sticker = None):
        self.flags = flags
        self.can_not_skip = can_not_skip
        self.id = id
        self.version = version
        self.text = text
        self.entities = entities
        self.document = document
        self.url = url
        self.sticker = sticker
    def __str__(self):
        return 'help_appUpdate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.can_not_skip:
            flags |= (1 << 0)
        stream.pack_int32(self.id)
        stream.pack_string(self.version)
        stream.pack_string(self.text)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.entities))
        for vec_k_2 in self.entities:
            stream.pack_bytes(vec_k_2.write())
        if self.document:
            flags |= (1 << 1)
            stream.pack_bytes(self.document.write())
        if self.url:
            flags |= (1 << 2)
            stream.pack_string(self.url)
        if self.sticker:
            flags |= (1 << 3)
            stream.pack_bytes(self.sticker.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.can_not_skip = True
        self.id = data.unpack_int32()
        self.version = data.unpack_string()
        self.text = data.unpack_string()
        self.entities = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageEntity()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.entities.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.document = Document()
            self.document = self.document.read(data)
        if flags.check_bit(2):
            self.url = data.unpack_string()
        if flags.check_bit(3):
            self.sticker = Document()
            self.sticker = self.sticker.read(data)
        return self

class help_noAppUpdate(TLObject):
    ID = 0xc45a6536
    def __init__(self):
        pass
    def __str__(self):
        return 'help_noAppUpdate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_getAppUpdate(TLObject):
    ID = 0x522d5a7d
    def __init__(self, source = None):
        self.source = source
    def __str__(self):
        return 'help_getAppUpdate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.source)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.source = data.unpack_string()
        return self

class help_AppUpdate(TLObject):
    DERIVED_OBJECTS = {0xccbbce30: help_appUpdate, 0xc45a6536: help_noAppUpdate, 0x522d5a7d: help_getAppUpdate}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_inviteText(TLObject):
    ID = 0x18cb9f78
    def __init__(self, message = None):
        self.message = message
    def __str__(self):
        return 'help_inviteText'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.message)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = data.unpack_string()
        return self

class help_getInviteText(TLObject):
    ID = 0x4d392343
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getInviteText'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_InviteText(TLObject):
    DERIVED_OBJECTS = {0x18cb9f78: help_inviteText, 0x4d392343: help_getInviteText}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class encryptedChatEmpty(TLObject):
    ID = 0xab7ec0a0
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'encryptedChatEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        return self

class encryptedChatWaiting(TLObject):
    ID = 0x66b25953
    def __init__(self, id = None, access_hash = None, date = None, admin_id = None, participant_id = None):
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
    def __str__(self):
        return 'encryptedChatWaiting'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        return self

class encryptedChatRequested(TLObject):
    ID = 0x48f1d94c
    def __init__(self, flags = None, folder_id = None, id = None, access_hash = None, date = None, admin_id = None, participant_id = None, g_a = None):
        self.flags = flags
        self.folder_id = folder_id
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a = g_a
    def __str__(self):
        return 'encryptedChatRequested'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.folder_id:
            flags |= (1 << 0)
            stream.pack_int32(self.folder_id)
        stream.pack_int32(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        stream.pack_string(self.g_a)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.folder_id = data.unpack_int32()
        self.id = data.unpack_int32()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        self.g_a = data.unpack_string()
        return self

class encryptedChat(TLObject):
    ID = 0x61f0d4c7
    def __init__(self, id = None, access_hash = None, date = None, admin_id = None, participant_id = None, g_a_or_b = None, key_fingerprint = None):
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_or_b = g_a_or_b
        self.key_fingerprint = key_fingerprint
    def __str__(self):
        return 'encryptedChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        stream.pack_string(self.g_a_or_b)
        stream.pack_int64(self.key_fingerprint)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        self.g_a_or_b = data.unpack_string()
        self.key_fingerprint = data.unpack_int64()
        return self

class encryptedChatDiscarded(TLObject):
    ID = 0x1e1c7c45
    def __init__(self, flags = None, history_deleted = None, id = None):
        self.flags = flags
        self.history_deleted = history_deleted
        self.id = id
    def __str__(self):
        return 'encryptedChatDiscarded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.history_deleted:
            flags |= (1 << 0)
        stream.pack_int32(self.id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.history_deleted = True
        self.id = data.unpack_int32()
        return self

class messages_requestEncryption(TLObject):
    ID = 0xf64daf43
    def __init__(self, user_id = None, random_id = None, g_a = None):
        self.user_id = user_id
        self.random_id = random_id
        self.g_a = g_a
    def __str__(self):
        return 'messages_requestEncryption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(self.random_id)
        stream.pack_string(self.g_a)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.random_id = data.unpack_int32()
        self.g_a = data.unpack_string()
        return self

class messages_acceptEncryption(TLObject):
    ID = 0x3dbc0415
    def __init__(self, peer = None, g_b = None, key_fingerprint = None):
        self.peer = peer
        self.g_b = g_b
        self.key_fingerprint = key_fingerprint
    def __str__(self):
        return 'messages_acceptEncryption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.g_b)
        stream.pack_int64(self.key_fingerprint)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.g_b = data.unpack_string()
        self.key_fingerprint = data.unpack_int64()
        return self

class EncryptedChat(TLObject):
    DERIVED_OBJECTS = {0xab7ec0a0: encryptedChatEmpty, 0x66b25953: encryptedChatWaiting, 0x48f1d94c: encryptedChatRequested, 0x61f0d4c7: encryptedChat, 0x1e1c7c45: encryptedChatDiscarded, 0xf64daf43: messages_requestEncryption, 0x3dbc0415: messages_acceptEncryption}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputEncryptedChat(TLObject):
    ID = 0xf141b5e1
    def __init__(self, chat_id = None, access_hash = None):
        self.chat_id = chat_id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputEncryptedChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.chat_id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat_id = data.unpack_int32()
        self.access_hash = data.unpack_int64()
        return self

class InputEncryptedChat(TLObject):
    DERIVED_OBJECTS = {0xf141b5e1: inputEncryptedChat}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class encryptedFileEmpty(TLObject):
    ID = 0xc21f497e
    def __init__(self):
        pass
    def __str__(self):
        return 'encryptedFileEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class encryptedFile(TLObject):
    ID = 0x4a70994c
    def __init__(self, id = None, access_hash = None, size = None, dc_id = None, key_fingerprint = None):
        self.id = id
        self.access_hash = access_hash
        self.size = size
        self.dc_id = dc_id
        self.key_fingerprint = key_fingerprint
    def __str__(self):
        return 'encryptedFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.size)
        stream.pack_int32(self.dc_id)
        stream.pack_int32(self.key_fingerprint)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.size = data.unpack_int32()
        self.dc_id = data.unpack_int32()
        self.key_fingerprint = data.unpack_int32()
        return self

class messages_uploadEncryptedFile(TLObject):
    ID = 0x5057c497
    def __init__(self, peer = None, file = None):
        self.peer = peer
        self.file = file
    def __str__(self):
        return 'messages_uploadEncryptedFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.file.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.file = InputEncryptedFile()
        self.file = self.file.read(data)
        return self

class EncryptedFile(TLObject):
    DERIVED_OBJECTS = {0xc21f497e: encryptedFileEmpty, 0x4a70994c: encryptedFile, 0x5057c497: messages_uploadEncryptedFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputEncryptedFileEmpty(TLObject):
    ID = 0x1837c364
    def __init__(self):
        pass
    def __str__(self):
        return 'inputEncryptedFileEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputEncryptedFileUploaded(TLObject):
    ID = 0x64bd0306
    def __init__(self, id = None, parts = None, md5_checksum = None, key_fingerprint = None):
        self.id = id
        self.parts = parts
        self.md5_checksum = md5_checksum
        self.key_fingerprint = key_fingerprint
    def __str__(self):
        return 'inputEncryptedFileUploaded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.parts)
        stream.pack_string(self.md5_checksum)
        stream.pack_int32(self.key_fingerprint)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.parts = data.unpack_int32()
        self.md5_checksum = data.unpack_string()
        self.key_fingerprint = data.unpack_int32()
        return self

class inputEncryptedFile(TLObject):
    ID = 0x5a17b5e5
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputEncryptedFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputEncryptedFileBigUploaded(TLObject):
    ID = 0x2dc173c8
    def __init__(self, id = None, parts = None, key_fingerprint = None):
        self.id = id
        self.parts = parts
        self.key_fingerprint = key_fingerprint
    def __str__(self):
        return 'inputEncryptedFileBigUploaded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.parts)
        stream.pack_int32(self.key_fingerprint)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.parts = data.unpack_int32()
        self.key_fingerprint = data.unpack_int32()
        return self

class InputEncryptedFile(TLObject):
    DERIVED_OBJECTS = {0x1837c364: inputEncryptedFileEmpty, 0x64bd0306: inputEncryptedFileUploaded, 0x5a17b5e5: inputEncryptedFile, 0x2dc173c8: inputEncryptedFileBigUploaded}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class encryptedMessage(TLObject):
    ID = 0xed18c118
    def __init__(self, random_id = None, chat_id = None, date = None, bytes = None, file = None):
        self.random_id = random_id
        self.chat_id = chat_id
        self.date = date
        self.bytes = bytes
        self.file = file
    def __str__(self):
        return 'encryptedMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.random_id)
        stream.pack_int32(self.chat_id)
        stream.pack_int32(self.date)
        stream.pack_string(self.bytes)
        stream.pack_bytes(self.file.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.random_id = data.unpack_int64()
        self.chat_id = data.unpack_int32()
        self.date = data.unpack_int32()
        self.bytes = data.unpack_string()
        self.file = EncryptedFile()
        self.file = self.file.read(data)
        return self

class encryptedMessageService(TLObject):
    ID = 0x23734b06
    def __init__(self, random_id = None, chat_id = None, date = None, bytes = None):
        self.random_id = random_id
        self.chat_id = chat_id
        self.date = date
        self.bytes = bytes
    def __str__(self):
        return 'encryptedMessageService'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.random_id)
        stream.pack_int32(self.chat_id)
        stream.pack_int32(self.date)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.random_id = data.unpack_int64()
        self.chat_id = data.unpack_int32()
        self.date = data.unpack_int32()
        self.bytes = data.unpack_string()
        return self

class EncryptedMessage(TLObject):
    DERIVED_OBJECTS = {0xed18c118: encryptedMessage, 0x23734b06: encryptedMessageService}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_dhConfigNotModified(TLObject):
    ID = 0xc0e24635
    def __init__(self, random = None):
        self.random = random
    def __str__(self):
        return 'messages_dhConfigNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.random)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.random = data.unpack_string()
        return self

class messages_dhConfig(TLObject):
    ID = 0x2c221edd
    def __init__(self, g = None, p = None, version = None, random = None):
        self.g = g
        self.p = p
        self.version = version
        self.random = random
    def __str__(self):
        return 'messages_dhConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.g)
        stream.pack_string(self.p)
        stream.pack_int32(self.version)
        stream.pack_string(self.random)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.g = data.unpack_int32()
        self.p = data.unpack_string()
        self.version = data.unpack_int32()
        self.random = data.unpack_string()
        return self

class messages_getDhConfig(TLObject):
    ID = 0x26cf8950
    def __init__(self, version = None, random_length = None):
        self.version = version
        self.random_length = random_length
    def __str__(self):
        return 'messages_getDhConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.version)
        stream.pack_int32(self.random_length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.version = data.unpack_int32()
        self.random_length = data.unpack_int32()
        return self

class messages_DhConfig(TLObject):
    DERIVED_OBJECTS = {0xc0e24635: messages_dhConfigNotModified, 0x2c221edd: messages_dhConfig, 0x26cf8950: messages_getDhConfig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_sentEncryptedMessage(TLObject):
    ID = 0x560f8935
    def __init__(self, date = None):
        self.date = date
    def __str__(self):
        return 'messages_sentEncryptedMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.date = data.unpack_int32()
        return self

class messages_sentEncryptedFile(TLObject):
    ID = 0x9493ff32
    def __init__(self, date = None, file = None):
        self.date = date
        self.file = file
    def __str__(self):
        return 'messages_sentEncryptedFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.date)
        stream.pack_bytes(self.file.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.date = data.unpack_int32()
        self.file = EncryptedFile()
        self.file = self.file.read(data)
        return self

class messages_sendEncrypted(TLObject):
    ID = 0x44fa7a15
    def __init__(self, flags = None, silent = None, peer = None, random_id = None, data = None):
        self.flags = flags
        self.silent = silent
        self.peer = peer
        self.random_id = random_id
        self.data = data
    def __str__(self):
        return 'messages_sendEncrypted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.random_id)
        stream.pack_string(self.data)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.silent = True
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.random_id = data.unpack_int64()
        self.data = data.unpack_string()
        return self

class messages_sendEncryptedFile(TLObject):
    ID = 0x5559481d
    def __init__(self, flags = None, silent = None, peer = None, random_id = None, data = None, file = None):
        self.flags = flags
        self.silent = silent
        self.peer = peer
        self.random_id = random_id
        self.data = data
        self.file = file
    def __str__(self):
        return 'messages_sendEncryptedFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.silent:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.random_id)
        stream.pack_string(self.data)
        stream.pack_bytes(self.file.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.silent = True
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.random_id = data.unpack_int64()
        self.data = data.unpack_string()
        self.file = InputEncryptedFile()
        self.file = self.file.read(data)
        return self

class messages_sendEncryptedService(TLObject):
    ID = 0x32d439a4
    def __init__(self, peer = None, random_id = None, data = None):
        self.peer = peer
        self.random_id = random_id
        self.data = data
    def __str__(self):
        return 'messages_sendEncryptedService'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.random_id)
        stream.pack_string(self.data)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputEncryptedChat()
        self.peer = self.peer.read(data)
        self.random_id = data.unpack_int64()
        self.data = data.unpack_string()
        return self

class messages_SentEncryptedMessage(TLObject):
    DERIVED_OBJECTS = {0x560f8935: messages_sentEncryptedMessage, 0x9493ff32: messages_sentEncryptedFile, 0x44fa7a15: messages_sendEncrypted, 0x5559481d: messages_sendEncryptedFile, 0x32d439a4: messages_sendEncryptedService}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputDocumentEmpty(TLObject):
    ID = 0x72f0eaae
    def __init__(self):
        pass
    def __str__(self):
        return 'inputDocumentEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputDocument(TLObject):
    ID = 0x1abfb575
    def __init__(self, id = None, access_hash = None, file_reference = None):
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
    def __str__(self):
        return 'inputDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        return self

class InputDocument(TLObject):
    DERIVED_OBJECTS = {0x72f0eaae: inputDocumentEmpty, 0x1abfb575: inputDocument}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class documentEmpty(TLObject):
    ID = 0x36f8c871
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'documentEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class document(TLObject):
    ID = 0x1e87342b
    def __init__(self, flags = None, id = None, access_hash = None, file_reference = None, date = None, mime_type = None, size = None, thumbs = None, video_thumbs = None, dc_id = None, attributes = None):
        self.flags = flags
        self.id = id
        self.access_hash = access_hash
        self.file_reference = file_reference
        self.date = date
        self.mime_type = mime_type
        self.size = size
        self.thumbs = thumbs
        self.video_thumbs = video_thumbs
        self.dc_id = dc_id
        self.attributes = attributes
    def __str__(self):
        return 'document'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.file_reference)
        stream.pack_int32(self.date)
        stream.pack_string(self.mime_type)
        stream.pack_int32(self.size)
        flags = 0x0
        if self.thumbs:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.thumbs))
            for vec_k_2 in self.thumbs:
                stream.pack_bytes(vec_k_2.write())
        if self.video_thumbs:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.video_thumbs))
            for vec_k_3 in self.video_thumbs:
                stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(self.dc_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.attributes))
        for vec_k_4 in self.attributes:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.file_reference = data.unpack_string()
        self.date = data.unpack_int32()
        self.mime_type = data.unpack_string()
        self.size = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.thumbs = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = PhotoSize()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.thumbs.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.video_thumbs = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = VideoSize()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.video_thumbs.append(elem_of_2_vec)
        self.dc_id = data.unpack_int32()
        self.attributes = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = DocumentAttribute()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.attributes.append(elem_of_3_vec)
        return self

class account_uploadTheme(TLObject):
    ID = 0x1c3db333
    def __init__(self, flags = None, file = None, thumb = None, file_name = None, mime_type = None):
        self.flags = flags
        self.file = file
        self.thumb = thumb
        self.file_name = file_name
        self.mime_type = mime_type
    def __str__(self):
        return 'account_uploadTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.file.write())
        flags = 0x0
        if self.thumb:
            flags |= (1 << 0)
            stream.pack_bytes(self.thumb.write())
        stream.pack_string(self.file_name)
        stream.pack_string(self.mime_type)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.file = InputFile()
        self.file = self.file.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.thumb = InputFile()
            self.thumb = self.thumb.read(data)
        self.file_name = data.unpack_string()
        self.mime_type = data.unpack_string()
        return self

class messages_getDocumentByHash(TLObject):
    ID = 0x338e2464
    def __init__(self, sha256 = None, size = None, mime_type = None):
        self.sha256 = sha256
        self.size = size
        self.mime_type = mime_type
    def __str__(self):
        return 'messages_getDocumentByHash'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.sha256)
        stream.pack_int32(self.size)
        stream.pack_string(self.mime_type)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.sha256 = data.unpack_string()
        self.size = data.unpack_int32()
        self.mime_type = data.unpack_string()
        return self

class Document(TLObject):
    DERIVED_OBJECTS = {0x36f8c871: documentEmpty, 0x1e87342b: document, 0x1c3db333: account_uploadTheme, 0x338e2464: messages_getDocumentByHash}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_support(TLObject):
    ID = 0x17c6b5f6
    def __init__(self, phone_number = None, user = None):
        self.phone_number = phone_number
        self.user = user
    def __str__(self):
        return 'help_support'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_bytes(self.user.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_number = data.unpack_string()
        self.user = User()
        self.user = self.user.read(data)
        return self

class help_getSupport(TLObject):
    ID = 0x9cdf08cd
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getSupport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_Support(TLObject):
    DERIVED_OBJECTS = {0x17c6b5f6: help_support, 0x9cdf08cd: help_getSupport}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class notifyPeer(TLObject):
    ID = 0x9fd40bd8
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'notifyPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        return self

class notifyUsers(TLObject):
    ID = 0xb4c83b4c
    def __init__(self):
        pass
    def __str__(self):
        return 'notifyUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class notifyChats(TLObject):
    ID = 0xc007cec3
    def __init__(self):
        pass
    def __str__(self):
        return 'notifyChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class notifyBroadcasts(TLObject):
    ID = 0xd612e8ef
    def __init__(self):
        pass
    def __str__(self):
        return 'notifyBroadcasts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class NotifyPeer(TLObject):
    DERIVED_OBJECTS = {0x9fd40bd8: notifyPeer, 0xb4c83b4c: notifyUsers, 0xc007cec3: notifyChats, 0xd612e8ef: notifyBroadcasts}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class sendMessageTypingAction(TLObject):
    ID = 0x16bf744e
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageTypingAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageCancelAction(TLObject):
    ID = 0xfd5ec8f5
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageCancelAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageRecordVideoAction(TLObject):
    ID = 0xa187d66f
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageRecordVideoAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageUploadVideoAction(TLObject):
    ID = 0xe9763aec
    def __init__(self, progress = None):
        self.progress = progress
    def __str__(self):
        return 'sendMessageUploadVideoAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.progress)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.progress = data.unpack_int32()
        return self

class sendMessageRecordAudioAction(TLObject):
    ID = 0xd52f73f7
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageRecordAudioAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageUploadAudioAction(TLObject):
    ID = 0xf351d7ab
    def __init__(self, progress = None):
        self.progress = progress
    def __str__(self):
        return 'sendMessageUploadAudioAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.progress)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.progress = data.unpack_int32()
        return self

class sendMessageUploadPhotoAction(TLObject):
    ID = 0xd1d34a26
    def __init__(self, progress = None):
        self.progress = progress
    def __str__(self):
        return 'sendMessageUploadPhotoAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.progress)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.progress = data.unpack_int32()
        return self

class sendMessageUploadDocumentAction(TLObject):
    ID = 0xaa0cd9e4
    def __init__(self, progress = None):
        self.progress = progress
    def __str__(self):
        return 'sendMessageUploadDocumentAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.progress)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.progress = data.unpack_int32()
        return self

class sendMessageGeoLocationAction(TLObject):
    ID = 0x176f8ba1
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageGeoLocationAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageChooseContactAction(TLObject):
    ID = 0x628cbc6f
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageChooseContactAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageGamePlayAction(TLObject):
    ID = 0xdd6a8f48
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageGamePlayAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageRecordRoundAction(TLObject):
    ID = 0x88f27fbc
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageRecordRoundAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageUploadRoundAction(TLObject):
    ID = 0x243e1c66
    def __init__(self, progress = None):
        self.progress = progress
    def __str__(self):
        return 'sendMessageUploadRoundAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.progress)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.progress = data.unpack_int32()
        return self

class speakingInGroupCallAction(TLObject):
    ID = 0xd92c2285
    def __init__(self):
        pass
    def __str__(self):
        return 'speakingInGroupCallAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageHistoryImportAction(TLObject):
    ID = 0xdbda9246
    def __init__(self, progress = None):
        self.progress = progress
    def __str__(self):
        return 'sendMessageHistoryImportAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.progress)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.progress = data.unpack_int32()
        return self

class sendMessageChooseStickerAction(TLObject):
    ID = 0xb05ac6b1
    def __init__(self):
        pass
    def __str__(self):
        return 'sendMessageChooseStickerAction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class sendMessageEmojiInteraction(TLObject):
    ID = 0x25972bcb
    def __init__(self, emoticon = None, msg_id = None, interaction = None):
        self.emoticon = emoticon
        self.msg_id = msg_id
        self.interaction = interaction
    def __str__(self):
        return 'sendMessageEmojiInteraction'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        stream.pack_int32(self.msg_id)
        stream.pack_bytes(self.interaction.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        self.msg_id = data.unpack_int32()
        self.interaction = DataJSON()
        self.interaction = self.interaction.read(data)
        return self

class sendMessageEmojiInteractionSeen(TLObject):
    ID = 0xb665902e
    def __init__(self, emoticon = None):
        self.emoticon = emoticon
    def __str__(self):
        return 'sendMessageEmojiInteractionSeen'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        return self

class SendMessageAction(TLObject):
    DERIVED_OBJECTS = {0x16bf744e: sendMessageTypingAction, 0xfd5ec8f5: sendMessageCancelAction, 0xa187d66f: sendMessageRecordVideoAction, 0xe9763aec: sendMessageUploadVideoAction, 0xd52f73f7: sendMessageRecordAudioAction, 0xf351d7ab: sendMessageUploadAudioAction, 0xd1d34a26: sendMessageUploadPhotoAction, 0xaa0cd9e4: sendMessageUploadDocumentAction, 0x176f8ba1: sendMessageGeoLocationAction, 0x628cbc6f: sendMessageChooseContactAction, 0xdd6a8f48: sendMessageGamePlayAction, 0x88f27fbc: sendMessageRecordRoundAction, 0x243e1c66: sendMessageUploadRoundAction, 0xd92c2285: speakingInGroupCallAction, 0xdbda9246: sendMessageHistoryImportAction, 0xb05ac6b1: sendMessageChooseStickerAction, 0x25972bcb: sendMessageEmojiInteraction, 0xb665902e: sendMessageEmojiInteractionSeen}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contacts_found(TLObject):
    ID = 0xb3134d9d
    def __init__(self, my_results = None, results = None, chats = None, users = None):
        self.my_results = my_results
        self.results = results
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'contacts_found'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.my_results))
        for vec_k_2 in self.my_results:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.results))
        for vec_k_3 in self.results:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.my_results = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Peer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.my_results.append(elem_of_1_vec)
        self.results = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Peer()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.results.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        return self

class contacts_search(TLObject):
    ID = 0x11f812d8
    def __init__(self, q = None, limit = None):
        self.q = q
        self.limit = limit
    def __str__(self):
        return 'contacts_search'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.q)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.q = data.unpack_string()
        self.limit = data.unpack_int32()
        return self

class contacts_Found(TLObject):
    DERIVED_OBJECTS = {0xb3134d9d: contacts_found, 0x11f812d8: contacts_search}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPrivacyKeyStatusTimestamp(TLObject):
    ID = 0x4f96cb18
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyStatusTimestamp'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyChatInvite(TLObject):
    ID = 0xbdfb0426
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyPhoneCall(TLObject):
    ID = 0xfabadc5f
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyPhoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyPhoneP2P(TLObject):
    ID = 0xdb9e70d2
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyPhoneP2P'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyForwards(TLObject):
    ID = 0xa4dd4c08
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyForwards'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyProfilePhoto(TLObject):
    ID = 0x5719bacc
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyProfilePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyPhoneNumber(TLObject):
    ID = 0x352dafa
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyPhoneNumber'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyKeyAddedByPhone(TLObject):
    ID = 0xd1219bdd
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyKeyAddedByPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class InputPrivacyKey(TLObject):
    DERIVED_OBJECTS = {0x4f96cb18: inputPrivacyKeyStatusTimestamp, 0xbdfb0426: inputPrivacyKeyChatInvite, 0xfabadc5f: inputPrivacyKeyPhoneCall, 0xdb9e70d2: inputPrivacyKeyPhoneP2P, 0xa4dd4c08: inputPrivacyKeyForwards, 0x5719bacc: inputPrivacyKeyProfilePhoto, 0x352dafa: inputPrivacyKeyPhoneNumber, 0xd1219bdd: inputPrivacyKeyAddedByPhone}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class privacyKeyStatusTimestamp(TLObject):
    ID = 0xbc2eab30
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyStatusTimestamp'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyChatInvite(TLObject):
    ID = 0x500e6dfa
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyPhoneCall(TLObject):
    ID = 0x3d662b7b
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyPhoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyPhoneP2P(TLObject):
    ID = 0x39491cc8
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyPhoneP2P'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyForwards(TLObject):
    ID = 0x69ec56a3
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyForwards'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyProfilePhoto(TLObject):
    ID = 0x96151fed
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyProfilePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyPhoneNumber(TLObject):
    ID = 0xd19ae46d
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyPhoneNumber'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyKeyAddedByPhone(TLObject):
    ID = 0x42ffd42b
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyKeyAddedByPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class PrivacyKey(TLObject):
    DERIVED_OBJECTS = {0xbc2eab30: privacyKeyStatusTimestamp, 0x500e6dfa: privacyKeyChatInvite, 0x3d662b7b: privacyKeyPhoneCall, 0x39491cc8: privacyKeyPhoneP2P, 0x69ec56a3: privacyKeyForwards, 0x96151fed: privacyKeyProfilePhoto, 0xd19ae46d: privacyKeyPhoneNumber, 0x42ffd42b: privacyKeyAddedByPhone}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPrivacyValueAllowContacts(TLObject):
    ID = 0xd09e07b
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyValueAllowContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyValueAllowAll(TLObject):
    ID = 0x184b35ce
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyValueAllowAll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyValueAllowUsers(TLObject):
    ID = 0x131cc67f
    def __init__(self, users = None):
        self.users = users
    def __str__(self):
        return 'inputPrivacyValueAllowUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class inputPrivacyValueDisallowContacts(TLObject):
    ID = 0xba52007
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyValueDisallowContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyValueDisallowAll(TLObject):
    ID = 0xd66b66c9
    def __init__(self):
        pass
    def __str__(self):
        return 'inputPrivacyValueDisallowAll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputPrivacyValueDisallowUsers(TLObject):
    ID = 0x90110467
    def __init__(self, users = None):
        self.users = users
    def __str__(self):
        return 'inputPrivacyValueDisallowUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class inputPrivacyValueAllowChatParticipants(TLObject):
    ID = 0x840649cf
    def __init__(self, chats = None):
        self.chats = chats
    def __str__(self):
        return 'inputPrivacyValueAllowChatParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.chats.append(data.unpack_int64())
        return self

class inputPrivacyValueDisallowChatParticipants(TLObject):
    ID = 0xe94f0f86
    def __init__(self, chats = None):
        self.chats = chats
    def __str__(self):
        return 'inputPrivacyValueDisallowChatParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.chats.append(data.unpack_int64())
        return self

class InputPrivacyRule(TLObject):
    DERIVED_OBJECTS = {0xd09e07b: inputPrivacyValueAllowContacts, 0x184b35ce: inputPrivacyValueAllowAll, 0x131cc67f: inputPrivacyValueAllowUsers, 0xba52007: inputPrivacyValueDisallowContacts, 0xd66b66c9: inputPrivacyValueDisallowAll, 0x90110467: inputPrivacyValueDisallowUsers, 0x840649cf: inputPrivacyValueAllowChatParticipants, 0xe94f0f86: inputPrivacyValueDisallowChatParticipants}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class privacyValueAllowContacts(TLObject):
    ID = 0xfffe1bac
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyValueAllowContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyValueAllowAll(TLObject):
    ID = 0x65427b82
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyValueAllowAll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyValueAllowUsers(TLObject):
    ID = 0xb8905fb2
    def __init__(self, users = None):
        self.users = users
    def __str__(self):
        return 'privacyValueAllowUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.users.append(data.unpack_int64())
        return self

class privacyValueDisallowContacts(TLObject):
    ID = 0xf888fa1a
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyValueDisallowContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyValueDisallowAll(TLObject):
    ID = 0x8b73e763
    def __init__(self):
        pass
    def __str__(self):
        return 'privacyValueDisallowAll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class privacyValueDisallowUsers(TLObject):
    ID = 0xe4621141
    def __init__(self, users = None):
        self.users = users
    def __str__(self):
        return 'privacyValueDisallowUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.users.append(data.unpack_int64())
        return self

class privacyValueAllowChatParticipants(TLObject):
    ID = 0x6b134e8e
    def __init__(self, chats = None):
        self.chats = chats
    def __str__(self):
        return 'privacyValueAllowChatParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.chats.append(data.unpack_int64())
        return self

class privacyValueDisallowChatParticipants(TLObject):
    ID = 0x41c87565
    def __init__(self, chats = None):
        self.chats = chats
    def __str__(self):
        return 'privacyValueDisallowChatParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.chats.append(data.unpack_int64())
        return self

class PrivacyRule(TLObject):
    DERIVED_OBJECTS = {0xfffe1bac: privacyValueAllowContacts, 0x65427b82: privacyValueAllowAll, 0xb8905fb2: privacyValueAllowUsers, 0xf888fa1a: privacyValueDisallowContacts, 0x8b73e763: privacyValueDisallowAll, 0xe4621141: privacyValueDisallowUsers, 0x6b134e8e: privacyValueAllowChatParticipants, 0x41c87565: privacyValueDisallowChatParticipants}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_privacyRules(TLObject):
    ID = 0x50a04e45
    def __init__(self, rules = None, chats = None, users = None):
        self.rules = rules
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'account_privacyRules'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.rules))
        for vec_k_2 in self.rules:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.rules = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PrivacyRule()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.rules.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class account_getPrivacy(TLObject):
    ID = 0xdadbc950
    def __init__(self, key = None):
        self.key = key
    def __str__(self):
        return 'account_getPrivacy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.key.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.key = InputPrivacyKey()
        self.key = self.key.read(data)
        return self

class account_setPrivacy(TLObject):
    ID = 0xc9f81ce8
    def __init__(self, key = None, rules = None):
        self.key = key
        self.rules = rules
    def __str__(self):
        return 'account_setPrivacy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.key.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.rules))
        for vec_k_2 in self.rules:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.key = InputPrivacyKey()
        self.key = self.key.read(data)
        self.rules = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputPrivacyRule()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.rules.append(elem_of_1_vec)
        return self

class account_PrivacyRules(TLObject):
    DERIVED_OBJECTS = {0x50a04e45: account_privacyRules, 0xdadbc950: account_getPrivacy, 0xc9f81ce8: account_setPrivacy}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class accountDaysTTL(TLObject):
    ID = 0xb8d0afdf
    def __init__(self, days = None):
        self.days = days
    def __str__(self):
        return 'accountDaysTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.days)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.days = data.unpack_int32()
        return self

class account_getAccountTTL(TLObject):
    ID = 0x8fc711d
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getAccountTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class AccountDaysTTL(TLObject):
    DERIVED_OBJECTS = {0xb8d0afdf: accountDaysTTL, 0x8fc711d: account_getAccountTTL}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class documentAttributeImageSize(TLObject):
    ID = 0x6c37c15c
    def __init__(self, w = None, h = None):
        self.w = w
        self.h = h
    def __str__(self):
        return 'documentAttributeImageSize'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        return self

class documentAttributeAnimated(TLObject):
    ID = 0x11b58939
    def __init__(self):
        pass
    def __str__(self):
        return 'documentAttributeAnimated'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class documentAttributeSticker(TLObject):
    ID = 0x6319d612
    def __init__(self, flags = None, mask = None, alt = None, stickerset = None, mask_coords = None):
        self.flags = flags
        self.mask = mask
        self.alt = alt
        self.stickerset = stickerset
        self.mask_coords = mask_coords
    def __str__(self):
        return 'documentAttributeSticker'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.mask:
            flags |= (1 << 1)
        stream.pack_string(self.alt)
        stream.pack_bytes(self.stickerset.write())
        if self.mask_coords:
            flags |= (1 << 0)
            stream.pack_bytes(self.mask_coords.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.mask = True
        self.alt = data.unpack_string()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        if flags.check_bit(0):
            self.mask_coords = MaskCoords()
            self.mask_coords = self.mask_coords.read(data)
        return self

class documentAttributeVideo(TLObject):
    ID = 0xef02ce6
    def __init__(self, flags = None, round_message = None, supports_streaming = None, duration = None, w = None, h = None):
        self.flags = flags
        self.round_message = round_message
        self.supports_streaming = supports_streaming
        self.duration = duration
        self.w = w
        self.h = h
    def __str__(self):
        return 'documentAttributeVideo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.round_message:
            flags |= (1 << 0)
        if self.supports_streaming:
            flags |= (1 << 1)
        stream.pack_int32(self.duration)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.round_message = True
        if flags.check_bit(1):
            self.supports_streaming = True
        self.duration = data.unpack_int32()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        return self

class documentAttributeAudio(TLObject):
    ID = 0x9852f9c6
    def __init__(self, flags = None, voice = None, duration = None, title = None, performer = None, waveform = None):
        self.flags = flags
        self.voice = voice
        self.duration = duration
        self.title = title
        self.performer = performer
        self.waveform = waveform
    def __str__(self):
        return 'documentAttributeAudio'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.voice:
            flags |= (1 << 10)
        stream.pack_int32(self.duration)
        if self.title:
            flags |= (1 << 0)
            stream.pack_string(self.title)
        if self.performer:
            flags |= (1 << 1)
            stream.pack_string(self.performer)
        if self.waveform:
            flags |= (1 << 2)
            stream.pack_string(self.waveform)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(10):
            self.voice = True
        self.duration = data.unpack_int32()
        if flags.check_bit(0):
            self.title = data.unpack_string()
        if flags.check_bit(1):
            self.performer = data.unpack_string()
        if flags.check_bit(2):
            self.waveform = data.unpack_string()
        return self

class documentAttributeFilename(TLObject):
    ID = 0x15590068
    def __init__(self, file_name = None):
        self.file_name = file_name
    def __str__(self):
        return 'documentAttributeFilename'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.file_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file_name = data.unpack_string()
        return self

class documentAttributeHasStickers(TLObject):
    ID = 0x9801d2f7
    def __init__(self):
        pass
    def __str__(self):
        return 'documentAttributeHasStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class DocumentAttribute(TLObject):
    DERIVED_OBJECTS = {0x6c37c15c: documentAttributeImageSize, 0x11b58939: documentAttributeAnimated, 0x6319d612: documentAttributeSticker, 0xef02ce6: documentAttributeVideo, 0x9852f9c6: documentAttributeAudio, 0x15590068: documentAttributeFilename, 0x9801d2f7: documentAttributeHasStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_stickersNotModified(TLObject):
    ID = 0xf1749a22
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_stickersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_stickers(TLObject):
    ID = 0x30a6ec7e
    def __init__(self, hash = None, stickers = None):
        self.hash = hash
        self.stickers = stickers
    def __str__(self):
        return 'messages_stickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.stickers))
        for vec_k_2 in self.stickers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.stickers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Document()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.stickers.append(elem_of_1_vec)
        return self

class messages_getStickers(TLObject):
    ID = 0xd5a5d3a1
    def __init__(self, emoticon = None, hash = None):
        self.emoticon = emoticon
        self.hash = hash
    def __str__(self):
        return 'messages_getStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        self.hash = data.unpack_int64()
        return self

class messages_Stickers(TLObject):
    DERIVED_OBJECTS = {0xf1749a22: messages_stickersNotModified, 0x30a6ec7e: messages_stickers, 0xd5a5d3a1: messages_getStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stickerPack(TLObject):
    ID = 0x12b299d4
    def __init__(self, emoticon = None, documents = None):
        self.emoticon = emoticon
        self.documents = documents
    def __str__(self):
        return 'stickerPack'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.documents))
        for vec_k_2 in self.documents:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        self.documents = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.documents.append(data.unpack_int64())
        return self

class StickerPack(TLObject):
    DERIVED_OBJECTS = {0x12b299d4: stickerPack}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_allStickersNotModified(TLObject):
    ID = 0xe86602c3
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_allStickersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_allStickers(TLObject):
    ID = 0xcdbbcebb
    def __init__(self, hash = None, sets = None):
        self.hash = hash
        self.sets = sets
    def __str__(self):
        return 'messages_allStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sets))
        for vec_k_2 in self.sets:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.sets = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerSet()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.sets.append(elem_of_1_vec)
        return self

class messages_getAllStickers(TLObject):
    ID = 0xb8a0a1a8
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_getAllStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class messages_getMaskStickers(TLObject):
    ID = 0x640f82b8
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_getMaskStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class messages_AllStickers(TLObject):
    DERIVED_OBJECTS = {0xe86602c3: messages_allStickersNotModified, 0xcdbbcebb: messages_allStickers, 0xb8a0a1a8: messages_getAllStickers, 0x640f82b8: messages_getMaskStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_affectedMessages(TLObject):
    ID = 0x84d19185
    def __init__(self, pts = None, pts_count = None):
        self.pts = pts
        self.pts_count = pts_count
    def __str__(self):
        return 'messages_affectedMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        return self

class messages_readHistory(TLObject):
    ID = 0xe306d3a
    def __init__(self, peer = None, max_id = None):
        self.peer = peer
        self.max_id = max_id
    def __str__(self):
        return 'messages_readHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.max_id = data.unpack_int32()
        return self

class messages_deleteMessages(TLObject):
    ID = 0xe58e95d2
    def __init__(self, flags = None, revoke = None, id = None):
        self.flags = flags
        self.revoke = revoke
        self.id = id
    def __str__(self):
        return 'messages_deleteMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.revoke:
            flags |= (1 << 0)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.revoke = True
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class messages_readMessageContents(TLObject):
    ID = 0x36a73f77
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'messages_readMessageContents'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class channels_deleteMessages(TLObject):
    ID = 0x84c1fd4e
    def __init__(self, channel = None, id = None):
        self.channel = channel
        self.id = id
    def __str__(self):
        return 'channels_deleteMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        return self

class messages_AffectedMessages(TLObject):
    DERIVED_OBJECTS = {0x84d19185: messages_affectedMessages, 0xe306d3a: messages_readHistory, 0xe58e95d2: messages_deleteMessages, 0x36a73f77: messages_readMessageContents, 0x84c1fd4e: channels_deleteMessages}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class webPageEmpty(TLObject):
    ID = 0xeb1477e8
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'webPageEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class webPagePending(TLObject):
    ID = 0xc586da1c
    def __init__(self, id = None, date = None):
        self.id = id
        self.date = date
    def __str__(self):
        return 'webPagePending'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class webPage(TLObject):
    ID = 0xe89c45b2
    def __init__(self, flags = None, id = None, url = None, display_url = None, hash = None, type = None, site_name = None, title = None, description = None, photo = None, embed_url = None, embed_type = None, embed_width = None, embed_height = None, duration = None, author = None, document = None, cached_page = None, attributes = None):
        self.flags = flags
        self.id = id
        self.url = url
        self.display_url = display_url
        self.hash = hash
        self.type = type
        self.site_name = site_name
        self.title = title
        self.description = description
        self.photo = photo
        self.embed_url = embed_url
        self.embed_type = embed_type
        self.embed_width = embed_width
        self.embed_height = embed_height
        self.duration = duration
        self.author = author
        self.document = document
        self.cached_page = cached_page
        self.attributes = attributes
    def __str__(self):
        return 'webPage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_string(self.url)
        stream.pack_string(self.display_url)
        stream.pack_int32(self.hash)
        flags = 0x0
        if self.type:
            flags |= (1 << 0)
            stream.pack_string(self.type)
        if self.site_name:
            flags |= (1 << 1)
            stream.pack_string(self.site_name)
        if self.title:
            flags |= (1 << 2)
            stream.pack_string(self.title)
        if self.description:
            flags |= (1 << 3)
            stream.pack_string(self.description)
        if self.photo:
            flags |= (1 << 4)
            stream.pack_bytes(self.photo.write())
        if self.embed_url:
            flags |= (1 << 5)
            stream.pack_string(self.embed_url)
        if self.embed_type:
            flags |= (1 << 5)
            stream.pack_string(self.embed_type)
        if self.embed_width:
            flags |= (1 << 6)
            stream.pack_int32(self.embed_width)
        if self.embed_height:
            flags |= (1 << 6)
            stream.pack_int32(self.embed_height)
        if self.duration:
            flags |= (1 << 7)
            stream.pack_int32(self.duration)
        if self.author:
            flags |= (1 << 8)
            stream.pack_string(self.author)
        if self.document:
            flags |= (1 << 9)
            stream.pack_bytes(self.document.write())
        if self.cached_page:
            flags |= (1 << 10)
            stream.pack_bytes(self.cached_page.write())
        if self.attributes:
            flags |= (1 << 12)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.attributes))
            for vec_k_2 in self.attributes:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_int64()
        self.url = data.unpack_string()
        self.display_url = data.unpack_string()
        self.hash = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.type = data.unpack_string()
        if flags.check_bit(1):
            self.site_name = data.unpack_string()
        if flags.check_bit(2):
            self.title = data.unpack_string()
        if flags.check_bit(3):
            self.description = data.unpack_string()
        if flags.check_bit(4):
            self.photo = Photo()
            self.photo = self.photo.read(data)
        if flags.check_bit(5):
            self.embed_url = data.unpack_string()
        if flags.check_bit(5):
            self.embed_type = data.unpack_string()
        if flags.check_bit(6):
            self.embed_width = data.unpack_int32()
        if flags.check_bit(6):
            self.embed_height = data.unpack_int32()
        if flags.check_bit(7):
            self.duration = data.unpack_int32()
        if flags.check_bit(8):
            self.author = data.unpack_string()
        if flags.check_bit(9):
            self.document = Document()
            self.document = self.document.read(data)
        if flags.check_bit(10):
            self.cached_page = Page()
            self.cached_page = self.cached_page.read(data)
        if flags.check_bit(12):
            self.attributes = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = WebPageAttribute()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.attributes.append(elem_of_1_vec)
        return self

class webPageNotModified(TLObject):
    ID = 0x7311ca11
    def __init__(self, flags = None, cached_page_views = None):
        self.flags = flags
        self.cached_page_views = cached_page_views
    def __str__(self):
        return 'webPageNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.cached_page_views:
            flags |= (1 << 0)
            stream.pack_int32(self.cached_page_views)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.cached_page_views = data.unpack_int32()
        return self

class messages_getWebPage(TLObject):
    ID = 0x32ca8f91
    def __init__(self, url = None, hash = None):
        self.url = url
        self.hash = hash
    def __str__(self):
        return 'messages_getWebPage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int32(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.hash = data.unpack_int32()
        return self

class WebPage(TLObject):
    DERIVED_OBJECTS = {0xeb1477e8: webPageEmpty, 0xc586da1c: webPagePending, 0xe89c45b2: webPage, 0x7311ca11: webPageNotModified, 0x32ca8f91: messages_getWebPage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class authorization(TLObject):
    ID = 0xad01d61d
    def __init__(self, flags = None, current = None, official_app = None, password_pending = None, encrypted_requests_disabled = None, hash = None, device_model = None, platform = None, system_version = None, api_id = None, app_name = None, app_version = None, date_created = None, date_active = None, ip = None, country = None, region = None):
        self.flags = flags
        self.current = current
        self.official_app = official_app
        self.password_pending = password_pending
        self.encrypted_requests_disabled = encrypted_requests_disabled
        self.hash = hash
        self.device_model = device_model
        self.platform = platform
        self.system_version = system_version
        self.api_id = api_id
        self.app_name = app_name
        self.app_version = app_version
        self.date_created = date_created
        self.date_active = date_active
        self.ip = ip
        self.country = country
        self.region = region
    def __str__(self):
        return 'authorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.current:
            flags |= (1 << 0)
        if self.official_app:
            flags |= (1 << 1)
        if self.password_pending:
            flags |= (1 << 2)
        if self.encrypted_requests_disabled:
            flags |= (1 << 3)
        stream.pack_int64(self.hash)
        stream.pack_string(self.device_model)
        stream.pack_string(self.platform)
        stream.pack_string(self.system_version)
        stream.pack_int32(self.api_id)
        stream.pack_string(self.app_name)
        stream.pack_string(self.app_version)
        stream.pack_int32(self.date_created)
        stream.pack_int32(self.date_active)
        stream.pack_string(self.ip)
        stream.pack_string(self.country)
        stream.pack_string(self.region)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.current = True
        if flags.check_bit(1):
            self.official_app = True
        if flags.check_bit(2):
            self.password_pending = True
        if flags.check_bit(3):
            self.encrypted_requests_disabled = True
        self.hash = data.unpack_int64()
        self.device_model = data.unpack_string()
        self.platform = data.unpack_string()
        self.system_version = data.unpack_string()
        self.api_id = data.unpack_int32()
        self.app_name = data.unpack_string()
        self.app_version = data.unpack_string()
        self.date_created = data.unpack_int32()
        self.date_active = data.unpack_int32()
        self.ip = data.unpack_string()
        self.country = data.unpack_string()
        self.region = data.unpack_string()
        return self

class auth_acceptLoginToken(TLObject):
    ID = 0xe894ad4d
    def __init__(self, token = None):
        self.token = token
    def __str__(self):
        return 'auth_acceptLoginToken'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.token = data.unpack_string()
        return self

class Authorization(TLObject):
    DERIVED_OBJECTS = {0xad01d61d: authorization, 0xe894ad4d: auth_acceptLoginToken}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_authorizations(TLObject):
    ID = 0x1250abde
    def __init__(self, authorizations = None):
        self.authorizations = authorizations
    def __str__(self):
        return 'account_authorizations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.authorizations))
        for vec_k_2 in self.authorizations:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.authorizations = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Authorization()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.authorizations.append(elem_of_1_vec)
        return self

class account_getAuthorizations(TLObject):
    ID = 0xe320c158
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getAuthorizations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_Authorizations(TLObject):
    DERIVED_OBJECTS = {0x1250abde: account_authorizations, 0xe320c158: account_getAuthorizations}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_password(TLObject):
    ID = 0x185b184f
    def __init__(self, flags = None, has_recovery = None, has_secure_values = None, has_password = None, current_algo = None, srp_B = None, srp_id = None, hint = None, email_unconfirmed_pattern = None, new_algo = None, new_secure_algo = None, secure_random = None, pending_reset_date = None):
        self.flags = flags
        self.has_recovery = has_recovery
        self.has_secure_values = has_secure_values
        self.has_password = has_password
        self.current_algo = current_algo
        self.srp_B = srp_B
        self.srp_id = srp_id
        self.hint = hint
        self.email_unconfirmed_pattern = email_unconfirmed_pattern
        self.new_algo = new_algo
        self.new_secure_algo = new_secure_algo
        self.secure_random = secure_random
        self.pending_reset_date = pending_reset_date
    def __str__(self):
        return 'account_password'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.has_recovery:
            flags |= (1 << 0)
        if self.has_secure_values:
            flags |= (1 << 1)
        if self.has_password:
            flags |= (1 << 2)
        if self.current_algo:
            flags |= (1 << 2)
            stream.pack_bytes(self.current_algo.write())
        if self.srp_B:
            flags |= (1 << 2)
            stream.pack_string(self.srp_B)
        if self.srp_id:
            flags |= (1 << 2)
            stream.pack_int64(self.srp_id)
        if self.hint:
            flags |= (1 << 3)
            stream.pack_string(self.hint)
        if self.email_unconfirmed_pattern:
            flags |= (1 << 4)
            stream.pack_string(self.email_unconfirmed_pattern)
        stream.pack_bytes(self.new_algo.write())
        stream.pack_bytes(self.new_secure_algo.write())
        stream.pack_string(self.secure_random)
        if self.pending_reset_date:
            flags |= (1 << 5)
            stream.pack_int32(self.pending_reset_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.has_recovery = True
        if flags.check_bit(1):
            self.has_secure_values = True
        if flags.check_bit(2):
            self.has_password = True
        if flags.check_bit(2):
            self.current_algo = PasswordKdfAlgo()
            self.current_algo = self.current_algo.read(data)
        if flags.check_bit(2):
            self.srp_B = data.unpack_string()
        if flags.check_bit(2):
            self.srp_id = data.unpack_int64()
        if flags.check_bit(3):
            self.hint = data.unpack_string()
        if flags.check_bit(4):
            self.email_unconfirmed_pattern = data.unpack_string()
        self.new_algo = PasswordKdfAlgo()
        self.new_algo = self.new_algo.read(data)
        self.new_secure_algo = SecurePasswordKdfAlgo()
        self.new_secure_algo = self.new_secure_algo.read(data)
        self.secure_random = data.unpack_string()
        if flags.check_bit(5):
            self.pending_reset_date = data.unpack_int32()
        return self

class account_getPassword(TLObject):
    ID = 0x548a30f5
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_Password(TLObject):
    DERIVED_OBJECTS = {0x185b184f: account_password, 0x548a30f5: account_getPassword}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_passwordSettings(TLObject):
    ID = 0x9a5c33e5
    def __init__(self, flags = None, email = None, secure_settings = None):
        self.flags = flags
        self.email = email
        self.secure_settings = secure_settings
    def __str__(self):
        return 'account_passwordSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.email:
            flags |= (1 << 0)
            stream.pack_string(self.email)
        if self.secure_settings:
            flags |= (1 << 1)
            stream.pack_bytes(self.secure_settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.email = data.unpack_string()
        if flags.check_bit(1):
            self.secure_settings = SecureSecretSettings()
            self.secure_settings = self.secure_settings.read(data)
        return self

class account_getPasswordSettings(TLObject):
    ID = 0x9cd4eaf9
    def __init__(self, password = None):
        self.password = password
    def __str__(self):
        return 'account_getPasswordSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.password.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.password = InputCheckPasswordSRP()
        self.password = self.password.read(data)
        return self

class account_PasswordSettings(TLObject):
    DERIVED_OBJECTS = {0x9a5c33e5: account_passwordSettings, 0x9cd4eaf9: account_getPasswordSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_passwordInputSettings(TLObject):
    ID = 0xc23727c9
    def __init__(self, flags = None, new_algo = None, new_password_hash = None, hint = None, email = None, new_secure_settings = None):
        self.flags = flags
        self.new_algo = new_algo
        self.new_password_hash = new_password_hash
        self.hint = hint
        self.email = email
        self.new_secure_settings = new_secure_settings
    def __str__(self):
        return 'account_passwordInputSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.new_algo:
            flags |= (1 << 0)
            stream.pack_bytes(self.new_algo.write())
        if self.new_password_hash:
            flags |= (1 << 0)
            stream.pack_string(self.new_password_hash)
        if self.hint:
            flags |= (1 << 0)
            stream.pack_string(self.hint)
        if self.email:
            flags |= (1 << 1)
            stream.pack_string(self.email)
        if self.new_secure_settings:
            flags |= (1 << 2)
            stream.pack_bytes(self.new_secure_settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.new_algo = PasswordKdfAlgo()
            self.new_algo = self.new_algo.read(data)
        if flags.check_bit(0):
            self.new_password_hash = data.unpack_string()
        if flags.check_bit(0):
            self.hint = data.unpack_string()
        if flags.check_bit(1):
            self.email = data.unpack_string()
        if flags.check_bit(2):
            self.new_secure_settings = SecureSecretSettings()
            self.new_secure_settings = self.new_secure_settings.read(data)
        return self

class account_PasswordInputSettings(TLObject):
    DERIVED_OBJECTS = {0xc23727c9: account_passwordInputSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_passwordRecovery(TLObject):
    ID = 0x137948a5
    def __init__(self, email_pattern = None):
        self.email_pattern = email_pattern
    def __str__(self):
        return 'auth_passwordRecovery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.email_pattern)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.email_pattern = data.unpack_string()
        return self

class auth_requestPasswordRecovery(TLObject):
    ID = 0xd897bc66
    def __init__(self):
        pass
    def __str__(self):
        return 'auth_requestPasswordRecovery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_PasswordRecovery(TLObject):
    DERIVED_OBJECTS = {0x137948a5: auth_passwordRecovery, 0xd897bc66: auth_requestPasswordRecovery}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class receivedNotifyMessage(TLObject):
    ID = 0xa384b779
    def __init__(self, id = None, flags = None):
        self.id = id
        self.flags = flags
    def __str__(self):
        return 'receivedNotifyMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        self.flags = data.unpack_int32()
        return self

class ReceivedNotifyMessage(TLObject):
    DERIVED_OBJECTS = {0xa384b779: receivedNotifyMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatInviteExported(TLObject):
    ID = 0xb18105e8
    def __init__(self, flags = None, revoked = None, permanent = None, link = None, admin_id = None, date = None, start_date = None, expire_date = None, usage_limit = None, usage = None):
        self.flags = flags
        self.revoked = revoked
        self.permanent = permanent
        self.link = link
        self.admin_id = admin_id
        self.date = date
        self.start_date = start_date
        self.expire_date = expire_date
        self.usage_limit = usage_limit
        self.usage = usage
    def __str__(self):
        return 'chatInviteExported'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.revoked:
            flags |= (1 << 0)
        if self.permanent:
            flags |= (1 << 5)
        stream.pack_string(self.link)
        stream.pack_int64(self.admin_id)
        stream.pack_int32(self.date)
        if self.start_date:
            flags |= (1 << 4)
            stream.pack_int32(self.start_date)
        if self.expire_date:
            flags |= (1 << 1)
            stream.pack_int32(self.expire_date)
        if self.usage_limit:
            flags |= (1 << 2)
            stream.pack_int32(self.usage_limit)
        if self.usage:
            flags |= (1 << 3)
            stream.pack_int32(self.usage)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.revoked = True
        if flags.check_bit(5):
            self.permanent = True
        self.link = data.unpack_string()
        self.admin_id = data.unpack_int64()
        self.date = data.unpack_int32()
        if flags.check_bit(4):
            self.start_date = data.unpack_int32()
        if flags.check_bit(1):
            self.expire_date = data.unpack_int32()
        if flags.check_bit(2):
            self.usage_limit = data.unpack_int32()
        if flags.check_bit(3):
            self.usage = data.unpack_int32()
        return self

class messages_exportChatInvite(TLObject):
    ID = 0x14b9bcd7
    def __init__(self, flags = None, legacy_revoke_permanent = None, peer = None, expire_date = None, usage_limit = None):
        self.flags = flags
        self.legacy_revoke_permanent = legacy_revoke_permanent
        self.peer = peer
        self.expire_date = expire_date
        self.usage_limit = usage_limit
    def __str__(self):
        return 'messages_exportChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.legacy_revoke_permanent:
            flags |= (1 << 2)
        stream.pack_bytes(self.peer.write())
        if self.expire_date:
            flags |= (1 << 0)
            stream.pack_int32(self.expire_date)
        if self.usage_limit:
            flags |= (1 << 1)
            stream.pack_int32(self.usage_limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.legacy_revoke_permanent = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        if flags.check_bit(0):
            self.expire_date = data.unpack_int32()
        if flags.check_bit(1):
            self.usage_limit = data.unpack_int32()
        return self

class ExportedChatInvite(TLObject):
    DERIVED_OBJECTS = {0xb18105e8: chatInviteExported, 0x14b9bcd7: messages_exportChatInvite}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatInviteAlready(TLObject):
    ID = 0x5a686d7c
    def __init__(self, chat = None):
        self.chat = chat
    def __str__(self):
        return 'chatInviteAlready'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.chat.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat = Chat()
        self.chat = self.chat.read(data)
        return self

class chatInvite(TLObject):
    ID = 0xdfc2f58e
    def __init__(self, flags = None, channel = None, broadcast = None, public = None, megagroup = None, title = None, photo = None, participants_count = None, participants = None):
        self.flags = flags
        self.channel = channel
        self.broadcast = broadcast
        self.public = public
        self.megagroup = megagroup
        self.title = title
        self.photo = photo
        self.participants_count = participants_count
        self.participants = participants
    def __str__(self):
        return 'chatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.channel:
            flags |= (1 << 0)
        if self.broadcast:
            flags |= (1 << 1)
        if self.public:
            flags |= (1 << 2)
        if self.megagroup:
            flags |= (1 << 3)
        stream.pack_string(self.title)
        stream.pack_bytes(self.photo.write())
        stream.pack_int32(self.participants_count)
        if self.participants:
            flags |= (1 << 4)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.participants))
            for vec_k_2 in self.participants:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.channel = True
        if flags.check_bit(1):
            self.broadcast = True
        if flags.check_bit(2):
            self.public = True
        if flags.check_bit(3):
            self.megagroup = True
        self.title = data.unpack_string()
        self.photo = Photo()
        self.photo = self.photo.read(data)
        self.participants_count = data.unpack_int32()
        if flags.check_bit(4):
            self.participants = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = User()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.participants.append(elem_of_1_vec)
        return self

class chatInvitePeek(TLObject):
    ID = 0x61695cb0
    def __init__(self, chat = None, expires = None):
        self.chat = chat
        self.expires = expires
    def __str__(self):
        return 'chatInvitePeek'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.chat.write())
        stream.pack_int32(self.expires)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.chat = Chat()
        self.chat = self.chat.read(data)
        self.expires = data.unpack_int32()
        return self

class messages_checkChatInvite(TLObject):
    ID = 0x3eadb1bb
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_checkChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_string()
        return self

class ChatInvite(TLObject):
    DERIVED_OBJECTS = {0x5a686d7c: chatInviteAlready, 0xdfc2f58e: chatInvite, 0x61695cb0: chatInvitePeek, 0x3eadb1bb: messages_checkChatInvite}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputStickerSetEmpty(TLObject):
    ID = 0xffb62b95
    def __init__(self):
        pass
    def __str__(self):
        return 'inputStickerSetEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputStickerSetID(TLObject):
    ID = 0x9de7a269
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputStickerSetID'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputStickerSetShortName(TLObject):
    ID = 0x861cc8a0
    def __init__(self, short_name = None):
        self.short_name = short_name
    def __str__(self):
        return 'inputStickerSetShortName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.short_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.short_name = data.unpack_string()
        return self

class inputStickerSetAnimatedEmoji(TLObject):
    ID = 0x28703c8
    def __init__(self):
        pass
    def __str__(self):
        return 'inputStickerSetAnimatedEmoji'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputStickerSetDice(TLObject):
    ID = 0xe67f520e
    def __init__(self, emoticon = None):
        self.emoticon = emoticon
    def __str__(self):
        return 'inputStickerSetDice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        return self

class inputStickerSetAnimatedEmojiAnimations(TLObject):
    ID = 0xcde3739
    def __init__(self):
        pass
    def __str__(self):
        return 'inputStickerSetAnimatedEmojiAnimations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class InputStickerSet(TLObject):
    DERIVED_OBJECTS = {0xffb62b95: inputStickerSetEmpty, 0x9de7a269: inputStickerSetID, 0x861cc8a0: inputStickerSetShortName, 0x28703c8: inputStickerSetAnimatedEmoji, 0xe67f520e: inputStickerSetDice, 0xcde3739: inputStickerSetAnimatedEmojiAnimations}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stickerSet(TLObject):
    ID = 0xd7df217a
    def __init__(self, flags = None, archived = None, official = None, masks = None, animated = None, installed_date = None, id = None, access_hash = None, title = None, short_name = None, thumbs = None, thumb_dc_id = None, thumb_version = None, count = None, hash = None):
        self.flags = flags
        self.archived = archived
        self.official = official
        self.masks = masks
        self.animated = animated
        self.installed_date = installed_date
        self.id = id
        self.access_hash = access_hash
        self.title = title
        self.short_name = short_name
        self.thumbs = thumbs
        self.thumb_dc_id = thumb_dc_id
        self.thumb_version = thumb_version
        self.count = count
        self.hash = hash
    def __str__(self):
        return 'stickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.archived:
            flags |= (1 << 1)
        if self.official:
            flags |= (1 << 2)
        if self.masks:
            flags |= (1 << 3)
        if self.animated:
            flags |= (1 << 5)
        if self.installed_date:
            flags |= (1 << 0)
            stream.pack_int32(self.installed_date)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.title)
        stream.pack_string(self.short_name)
        if self.thumbs:
            flags |= (1 << 4)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.thumbs))
            for vec_k_2 in self.thumbs:
                stream.pack_bytes(vec_k_2.write())
        if self.thumb_dc_id:
            flags |= (1 << 4)
            stream.pack_int32(self.thumb_dc_id)
        if self.thumb_version:
            flags |= (1 << 4)
            stream.pack_int32(self.thumb_version)
        stream.pack_int32(self.count)
        stream.pack_int32(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.archived = True
        if flags.check_bit(2):
            self.official = True
        if flags.check_bit(3):
            self.masks = True
        if flags.check_bit(5):
            self.animated = True
        if flags.check_bit(0):
            self.installed_date = data.unpack_int32()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.title = data.unpack_string()
        self.short_name = data.unpack_string()
        if flags.check_bit(4):
            self.thumbs = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = PhotoSize()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.thumbs.append(elem_of_1_vec)
        if flags.check_bit(4):
            self.thumb_dc_id = data.unpack_int32()
        if flags.check_bit(4):
            self.thumb_version = data.unpack_int32()
        self.count = data.unpack_int32()
        self.hash = data.unpack_int32()
        return self

class StickerSet(TLObject):
    DERIVED_OBJECTS = {0xd7df217a: stickerSet}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_stickerSet(TLObject):
    ID = 0xb60a24a6
    def __init__(self, set = None, packs = None, documents = None):
        self.set = set
        self.packs = packs
        self.documents = documents
    def __str__(self):
        return 'messages_stickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.set.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.packs))
        for vec_k_2 in self.packs:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.documents))
        for vec_k_3 in self.documents:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.set = StickerSet()
        self.set = self.set.read(data)
        self.packs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerPack()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.packs.append(elem_of_1_vec)
        self.documents = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Document()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.documents.append(elem_of_2_vec)
        return self

class messages_getStickerSet(TLObject):
    ID = 0x2619a90e
    def __init__(self, stickerset = None):
        self.stickerset = stickerset
    def __str__(self):
        return 'messages_getStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        return self

class stickers_createStickerSet(TLObject):
    ID = 0x9021ab67
    def __init__(self, flags = None, masks = None, animated = None, user_id = None, title = None, short_name = None, thumb = None, stickers = None, software = None):
        self.flags = flags
        self.masks = masks
        self.animated = animated
        self.user_id = user_id
        self.title = title
        self.short_name = short_name
        self.thumb = thumb
        self.stickers = stickers
        self.software = software
    def __str__(self):
        return 'stickers_createStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.masks:
            flags |= (1 << 0)
        if self.animated:
            flags |= (1 << 1)
        stream.pack_bytes(self.user_id.write())
        stream.pack_string(self.title)
        stream.pack_string(self.short_name)
        if self.thumb:
            flags |= (1 << 2)
            stream.pack_bytes(self.thumb.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.stickers))
        for vec_k_2 in self.stickers:
            stream.pack_bytes(vec_k_2.write())
        if self.software:
            flags |= (1 << 3)
            stream.pack_string(self.software)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.masks = True
        if flags.check_bit(1):
            self.animated = True
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.title = data.unpack_string()
        self.short_name = data.unpack_string()
        if flags.check_bit(2):
            self.thumb = InputDocument()
            self.thumb = self.thumb.read(data)
        self.stickers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputStickerSetItem()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.stickers.append(elem_of_1_vec)
        if flags.check_bit(3):
            self.software = data.unpack_string()
        return self

class stickers_removeStickerFromSet(TLObject):
    ID = 0xf7760f51
    def __init__(self, sticker = None):
        self.sticker = sticker
    def __str__(self):
        return 'stickers_removeStickerFromSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.sticker.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.sticker = InputDocument()
        self.sticker = self.sticker.read(data)
        return self

class stickers_changeStickerPosition(TLObject):
    ID = 0xffb6d4ca
    def __init__(self, sticker = None, position = None):
        self.sticker = sticker
        self.position = position
    def __str__(self):
        return 'stickers_changeStickerPosition'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.sticker.write())
        stream.pack_int32(self.position)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.sticker = InputDocument()
        self.sticker = self.sticker.read(data)
        self.position = data.unpack_int32()
        return self

class stickers_addStickerToSet(TLObject):
    ID = 0x8653febe
    def __init__(self, stickerset = None, sticker = None):
        self.stickerset = stickerset
        self.sticker = sticker
    def __str__(self):
        return 'stickers_addStickerToSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        stream.pack_bytes(self.sticker.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        self.sticker = InputStickerSetItem()
        self.sticker = self.sticker.read(data)
        return self

class stickers_setStickerSetThumb(TLObject):
    ID = 0x9a364e30
    def __init__(self, stickerset = None, thumb = None):
        self.stickerset = stickerset
        self.thumb = thumb
    def __str__(self):
        return 'stickers_setStickerSetThumb'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        stream.pack_bytes(self.thumb.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        self.thumb = InputDocument()
        self.thumb = self.thumb.read(data)
        return self

class messages_StickerSet(TLObject):
    DERIVED_OBJECTS = {0xb60a24a6: messages_stickerSet, 0x2619a90e: messages_getStickerSet, 0x9021ab67: stickers_createStickerSet, 0xf7760f51: stickers_removeStickerFromSet, 0xffb6d4ca: stickers_changeStickerPosition, 0x8653febe: stickers_addStickerToSet, 0x9a364e30: stickers_setStickerSetThumb}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class botCommand(TLObject):
    ID = 0xc27ac8c7
    def __init__(self, command = None, description = None):
        self.command = command
        self.description = description
    def __str__(self):
        return 'botCommand'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.command)
        stream.pack_string(self.description)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.command = data.unpack_string()
        self.description = data.unpack_string()
        return self

class BotCommand(TLObject):
    DERIVED_OBJECTS = {0xc27ac8c7: botCommand}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class botInfo(TLObject):
    ID = 0x1b74b335
    def __init__(self, user_id = None, description = None, commands = None):
        self.user_id = user_id
        self.description = description
        self.commands = commands
    def __str__(self):
        return 'botInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.description)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.commands))
        for vec_k_2 in self.commands:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.description = data.unpack_string()
        self.commands = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = BotCommand()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.commands.append(elem_of_1_vec)
        return self

class BotInfo(TLObject):
    DERIVED_OBJECTS = {0x1b74b335: botInfo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class keyboardButton(TLObject):
    ID = 0xa2fa4880
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'keyboardButton'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        return self

class keyboardButtonUrl(TLObject):
    ID = 0x258aff05
    def __init__(self, text = None, url = None):
        self.text = text
        self.url = url
    def __str__(self):
        return 'keyboardButtonUrl'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        self.url = data.unpack_string()
        return self

class keyboardButtonCallback(TLObject):
    ID = 0x35bbdb6b
    def __init__(self, flags = None, requires_password = None, text = None, data = None):
        self.flags = flags
        self.requires_password = requires_password
        self.text = text
        self.data = data
    def __str__(self):
        return 'keyboardButtonCallback'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.requires_password:
            flags |= (1 << 0)
        stream.pack_string(self.text)
        stream.pack_string(self.data)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.requires_password = True
        self.text = data.unpack_string()
        self.data = data.unpack_string()
        return self

class keyboardButtonRequestPhone(TLObject):
    ID = 0xb16a6c29
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'keyboardButtonRequestPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        return self

class keyboardButtonRequestGeoLocation(TLObject):
    ID = 0xfc796b3f
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'keyboardButtonRequestGeoLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        return self

class keyboardButtonSwitchInline(TLObject):
    ID = 0x568a748
    def __init__(self, flags = None, same_peer = None, text = None, query = None):
        self.flags = flags
        self.same_peer = same_peer
        self.text = text
        self.query = query
    def __str__(self):
        return 'keyboardButtonSwitchInline'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.same_peer:
            flags |= (1 << 0)
        stream.pack_string(self.text)
        stream.pack_string(self.query)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.same_peer = True
        self.text = data.unpack_string()
        self.query = data.unpack_string()
        return self

class keyboardButtonGame(TLObject):
    ID = 0x50f41ccf
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'keyboardButtonGame'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        return self

class keyboardButtonBuy(TLObject):
    ID = 0xafd93fbb
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'keyboardButtonBuy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        return self

class keyboardButtonUrlAuth(TLObject):
    ID = 0x10b78d29
    def __init__(self, flags = None, text = None, fwd_text = None, url = None, button_id = None):
        self.flags = flags
        self.text = text
        self.fwd_text = fwd_text
        self.url = url
        self.button_id = button_id
    def __str__(self):
        return 'keyboardButtonUrlAuth'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        flags = 0x0
        if self.fwd_text:
            flags |= (1 << 0)
            stream.pack_string(self.fwd_text)
        stream.pack_string(self.url)
        stream.pack_int32(self.button_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.text = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.fwd_text = data.unpack_string()
        self.url = data.unpack_string()
        self.button_id = data.unpack_int32()
        return self

class inputKeyboardButtonUrlAuth(TLObject):
    ID = 0xd02e7fd4
    def __init__(self, flags = None, request_write_access = None, text = None, fwd_text = None, url = None, bot = None):
        self.flags = flags
        self.request_write_access = request_write_access
        self.text = text
        self.fwd_text = fwd_text
        self.url = url
        self.bot = bot
    def __str__(self):
        return 'inputKeyboardButtonUrlAuth'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.request_write_access:
            flags |= (1 << 0)
        stream.pack_string(self.text)
        if self.fwd_text:
            flags |= (1 << 1)
            stream.pack_string(self.fwd_text)
        stream.pack_string(self.url)
        stream.pack_bytes(self.bot.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.request_write_access = True
        self.text = data.unpack_string()
        if flags.check_bit(1):
            self.fwd_text = data.unpack_string()
        self.url = data.unpack_string()
        self.bot = InputUser()
        self.bot = self.bot.read(data)
        return self

class keyboardButtonRequestPoll(TLObject):
    ID = 0xbbc7515d
    def __init__(self, flags = None, quiz = None, text = None):
        self.flags = flags
        self.quiz = quiz
        self.text = text
    def __str__(self):
        return 'keyboardButtonRequestPoll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.quiz:
            flags |= (1 << 0)
            stream.pack_bytes(self.quiz.write())
        stream.pack_string(self.text)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.quiz = Bool()
            self.quiz = self.quiz.read(data)
        self.text = data.unpack_string()
        return self

class KeyboardButton(TLObject):
    DERIVED_OBJECTS = {0xa2fa4880: keyboardButton, 0x258aff05: keyboardButtonUrl, 0x35bbdb6b: keyboardButtonCallback, 0xb16a6c29: keyboardButtonRequestPhone, 0xfc796b3f: keyboardButtonRequestGeoLocation, 0x568a748: keyboardButtonSwitchInline, 0x50f41ccf: keyboardButtonGame, 0xafd93fbb: keyboardButtonBuy, 0x10b78d29: keyboardButtonUrlAuth, 0xd02e7fd4: inputKeyboardButtonUrlAuth, 0xbbc7515d: keyboardButtonRequestPoll}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class keyboardButtonRow(TLObject):
    ID = 0x77608b83
    def __init__(self, buttons = None):
        self.buttons = buttons
    def __str__(self):
        return 'keyboardButtonRow'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.buttons))
        for vec_k_2 in self.buttons:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.buttons = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = KeyboardButton()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.buttons.append(elem_of_1_vec)
        return self

class KeyboardButtonRow(TLObject):
    DERIVED_OBJECTS = {0x77608b83: keyboardButtonRow}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class replyKeyboardHide(TLObject):
    ID = 0xa03e5b85
    def __init__(self, flags = None, selective = None):
        self.flags = flags
        self.selective = selective
    def __str__(self):
        return 'replyKeyboardHide'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.selective:
            flags |= (1 << 2)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.selective = True
        return self

class replyKeyboardForceReply(TLObject):
    ID = 0x86b40b08
    def __init__(self, flags = None, single_use = None, selective = None, placeholder = None):
        self.flags = flags
        self.single_use = single_use
        self.selective = selective
        self.placeholder = placeholder
    def __str__(self):
        return 'replyKeyboardForceReply'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.single_use:
            flags |= (1 << 1)
        if self.selective:
            flags |= (1 << 2)
        if self.placeholder:
            flags |= (1 << 3)
            stream.pack_string(self.placeholder)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.single_use = True
        if flags.check_bit(2):
            self.selective = True
        if flags.check_bit(3):
            self.placeholder = data.unpack_string()
        return self

class replyKeyboardMarkup(TLObject):
    ID = 0x85dd99d1
    def __init__(self, flags = None, resize = None, single_use = None, selective = None, rows = None, placeholder = None):
        self.flags = flags
        self.resize = resize
        self.single_use = single_use
        self.selective = selective
        self.rows = rows
        self.placeholder = placeholder
    def __str__(self):
        return 'replyKeyboardMarkup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.resize:
            flags |= (1 << 0)
        if self.single_use:
            flags |= (1 << 1)
        if self.selective:
            flags |= (1 << 2)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.rows))
        for vec_k_2 in self.rows:
            stream.pack_bytes(vec_k_2.write())
        if self.placeholder:
            flags |= (1 << 3)
            stream.pack_string(self.placeholder)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.resize = True
        if flags.check_bit(1):
            self.single_use = True
        if flags.check_bit(2):
            self.selective = True
        self.rows = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = KeyboardButtonRow()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.rows.append(elem_of_1_vec)
        if flags.check_bit(3):
            self.placeholder = data.unpack_string()
        return self

class replyInlineMarkup(TLObject):
    ID = 0x48a30254
    def __init__(self, rows = None):
        self.rows = rows
    def __str__(self):
        return 'replyInlineMarkup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.rows))
        for vec_k_2 in self.rows:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.rows = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = KeyboardButtonRow()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.rows.append(elem_of_1_vec)
        return self

class ReplyMarkup(TLObject):
    DERIVED_OBJECTS = {0xa03e5b85: replyKeyboardHide, 0x86b40b08: replyKeyboardForceReply, 0x85dd99d1: replyKeyboardMarkup, 0x48a30254: replyInlineMarkup}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageEntityUnknown(TLObject):
    ID = 0xbb92ba95
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityUnknown'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityMention(TLObject):
    ID = 0xfa04579d
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityMention'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityHashtag(TLObject):
    ID = 0x6f635b0d
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityHashtag'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityBotCommand(TLObject):
    ID = 0x6cef8ac7
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityBotCommand'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityUrl(TLObject):
    ID = 0x6ed02538
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityUrl'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityEmail(TLObject):
    ID = 0x64e475c2
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityBold(TLObject):
    ID = 0xbd610bc9
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityBold'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityItalic(TLObject):
    ID = 0x826f8b60
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityItalic'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityCode(TLObject):
    ID = 0x28a20571
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityPre(TLObject):
    ID = 0x73924be0
    def __init__(self, offset = None, length = None, language = None):
        self.offset = offset
        self.length = length
        self.language = language
    def __str__(self):
        return 'messageEntityPre'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        stream.pack_string(self.language)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        self.language = data.unpack_string()
        return self

class messageEntityTextUrl(TLObject):
    ID = 0x76a6d327
    def __init__(self, offset = None, length = None, url = None):
        self.offset = offset
        self.length = length
        self.url = url
    def __str__(self):
        return 'messageEntityTextUrl'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        self.url = data.unpack_string()
        return self

class messageEntityMentionName(TLObject):
    ID = 0xdc7b1140
    def __init__(self, offset = None, length = None, user_id = None):
        self.offset = offset
        self.length = length
        self.user_id = user_id
    def __str__(self):
        return 'messageEntityMentionName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        self.user_id = data.unpack_int64()
        return self

class inputMessageEntityMentionName(TLObject):
    ID = 0x208e68c9
    def __init__(self, offset = None, length = None, user_id = None):
        self.offset = offset
        self.length = length
        self.user_id = user_id
    def __str__(self):
        return 'inputMessageEntityMentionName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class messageEntityPhone(TLObject):
    ID = 0x9b69e34b
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityCashtag(TLObject):
    ID = 0x4c4e743f
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityCashtag'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityUnderline(TLObject):
    ID = 0x9c4e7e8b
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityUnderline'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityStrike(TLObject):
    ID = 0xbf0693d4
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityStrike'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityBlockquote(TLObject):
    ID = 0x20df5d0
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityBlockquote'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class messageEntityBankCard(TLObject):
    ID = 0x761e6af4
    def __init__(self, offset = None, length = None):
        self.offset = offset
        self.length = length
    def __str__(self):
        return 'messageEntityBankCard'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.length = data.unpack_int32()
        return self

class MessageEntity(TLObject):
    DERIVED_OBJECTS = {0xbb92ba95: messageEntityUnknown, 0xfa04579d: messageEntityMention, 0x6f635b0d: messageEntityHashtag, 0x6cef8ac7: messageEntityBotCommand, 0x6ed02538: messageEntityUrl, 0x64e475c2: messageEntityEmail, 0xbd610bc9: messageEntityBold, 0x826f8b60: messageEntityItalic, 0x28a20571: messageEntityCode, 0x73924be0: messageEntityPre, 0x76a6d327: messageEntityTextUrl, 0xdc7b1140: messageEntityMentionName, 0x208e68c9: inputMessageEntityMentionName, 0x9b69e34b: messageEntityPhone, 0x4c4e743f: messageEntityCashtag, 0x9c4e7e8b: messageEntityUnderline, 0xbf0693d4: messageEntityStrike, 0x20df5d0: messageEntityBlockquote, 0x761e6af4: messageEntityBankCard}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputChannelEmpty(TLObject):
    ID = 0xee8c1e86
    def __init__(self):
        pass
    def __str__(self):
        return 'inputChannelEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputChannel(TLObject):
    ID = 0xf35aec28
    def __init__(self, channel_id = None, access_hash = None):
        self.channel_id = channel_id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.channel_id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel_id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputChannelFromMessage(TLObject):
    ID = 0x5b934f9d
    def __init__(self, peer = None, msg_id = None, channel_id = None):
        self.peer = peer
        self.msg_id = msg_id
        self.channel_id = channel_id
    def __str__(self):
        return 'inputChannelFromMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_int64(self.channel_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.channel_id = data.unpack_int64()
        return self

class InputChannel(TLObject):
    DERIVED_OBJECTS = {0xee8c1e86: inputChannelEmpty, 0xf35aec28: inputChannel, 0x5b934f9d: inputChannelFromMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contacts_resolvedPeer(TLObject):
    ID = 0x7f077ad9
    def __init__(self, peer = None, chats = None, users = None):
        self.peer = peer
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'contacts_resolvedPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Chat()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.chats.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class contacts_resolveUsername(TLObject):
    ID = 0xf93ccba3
    def __init__(self, username = None):
        self.username = username
    def __str__(self):
        return 'contacts_resolveUsername'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.username)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.username = data.unpack_string()
        return self

class contacts_ResolvedPeer(TLObject):
    DERIVED_OBJECTS = {0x7f077ad9: contacts_resolvedPeer, 0xf93ccba3: contacts_resolveUsername}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageRange(TLObject):
    ID = 0xae30253
    def __init__(self, min_id = None, max_id = None):
        self.min_id = min_id
        self.max_id = max_id
    def __str__(self):
        return 'messageRange'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.min_id)
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.min_id = data.unpack_int32()
        self.max_id = data.unpack_int32()
        return self

class MessageRange(TLObject):
    DERIVED_OBJECTS = {0xae30253: messageRange}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class updates_channelDifferenceEmpty(TLObject):
    ID = 0x3e11affb
    def __init__(self, flags = None, final = None, pts = None, timeout = None):
        self.flags = flags
        self.final = final
        self.pts = pts
        self.timeout = timeout
    def __str__(self):
        return 'updates_channelDifferenceEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.final:
            flags |= (1 << 0)
        stream.pack_int32(self.pts)
        if self.timeout:
            flags |= (1 << 1)
            stream.pack_int32(self.timeout)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.final = True
        self.pts = data.unpack_int32()
        if flags.check_bit(1):
            self.timeout = data.unpack_int32()
        return self

class updates_channelDifferenceTooLong(TLObject):
    ID = 0xa4bcc6fe
    def __init__(self, flags = None, final = None, timeout = None, dialog = None, messages = None, chats = None, users = None):
        self.flags = flags
        self.final = final
        self.timeout = timeout
        self.dialog = dialog
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'updates_channelDifferenceTooLong'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.final:
            flags |= (1 << 0)
        if self.timeout:
            flags |= (1 << 1)
            stream.pack_int32(self.timeout)
        stream.pack_bytes(self.dialog.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.final = True
        if flags.check_bit(1):
            self.timeout = data.unpack_int32()
        self.dialog = Dialog()
        self.dialog = self.dialog.read(data)
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.messages.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class updates_channelDifference(TLObject):
    ID = 0x2064674e
    def __init__(self, flags = None, final = None, pts = None, timeout = None, new_messages = None, other_updates = None, chats = None, users = None):
        self.flags = flags
        self.final = final
        self.pts = pts
        self.timeout = timeout
        self.new_messages = new_messages
        self.other_updates = other_updates
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'updates_channelDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.final:
            flags |= (1 << 0)
        stream.pack_int32(self.pts)
        if self.timeout:
            flags |= (1 << 1)
            stream.pack_int32(self.timeout)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.new_messages))
        for vec_k_2 in self.new_messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.other_updates))
        for vec_k_3 in self.other_updates:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.final = True
        self.pts = data.unpack_int32()
        if flags.check_bit(1):
            self.timeout = data.unpack_int32()
        self.new_messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.new_messages.append(elem_of_1_vec)
        self.other_updates = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Update()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.other_updates.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        return self

class updates_getChannelDifference(TLObject):
    ID = 0x3173d78
    def __init__(self, flags = None, force = None, channel = None, filter = None, pts = None, limit = None):
        self.flags = flags
        self.force = force
        self.channel = channel
        self.filter = filter
        self.pts = pts
        self.limit = limit
    def __str__(self):
        return 'updates_getChannelDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.force:
            flags |= (1 << 0)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.filter.write())
        stream.pack_int32(self.pts)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.force = True
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.filter = ChannelMessagesFilter()
        self.filter = self.filter.read(data)
        self.pts = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class updates_ChannelDifference(TLObject):
    DERIVED_OBJECTS = {0x3e11affb: updates_channelDifferenceEmpty, 0xa4bcc6fe: updates_channelDifferenceTooLong, 0x2064674e: updates_channelDifference, 0x3173d78: updates_getChannelDifference}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelMessagesFilterEmpty(TLObject):
    ID = 0x94d42ee7
    def __init__(self):
        pass
    def __str__(self):
        return 'channelMessagesFilterEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelMessagesFilter(TLObject):
    ID = 0xcd77d957
    def __init__(self, flags = None, exclude_new_messages = None, ranges = None):
        self.flags = flags
        self.exclude_new_messages = exclude_new_messages
        self.ranges = ranges
    def __str__(self):
        return 'channelMessagesFilter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.exclude_new_messages:
            flags |= (1 << 1)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.ranges))
        for vec_k_2 in self.ranges:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.exclude_new_messages = True
        self.ranges = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageRange()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.ranges.append(elem_of_1_vec)
        return self

class ChannelMessagesFilter(TLObject):
    DERIVED_OBJECTS = {0x94d42ee7: channelMessagesFilterEmpty, 0xcd77d957: channelMessagesFilter}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelParticipant(TLObject):
    ID = 0xc00c07c0
    def __init__(self, user_id = None, date = None):
        self.user_id = user_id
        self.date = date
    def __str__(self):
        return 'channelParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class channelParticipantSelf(TLObject):
    ID = 0x28a8bc67
    def __init__(self, user_id = None, inviter_id = None, date = None):
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.date = date
    def __str__(self):
        return 'channelParticipantSelf'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int64(self.inviter_id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.inviter_id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class channelParticipantCreator(TLObject):
    ID = 0x2fe601d3
    def __init__(self, flags = None, user_id = None, admin_rights = None, rank = None):
        self.flags = flags
        self.user_id = user_id
        self.admin_rights = admin_rights
        self.rank = rank
    def __str__(self):
        return 'channelParticipantCreator'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.admin_rights.write())
        flags = 0x0
        if self.rank:
            flags |= (1 << 0)
            stream.pack_string(self.rank)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.user_id = data.unpack_int64()
        self.admin_rights = ChatAdminRights()
        self.admin_rights = self.admin_rights.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.rank = data.unpack_string()
        return self

class channelParticipantAdmin(TLObject):
    ID = 0x34c3bb53
    def __init__(self, flags = None, can_edit = None, self_ = None, user_id = None, inviter_id = None, promoted_by = None, date = None, admin_rights = None, rank = None):
        self.flags = flags
        self.can_edit = can_edit
        self.self_ = self_
        self.user_id = user_id
        self.inviter_id = inviter_id
        self.promoted_by = promoted_by
        self.date = date
        self.admin_rights = admin_rights
        self.rank = rank
    def __str__(self):
        return 'channelParticipantAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.can_edit:
            flags |= (1 << 0)
        if self.self_:
            flags |= (1 << 1)
        stream.pack_int64(self.user_id)
        if self.inviter_id:
            flags |= (1 << 1)
            stream.pack_int64(self.inviter_id)
        stream.pack_int64(self.promoted_by)
        stream.pack_int32(self.date)
        stream.pack_bytes(self.admin_rights.write())
        if self.rank:
            flags |= (1 << 2)
            stream.pack_string(self.rank)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.can_edit = True
        if flags.check_bit(1):
            self.self_ = True
        self.user_id = data.unpack_int64()
        if flags.check_bit(1):
            self.inviter_id = data.unpack_int64()
        self.promoted_by = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_rights = ChatAdminRights()
        self.admin_rights = self.admin_rights.read(data)
        if flags.check_bit(2):
            self.rank = data.unpack_string()
        return self

class channelParticipantBanned(TLObject):
    ID = 0x6df8014e
    def __init__(self, flags = None, left = None, peer = None, kicked_by = None, date = None, banned_rights = None):
        self.flags = flags
        self.left = left
        self.peer = peer
        self.kicked_by = kicked_by
        self.date = date
        self.banned_rights = banned_rights
    def __str__(self):
        return 'channelParticipantBanned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.left:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int64(self.kicked_by)
        stream.pack_int32(self.date)
        stream.pack_bytes(self.banned_rights.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.left = True
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.kicked_by = data.unpack_int64()
        self.date = data.unpack_int32()
        self.banned_rights = ChatBannedRights()
        self.banned_rights = self.banned_rights.read(data)
        return self

class channelParticipantLeft(TLObject):
    ID = 0x1b03f006
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'channelParticipantLeft'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        return self

class ChannelParticipant(TLObject):
    DERIVED_OBJECTS = {0xc00c07c0: channelParticipant, 0x28a8bc67: channelParticipantSelf, 0x2fe601d3: channelParticipantCreator, 0x34c3bb53: channelParticipantAdmin, 0x6df8014e: channelParticipantBanned, 0x1b03f006: channelParticipantLeft}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelParticipantsRecent(TLObject):
    ID = 0xde3f3c79
    def __init__(self):
        pass
    def __str__(self):
        return 'channelParticipantsRecent'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelParticipantsAdmins(TLObject):
    ID = 0xb4608969
    def __init__(self):
        pass
    def __str__(self):
        return 'channelParticipantsAdmins'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelParticipantsKicked(TLObject):
    ID = 0xa3b54985
    def __init__(self, q = None):
        self.q = q
    def __str__(self):
        return 'channelParticipantsKicked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.q)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.q = data.unpack_string()
        return self

class channelParticipantsBots(TLObject):
    ID = 0xb0d1865b
    def __init__(self):
        pass
    def __str__(self):
        return 'channelParticipantsBots'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelParticipantsBanned(TLObject):
    ID = 0x1427a5e1
    def __init__(self, q = None):
        self.q = q
    def __str__(self):
        return 'channelParticipantsBanned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.q)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.q = data.unpack_string()
        return self

class channelParticipantsSearch(TLObject):
    ID = 0x656ac4b
    def __init__(self, q = None):
        self.q = q
    def __str__(self):
        return 'channelParticipantsSearch'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.q)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.q = data.unpack_string()
        return self

class channelParticipantsContacts(TLObject):
    ID = 0xbb6ae88d
    def __init__(self, q = None):
        self.q = q
    def __str__(self):
        return 'channelParticipantsContacts'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.q)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.q = data.unpack_string()
        return self

class channelParticipantsMentions(TLObject):
    ID = 0xe04b5ceb
    def __init__(self, flags = None, q = None, top_msg_id = None):
        self.flags = flags
        self.q = q
        self.top_msg_id = top_msg_id
    def __str__(self):
        return 'channelParticipantsMentions'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.q:
            flags |= (1 << 0)
            stream.pack_string(self.q)
        if self.top_msg_id:
            flags |= (1 << 1)
            stream.pack_int32(self.top_msg_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.q = data.unpack_string()
        if flags.check_bit(1):
            self.top_msg_id = data.unpack_int32()
        return self

class ChannelParticipantsFilter(TLObject):
    DERIVED_OBJECTS = {0xde3f3c79: channelParticipantsRecent, 0xb4608969: channelParticipantsAdmins, 0xa3b54985: channelParticipantsKicked, 0xb0d1865b: channelParticipantsBots, 0x1427a5e1: channelParticipantsBanned, 0x656ac4b: channelParticipantsSearch, 0xbb6ae88d: channelParticipantsContacts, 0xe04b5ceb: channelParticipantsMentions}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channels_channelParticipants(TLObject):
    ID = 0x9ab0feaf
    def __init__(self, count = None, participants = None, chats = None, users = None):
        self.count = count
        self.participants = participants
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'channels_channelParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.participants))
        for vec_k_2 in self.participants:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.participants = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ChannelParticipant()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.participants.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class channels_channelParticipantsNotModified(TLObject):
    ID = 0xf0173fe9
    def __init__(self):
        pass
    def __str__(self):
        return 'channels_channelParticipantsNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channels_getParticipants(TLObject):
    ID = 0x77ced9d0
    def __init__(self, channel = None, filter = None, offset = None, limit = None, hash = None):
        self.channel = channel
        self.filter = filter
        self.offset = offset
        self.limit = limit
        self.hash = hash
    def __str__(self):
        return 'channels_getParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.filter.write())
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.filter = ChannelParticipantsFilter()
        self.filter = self.filter.read(data)
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class channels_ChannelParticipants(TLObject):
    DERIVED_OBJECTS = {0x9ab0feaf: channels_channelParticipants, 0xf0173fe9: channels_channelParticipantsNotModified, 0x77ced9d0: channels_getParticipants}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channels_channelParticipant(TLObject):
    ID = 0xdfb80317
    def __init__(self, participant = None, chats = None, users = None):
        self.participant = participant
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'channels_channelParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.participant.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.participant = ChannelParticipant()
        self.participant = self.participant.read(data)
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Chat()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.chats.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class channels_getParticipant(TLObject):
    ID = 0xa0ab6cc6
    def __init__(self, channel = None, participant = None):
        self.channel = channel
        self.participant = participant
    def __str__(self):
        return 'channels_getParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_bytes(self.participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.participant = InputPeer()
        self.participant = self.participant.read(data)
        return self

class channels_ChannelParticipant(TLObject):
    DERIVED_OBJECTS = {0xdfb80317: channels_channelParticipant, 0xa0ab6cc6: channels_getParticipant}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_termsOfService(TLObject):
    ID = 0x780a0310
    def __init__(self, flags = None, popup = None, id = None, text = None, entities = None, min_age_confirm = None):
        self.flags = flags
        self.popup = popup
        self.id = id
        self.text = text
        self.entities = entities
        self.min_age_confirm = min_age_confirm
    def __str__(self):
        return 'help_termsOfService'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.popup:
            flags |= (1 << 0)
        stream.pack_bytes(self.id.write())
        stream.pack_string(self.text)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.entities))
        for vec_k_2 in self.entities:
            stream.pack_bytes(vec_k_2.write())
        if self.min_age_confirm:
            flags |= (1 << 1)
            stream.pack_int32(self.min_age_confirm)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.popup = True
        self.id = DataJSON()
        self.id = self.id.read(data)
        self.text = data.unpack_string()
        self.entities = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageEntity()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.entities.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.min_age_confirm = data.unpack_int32()
        return self

class help_TermsOfService(TLObject):
    DERIVED_OBJECTS = {0x780a0310: help_termsOfService}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_savedGifsNotModified(TLObject):
    ID = 0xe8025ca2
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_savedGifsNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_savedGifs(TLObject):
    ID = 0x84a02a0d
    def __init__(self, hash = None, gifs = None):
        self.hash = hash
        self.gifs = gifs
    def __str__(self):
        return 'messages_savedGifs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.gifs))
        for vec_k_2 in self.gifs:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.gifs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Document()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.gifs.append(elem_of_1_vec)
        return self

class messages_getSavedGifs(TLObject):
    ID = 0x5cf09635
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_getSavedGifs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class messages_SavedGifs(TLObject):
    DERIVED_OBJECTS = {0xe8025ca2: messages_savedGifsNotModified, 0x84a02a0d: messages_savedGifs, 0x5cf09635: messages_getSavedGifs}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputBotInlineMessageMediaAuto(TLObject):
    ID = 0x3380c786
    def __init__(self, flags = None, message = None, entities = None, reply_markup = None):
        self.flags = flags
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageMediaAuto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.message)
        flags = 0x0
        if self.entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.message = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class inputBotInlineMessageText(TLObject):
    ID = 0x3dcd7a87
    def __init__(self, flags = None, no_webpage = None, message = None, entities = None, reply_markup = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageText'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 0)
        stream.pack_string(self.message)
        if self.entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.no_webpage = True
        self.message = data.unpack_string()
        if flags.check_bit(1):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class inputBotInlineMessageMediaGeo(TLObject):
    ID = 0x96929a85
    def __init__(self, flags = None, geo_point = None, heading = None, period = None, proximity_notification_radius = None, reply_markup = None):
        self.flags = flags
        self.geo_point = geo_point
        self.heading = heading
        self.period = period
        self.proximity_notification_radius = proximity_notification_radius
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageMediaGeo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo_point.write())
        flags = 0x0
        if self.heading:
            flags |= (1 << 0)
            stream.pack_int32(self.heading)
        if self.period:
            flags |= (1 << 1)
            stream.pack_int32(self.period)
        if self.proximity_notification_radius:
            flags |= (1 << 3)
            stream.pack_int32(self.proximity_notification_radius)
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.heading = data.unpack_int32()
        if flags.check_bit(1):
            self.period = data.unpack_int32()
        if flags.check_bit(3):
            self.proximity_notification_radius = data.unpack_int32()
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class inputBotInlineMessageMediaVenue(TLObject):
    ID = 0x417bbf11
    def __init__(self, flags = None, geo_point = None, title = None, address = None, provider = None, venue_id = None, venue_type = None, reply_markup = None):
        self.flags = flags
        self.geo_point = geo_point
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.venue_type = venue_type
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageMediaVenue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo_point.write())
        stream.pack_string(self.title)
        stream.pack_string(self.address)
        stream.pack_string(self.provider)
        stream.pack_string(self.venue_id)
        stream.pack_string(self.venue_type)
        flags = 0x0
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        self.title = data.unpack_string()
        self.address = data.unpack_string()
        self.provider = data.unpack_string()
        self.venue_id = data.unpack_string()
        self.venue_type = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class inputBotInlineMessageMediaContact(TLObject):
    ID = 0xa6edbffd
    def __init__(self, flags = None, phone_number = None, first_name = None, last_name = None, vcard = None, reply_markup = None):
        self.flags = flags
        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.vcard = vcard
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageMediaContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_string(self.vcard)
        flags = 0x0
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.phone_number = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.vcard = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class inputBotInlineMessageGame(TLObject):
    ID = 0x4b425864
    def __init__(self, flags = None, reply_markup = None):
        self.flags = flags
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageGame'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class inputBotInlineMessageMediaInvoice(TLObject):
    ID = 0xd7e78225
    def __init__(self, flags = None, title = None, description = None, photo = None, invoice = None, payload = None, provider = None, provider_data = None, reply_markup = None):
        self.flags = flags
        self.title = title
        self.description = description
        self.photo = photo
        self.invoice = invoice
        self.payload = payload
        self.provider = provider
        self.provider_data = provider_data
        self.reply_markup = reply_markup
    def __str__(self):
        return 'inputBotInlineMessageMediaInvoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        stream.pack_string(self.description)
        flags = 0x0
        if self.photo:
            flags |= (1 << 0)
            stream.pack_bytes(self.photo.write())
        stream.pack_bytes(self.invoice.write())
        stream.pack_string(self.payload)
        stream.pack_string(self.provider)
        stream.pack_bytes(self.provider_data.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.title = data.unpack_string()
        self.description = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.photo = InputWebDocument()
            self.photo = self.photo.read(data)
        self.invoice = Invoice()
        self.invoice = self.invoice.read(data)
        self.payload = data.unpack_string()
        self.provider = data.unpack_string()
        self.provider_data = DataJSON()
        self.provider_data = self.provider_data.read(data)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class InputBotInlineMessage(TLObject):
    DERIVED_OBJECTS = {0x3380c786: inputBotInlineMessageMediaAuto, 0x3dcd7a87: inputBotInlineMessageText, 0x96929a85: inputBotInlineMessageMediaGeo, 0x417bbf11: inputBotInlineMessageMediaVenue, 0xa6edbffd: inputBotInlineMessageMediaContact, 0x4b425864: inputBotInlineMessageGame, 0xd7e78225: inputBotInlineMessageMediaInvoice}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputBotInlineResult(TLObject):
    ID = 0x88bf9319
    def __init__(self, flags = None, id = None, type = None, title = None, description = None, url = None, thumb = None, content = None, send_message = None):
        self.flags = flags
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.url = url
        self.thumb = thumb
        self.content = content
        self.send_message = send_message
    def __str__(self):
        return 'inputBotInlineResult'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.type)
        flags = 0x0
        if self.title:
            flags |= (1 << 1)
            stream.pack_string(self.title)
        if self.description:
            flags |= (1 << 2)
            stream.pack_string(self.description)
        if self.url:
            flags |= (1 << 3)
            stream.pack_string(self.url)
        if self.thumb:
            flags |= (1 << 4)
            stream.pack_bytes(self.thumb.write())
        if self.content:
            flags |= (1 << 5)
            stream.pack_bytes(self.content.write())
        stream.pack_bytes(self.send_message.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_string()
        self.type = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.title = data.unpack_string()
        if flags.check_bit(2):
            self.description = data.unpack_string()
        if flags.check_bit(3):
            self.url = data.unpack_string()
        if flags.check_bit(4):
            self.thumb = InputWebDocument()
            self.thumb = self.thumb.read(data)
        if flags.check_bit(5):
            self.content = InputWebDocument()
            self.content = self.content.read(data)
        self.send_message = InputBotInlineMessage()
        self.send_message = self.send_message.read(data)
        return self

class inputBotInlineResultPhoto(TLObject):
    ID = 0xa8d864a7
    def __init__(self, id = None, type = None, photo = None, send_message = None):
        self.id = id
        self.type = type
        self.photo = photo
        self.send_message = send_message
    def __str__(self):
        return 'inputBotInlineResultPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.type)
        stream.pack_bytes(self.photo.write())
        stream.pack_bytes(self.send_message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_string()
        self.type = data.unpack_string()
        self.photo = InputPhoto()
        self.photo = self.photo.read(data)
        self.send_message = InputBotInlineMessage()
        self.send_message = self.send_message.read(data)
        return self

class inputBotInlineResultDocument(TLObject):
    ID = 0xfff8fdc4
    def __init__(self, flags = None, id = None, type = None, title = None, description = None, document = None, send_message = None):
        self.flags = flags
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.document = document
        self.send_message = send_message
    def __str__(self):
        return 'inputBotInlineResultDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.type)
        flags = 0x0
        if self.title:
            flags |= (1 << 1)
            stream.pack_string(self.title)
        if self.description:
            flags |= (1 << 2)
            stream.pack_string(self.description)
        stream.pack_bytes(self.document.write())
        stream.pack_bytes(self.send_message.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_string()
        self.type = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.title = data.unpack_string()
        if flags.check_bit(2):
            self.description = data.unpack_string()
        self.document = InputDocument()
        self.document = self.document.read(data)
        self.send_message = InputBotInlineMessage()
        self.send_message = self.send_message.read(data)
        return self

class inputBotInlineResultGame(TLObject):
    ID = 0x4fa417f2
    def __init__(self, id = None, short_name = None, send_message = None):
        self.id = id
        self.short_name = short_name
        self.send_message = send_message
    def __str__(self):
        return 'inputBotInlineResultGame'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.short_name)
        stream.pack_bytes(self.send_message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_string()
        self.short_name = data.unpack_string()
        self.send_message = InputBotInlineMessage()
        self.send_message = self.send_message.read(data)
        return self

class InputBotInlineResult(TLObject):
    DERIVED_OBJECTS = {0x88bf9319: inputBotInlineResult, 0xa8d864a7: inputBotInlineResultPhoto, 0xfff8fdc4: inputBotInlineResultDocument, 0x4fa417f2: inputBotInlineResultGame}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class botInlineMessageMediaAuto(TLObject):
    ID = 0x764cf810
    def __init__(self, flags = None, message = None, entities = None, reply_markup = None):
        self.flags = flags
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup
    def __str__(self):
        return 'botInlineMessageMediaAuto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.message)
        flags = 0x0
        if self.entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.message = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class botInlineMessageText(TLObject):
    ID = 0x8c7f65e2
    def __init__(self, flags = None, no_webpage = None, message = None, entities = None, reply_markup = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.message = message
        self.entities = entities
        self.reply_markup = reply_markup
    def __str__(self):
        return 'botInlineMessageText'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 0)
        stream.pack_string(self.message)
        if self.entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.no_webpage = True
        self.message = data.unpack_string()
        if flags.check_bit(1):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class botInlineMessageMediaGeo(TLObject):
    ID = 0x51846fd
    def __init__(self, flags = None, geo = None, heading = None, period = None, proximity_notification_radius = None, reply_markup = None):
        self.flags = flags
        self.geo = geo
        self.heading = heading
        self.period = period
        self.proximity_notification_radius = proximity_notification_radius
        self.reply_markup = reply_markup
    def __str__(self):
        return 'botInlineMessageMediaGeo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo.write())
        flags = 0x0
        if self.heading:
            flags |= (1 << 0)
            stream.pack_int32(self.heading)
        if self.period:
            flags |= (1 << 1)
            stream.pack_int32(self.period)
        if self.proximity_notification_radius:
            flags |= (1 << 3)
            stream.pack_int32(self.proximity_notification_radius)
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.geo = GeoPoint()
        self.geo = self.geo.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.heading = data.unpack_int32()
        if flags.check_bit(1):
            self.period = data.unpack_int32()
        if flags.check_bit(3):
            self.proximity_notification_radius = data.unpack_int32()
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class botInlineMessageMediaVenue(TLObject):
    ID = 0x8a86659c
    def __init__(self, flags = None, geo = None, title = None, address = None, provider = None, venue_id = None, venue_type = None, reply_markup = None):
        self.flags = flags
        self.geo = geo
        self.title = title
        self.address = address
        self.provider = provider
        self.venue_id = venue_id
        self.venue_type = venue_type
        self.reply_markup = reply_markup
    def __str__(self):
        return 'botInlineMessageMediaVenue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo.write())
        stream.pack_string(self.title)
        stream.pack_string(self.address)
        stream.pack_string(self.provider)
        stream.pack_string(self.venue_id)
        stream.pack_string(self.venue_type)
        flags = 0x0
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.geo = GeoPoint()
        self.geo = self.geo.read(data)
        self.title = data.unpack_string()
        self.address = data.unpack_string()
        self.provider = data.unpack_string()
        self.venue_id = data.unpack_string()
        self.venue_type = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class botInlineMessageMediaContact(TLObject):
    ID = 0x18d1cdc2
    def __init__(self, flags = None, phone_number = None, first_name = None, last_name = None, vcard = None, reply_markup = None):
        self.flags = flags
        self.phone_number = phone_number
        self.first_name = first_name
        self.last_name = last_name
        self.vcard = vcard
        self.reply_markup = reply_markup
    def __str__(self):
        return 'botInlineMessageMediaContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone_number)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_string(self.vcard)
        flags = 0x0
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.phone_number = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.vcard = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class botInlineMessageMediaInvoice(TLObject):
    ID = 0x354a9b09
    def __init__(self, flags = None, shipping_address_requested = None, test = None, title = None, description = None, photo = None, currency = None, total_amount = None, reply_markup = None):
        self.flags = flags
        self.shipping_address_requested = shipping_address_requested
        self.test = test
        self.title = title
        self.description = description
        self.photo = photo
        self.currency = currency
        self.total_amount = total_amount
        self.reply_markup = reply_markup
    def __str__(self):
        return 'botInlineMessageMediaInvoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.shipping_address_requested:
            flags |= (1 << 1)
        if self.test:
            flags |= (1 << 3)
        stream.pack_string(self.title)
        stream.pack_string(self.description)
        if self.photo:
            flags |= (1 << 0)
            stream.pack_bytes(self.photo.write())
        stream.pack_string(self.currency)
        stream.pack_int64(self.total_amount)
        if self.reply_markup:
            flags |= (1 << 2)
            stream.pack_bytes(self.reply_markup.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.shipping_address_requested = True
        if flags.check_bit(3):
            self.test = True
        self.title = data.unpack_string()
        self.description = data.unpack_string()
        if flags.check_bit(0):
            self.photo = WebDocument()
            self.photo = self.photo.read(data)
        self.currency = data.unpack_string()
        self.total_amount = data.unpack_int64()
        if flags.check_bit(2):
            self.reply_markup = ReplyMarkup()
            self.reply_markup = self.reply_markup.read(data)
        return self

class BotInlineMessage(TLObject):
    DERIVED_OBJECTS = {0x764cf810: botInlineMessageMediaAuto, 0x8c7f65e2: botInlineMessageText, 0x51846fd: botInlineMessageMediaGeo, 0x8a86659c: botInlineMessageMediaVenue, 0x18d1cdc2: botInlineMessageMediaContact, 0x354a9b09: botInlineMessageMediaInvoice}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class botInlineResult(TLObject):
    ID = 0x11965f3a
    def __init__(self, flags = None, id = None, type = None, title = None, description = None, url = None, thumb = None, content = None, send_message = None):
        self.flags = flags
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.url = url
        self.thumb = thumb
        self.content = content
        self.send_message = send_message
    def __str__(self):
        return 'botInlineResult'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.type)
        flags = 0x0
        if self.title:
            flags |= (1 << 1)
            stream.pack_string(self.title)
        if self.description:
            flags |= (1 << 2)
            stream.pack_string(self.description)
        if self.url:
            flags |= (1 << 3)
            stream.pack_string(self.url)
        if self.thumb:
            flags |= (1 << 4)
            stream.pack_bytes(self.thumb.write())
        if self.content:
            flags |= (1 << 5)
            stream.pack_bytes(self.content.write())
        stream.pack_bytes(self.send_message.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_string()
        self.type = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.title = data.unpack_string()
        if flags.check_bit(2):
            self.description = data.unpack_string()
        if flags.check_bit(3):
            self.url = data.unpack_string()
        if flags.check_bit(4):
            self.thumb = WebDocument()
            self.thumb = self.thumb.read(data)
        if flags.check_bit(5):
            self.content = WebDocument()
            self.content = self.content.read(data)
        self.send_message = BotInlineMessage()
        self.send_message = self.send_message.read(data)
        return self

class botInlineMediaResult(TLObject):
    ID = 0x17db940b
    def __init__(self, flags = None, id = None, type = None, photo = None, document = None, title = None, description = None, send_message = None):
        self.flags = flags
        self.id = id
        self.type = type
        self.photo = photo
        self.document = document
        self.title = title
        self.description = description
        self.send_message = send_message
    def __str__(self):
        return 'botInlineMediaResult'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.type)
        flags = 0x0
        if self.photo:
            flags |= (1 << 0)
            stream.pack_bytes(self.photo.write())
        if self.document:
            flags |= (1 << 1)
            stream.pack_bytes(self.document.write())
        if self.title:
            flags |= (1 << 2)
            stream.pack_string(self.title)
        if self.description:
            flags |= (1 << 3)
            stream.pack_string(self.description)
        stream.pack_bytes(self.send_message.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_string()
        self.type = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.photo = Photo()
            self.photo = self.photo.read(data)
        if flags.check_bit(1):
            self.document = Document()
            self.document = self.document.read(data)
        if flags.check_bit(2):
            self.title = data.unpack_string()
        if flags.check_bit(3):
            self.description = data.unpack_string()
        self.send_message = BotInlineMessage()
        self.send_message = self.send_message.read(data)
        return self

class BotInlineResult(TLObject):
    DERIVED_OBJECTS = {0x11965f3a: botInlineResult, 0x17db940b: botInlineMediaResult}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_botResults(TLObject):
    ID = 0x947ca848
    def __init__(self, flags = None, gallery = None, query_id = None, next_offset = None, switch_pm = None, results = None, cache_time = None, users = None):
        self.flags = flags
        self.gallery = gallery
        self.query_id = query_id
        self.next_offset = next_offset
        self.switch_pm = switch_pm
        self.results = results
        self.cache_time = cache_time
        self.users = users
    def __str__(self):
        return 'messages_botResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.gallery:
            flags |= (1 << 0)
        stream.pack_int64(self.query_id)
        if self.next_offset:
            flags |= (1 << 1)
            stream.pack_string(self.next_offset)
        if self.switch_pm:
            flags |= (1 << 2)
            stream.pack_bytes(self.switch_pm.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.results))
        for vec_k_2 in self.results:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.cache_time)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.gallery = True
        self.query_id = data.unpack_int64()
        if flags.check_bit(1):
            self.next_offset = data.unpack_string()
        if flags.check_bit(2):
            self.switch_pm = InlineBotSwitchPM()
            self.switch_pm = self.switch_pm.read(data)
        self.results = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = BotInlineResult()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.results.append(elem_of_1_vec)
        self.cache_time = data.unpack_int32()
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class messages_getInlineBotResults(TLObject):
    ID = 0x514e999d
    def __init__(self, flags = None, bot = None, peer = None, geo_point = None, query = None, offset = None):
        self.flags = flags
        self.bot = bot
        self.peer = peer
        self.geo_point = geo_point
        self.query = query
        self.offset = offset
    def __str__(self):
        return 'messages_getInlineBotResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.bot.write())
        stream.pack_bytes(self.peer.write())
        flags = 0x0
        if self.geo_point:
            flags |= (1 << 0)
            stream.pack_bytes(self.geo_point.write())
        stream.pack_string(self.query)
        stream.pack_string(self.offset)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.bot = InputUser()
        self.bot = self.bot.read(data)
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.geo_point = InputGeoPoint()
            self.geo_point = self.geo_point.read(data)
        self.query = data.unpack_string()
        self.offset = data.unpack_string()
        return self

class messages_BotResults(TLObject):
    DERIVED_OBJECTS = {0x947ca848: messages_botResults, 0x514e999d: messages_getInlineBotResults}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class exportedMessageLink(TLObject):
    ID = 0x5dab1af4
    def __init__(self, link = None, html = None):
        self.link = link
        self.html = html
    def __str__(self):
        return 'exportedMessageLink'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.link)
        stream.pack_string(self.html)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.link = data.unpack_string()
        self.html = data.unpack_string()
        return self

class channels_exportMessageLink(TLObject):
    ID = 0xe63fadeb
    def __init__(self, flags = None, grouped = None, thread = None, channel = None, id = None):
        self.flags = flags
        self.grouped = grouped
        self.thread = thread
        self.channel = channel
        self.id = id
    def __str__(self):
        return 'channels_exportMessageLink'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.grouped:
            flags |= (1 << 0)
        if self.thread:
            flags |= (1 << 1)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(self.id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.grouped = True
        if flags.check_bit(1):
            self.thread = True
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.id = data.unpack_int32()
        return self

class ExportedMessageLink(TLObject):
    DERIVED_OBJECTS = {0x5dab1af4: exportedMessageLink, 0xe63fadeb: channels_exportMessageLink}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageFwdHeader(TLObject):
    ID = 0x5f777dce
    def __init__(self, flags = None, imported = None, from_id = None, from_name = None, date = None, channel_post = None, post_author = None, saved_from_peer = None, saved_from_msg_id = None, psa_type = None):
        self.flags = flags
        self.imported = imported
        self.from_id = from_id
        self.from_name = from_name
        self.date = date
        self.channel_post = channel_post
        self.post_author = post_author
        self.saved_from_peer = saved_from_peer
        self.saved_from_msg_id = saved_from_msg_id
        self.psa_type = psa_type
    def __str__(self):
        return 'messageFwdHeader'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.imported:
            flags |= (1 << 7)
        if self.from_id:
            flags |= (1 << 0)
            stream.pack_bytes(self.from_id.write())
        if self.from_name:
            flags |= (1 << 5)
            stream.pack_string(self.from_name)
        stream.pack_int32(self.date)
        if self.channel_post:
            flags |= (1 << 2)
            stream.pack_int32(self.channel_post)
        if self.post_author:
            flags |= (1 << 3)
            stream.pack_string(self.post_author)
        if self.saved_from_peer:
            flags |= (1 << 4)
            stream.pack_bytes(self.saved_from_peer.write())
        if self.saved_from_msg_id:
            flags |= (1 << 4)
            stream.pack_int32(self.saved_from_msg_id)
        if self.psa_type:
            flags |= (1 << 6)
            stream.pack_string(self.psa_type)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(7):
            self.imported = True
        if flags.check_bit(0):
            self.from_id = Peer()
            self.from_id = self.from_id.read(data)
        if flags.check_bit(5):
            self.from_name = data.unpack_string()
        self.date = data.unpack_int32()
        if flags.check_bit(2):
            self.channel_post = data.unpack_int32()
        if flags.check_bit(3):
            self.post_author = data.unpack_string()
        if flags.check_bit(4):
            self.saved_from_peer = Peer()
            self.saved_from_peer = self.saved_from_peer.read(data)
        if flags.check_bit(4):
            self.saved_from_msg_id = data.unpack_int32()
        if flags.check_bit(6):
            self.psa_type = data.unpack_string()
        return self

class MessageFwdHeader(TLObject):
    DERIVED_OBJECTS = {0x5f777dce: messageFwdHeader}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_codeTypeSms(TLObject):
    ID = 0x72a3158c
    def __init__(self):
        pass
    def __str__(self):
        return 'auth_codeTypeSms'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_codeTypeCall(TLObject):
    ID = 0x741cd3e3
    def __init__(self):
        pass
    def __str__(self):
        return 'auth_codeTypeCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_codeTypeFlashCall(TLObject):
    ID = 0x226ccefb
    def __init__(self):
        pass
    def __str__(self):
        return 'auth_codeTypeFlashCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class auth_CodeType(TLObject):
    DERIVED_OBJECTS = {0x72a3158c: auth_codeTypeSms, 0x741cd3e3: auth_codeTypeCall, 0x226ccefb: auth_codeTypeFlashCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_sentCodeTypeApp(TLObject):
    ID = 0x3dbb5986
    def __init__(self, length = None):
        self.length = length
    def __str__(self):
        return 'auth_sentCodeTypeApp'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.length = data.unpack_int32()
        return self

class auth_sentCodeTypeSms(TLObject):
    ID = 0xc000bba2
    def __init__(self, length = None):
        self.length = length
    def __str__(self):
        return 'auth_sentCodeTypeSms'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.length = data.unpack_int32()
        return self

class auth_sentCodeTypeCall(TLObject):
    ID = 0x5353e5a7
    def __init__(self, length = None):
        self.length = length
    def __str__(self):
        return 'auth_sentCodeTypeCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.length = data.unpack_int32()
        return self

class auth_sentCodeTypeFlashCall(TLObject):
    ID = 0xab03c6d9
    def __init__(self, pattern = None):
        self.pattern = pattern
    def __str__(self):
        return 'auth_sentCodeTypeFlashCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.pattern)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pattern = data.unpack_string()
        return self

class auth_SentCodeType(TLObject):
    DERIVED_OBJECTS = {0x3dbb5986: auth_sentCodeTypeApp, 0xc000bba2: auth_sentCodeTypeSms, 0x5353e5a7: auth_sentCodeTypeCall, 0xab03c6d9: auth_sentCodeTypeFlashCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_botCallbackAnswer(TLObject):
    ID = 0x36585ea4
    def __init__(self, flags = None, alert = None, has_url = None, native_ui = None, message = None, url = None, cache_time = None):
        self.flags = flags
        self.alert = alert
        self.has_url = has_url
        self.native_ui = native_ui
        self.message = message
        self.url = url
        self.cache_time = cache_time
    def __str__(self):
        return 'messages_botCallbackAnswer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.alert:
            flags |= (1 << 1)
        if self.has_url:
            flags |= (1 << 3)
        if self.native_ui:
            flags |= (1 << 4)
        if self.message:
            flags |= (1 << 0)
            stream.pack_string(self.message)
        if self.url:
            flags |= (1 << 2)
            stream.pack_string(self.url)
        stream.pack_int32(self.cache_time)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.alert = True
        if flags.check_bit(3):
            self.has_url = True
        if flags.check_bit(4):
            self.native_ui = True
        if flags.check_bit(0):
            self.message = data.unpack_string()
        if flags.check_bit(2):
            self.url = data.unpack_string()
        self.cache_time = data.unpack_int32()
        return self

class messages_getBotCallbackAnswer(TLObject):
    ID = 0x9342ca07
    def __init__(self, flags = None, game = None, peer = None, msg_id = None, data = None, password = None):
        self.flags = flags
        self.game = game
        self.peer = peer
        self.msg_id = msg_id
        self.data = data
        self.password = password
    def __str__(self):
        return 'messages_getBotCallbackAnswer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.game:
            flags |= (1 << 1)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        if self.data:
            flags |= (1 << 0)
            stream.pack_string(self.data)
        if self.password:
            flags |= (1 << 2)
            stream.pack_bytes(self.password.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.game = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        if flags.check_bit(0):
            self.data = data.unpack_string()
        if flags.check_bit(2):
            self.password = InputCheckPasswordSRP()
            self.password = self.password.read(data)
        return self

class messages_BotCallbackAnswer(TLObject):
    DERIVED_OBJECTS = {0x36585ea4: messages_botCallbackAnswer, 0x9342ca07: messages_getBotCallbackAnswer}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_messageEditData(TLObject):
    ID = 0x26b5dde6
    def __init__(self, flags = None, caption = None):
        self.flags = flags
        self.caption = caption
    def __str__(self):
        return 'messages_messageEditData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.caption:
            flags |= (1 << 0)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.caption = True
        return self

class messages_getMessageEditData(TLObject):
    ID = 0xfda68d36
    def __init__(self, peer = None, id = None):
        self.peer = peer
        self.id = id
    def __str__(self):
        return 'messages_getMessageEditData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = data.unpack_int32()
        return self

class messages_MessageEditData(TLObject):
    DERIVED_OBJECTS = {0x26b5dde6: messages_messageEditData, 0xfda68d36: messages_getMessageEditData}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputBotInlineMessageID(TLObject):
    ID = 0x890c3d89
    def __init__(self, dc_id = None, id = None, access_hash = None):
        self.dc_id = dc_id
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputBotInlineMessageID'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.dc_id)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_id = data.unpack_int32()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputBotInlineMessageID64(TLObject):
    ID = 0xb6d915d7
    def __init__(self, dc_id = None, owner_id = None, id = None, access_hash = None):
        self.dc_id = dc_id
        self.owner_id = owner_id
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputBotInlineMessageID64'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.dc_id)
        stream.pack_int64(self.owner_id)
        stream.pack_int32(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_id = data.unpack_int32()
        self.owner_id = data.unpack_int64()
        self.id = data.unpack_int32()
        self.access_hash = data.unpack_int64()
        return self

class InputBotInlineMessageID(TLObject):
    DERIVED_OBJECTS = {0x890c3d89: inputBotInlineMessageID, 0xb6d915d7: inputBotInlineMessageID64}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inlineBotSwitchPM(TLObject):
    ID = 0x3c20629f
    def __init__(self, text = None, start_param = None):
        self.text = text
        self.start_param = start_param
    def __str__(self):
        return 'inlineBotSwitchPM'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        stream.pack_string(self.start_param)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        self.start_param = data.unpack_string()
        return self

class InlineBotSwitchPM(TLObject):
    DERIVED_OBJECTS = {0x3c20629f: inlineBotSwitchPM}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_peerDialogs(TLObject):
    ID = 0x3371c354
    def __init__(self, dialogs = None, messages = None, chats = None, users = None, state = None):
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
        self.state = state
    def __str__(self):
        return 'messages_peerDialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dialogs))
        for vec_k_2 in self.dialogs:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_3 in self.messages:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_4 in self.chats:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        stream.pack_bytes(self.state.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dialogs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Dialog()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.dialogs.append(elem_of_1_vec)
        self.messages = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Message()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.messages.append(elem_of_2_vec)
        self.chats = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Chat()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.chats.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        self.state = updates_State()
        self.state = self.state.read(data)
        return self

class messages_getPeerDialogs(TLObject):
    ID = 0xe470bcfd
    def __init__(self, peers = None):
        self.peers = peers
    def __str__(self):
        return 'messages_getPeerDialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.peers))
        for vec_k_2 in self.peers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputDialogPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.peers.append(elem_of_1_vec)
        return self

class messages_getPinnedDialogs(TLObject):
    ID = 0xd6b94df2
    def __init__(self, folder_id = None):
        self.folder_id = folder_id
    def __str__(self):
        return 'messages_getPinnedDialogs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.folder_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.folder_id = data.unpack_int32()
        return self

class messages_PeerDialogs(TLObject):
    DERIVED_OBJECTS = {0x3371c354: messages_peerDialogs, 0xe470bcfd: messages_getPeerDialogs, 0xd6b94df2: messages_getPinnedDialogs}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class topPeer(TLObject):
    ID = 0xedcdc05b
    def __init__(self, peer = None, rating = None):
        self.peer = peer
        self.rating = rating
    def __str__(self):
        return 'topPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_double(self.rating)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.rating = data.unpack_double()
        return self

class TopPeer(TLObject):
    DERIVED_OBJECTS = {0xedcdc05b: topPeer}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class topPeerCategoryBotsPM(TLObject):
    ID = 0xab661b5b
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryBotsPM'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryBotsInline(TLObject):
    ID = 0x148677e2
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryBotsInline'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryCorrespondents(TLObject):
    ID = 0x637b7ed
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryCorrespondents'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryGroups(TLObject):
    ID = 0xbd17a14a
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryGroups'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryChannels(TLObject):
    ID = 0x161d9628
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryChannels'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryPhoneCalls(TLObject):
    ID = 0x1e76a78c
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryPhoneCalls'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryForwardUsers(TLObject):
    ID = 0xa8406ca9
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryForwardUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class topPeerCategoryForwardChats(TLObject):
    ID = 0xfbeec0f0
    def __init__(self):
        pass
    def __str__(self):
        return 'topPeerCategoryForwardChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class TopPeerCategory(TLObject):
    DERIVED_OBJECTS = {0xab661b5b: topPeerCategoryBotsPM, 0x148677e2: topPeerCategoryBotsInline, 0x637b7ed: topPeerCategoryCorrespondents, 0xbd17a14a: topPeerCategoryGroups, 0x161d9628: topPeerCategoryChannels, 0x1e76a78c: topPeerCategoryPhoneCalls, 0xa8406ca9: topPeerCategoryForwardUsers, 0xfbeec0f0: topPeerCategoryForwardChats}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class topPeerCategoryPeers(TLObject):
    ID = 0xfb834291
    def __init__(self, category = None, count = None, peers = None):
        self.category = category
        self.count = count
        self.peers = peers
    def __str__(self):
        return 'topPeerCategoryPeers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.category.write())
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.peers))
        for vec_k_2 in self.peers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.category = TopPeerCategory()
        self.category = self.category.read(data)
        self.count = data.unpack_int32()
        self.peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = TopPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.peers.append(elem_of_1_vec)
        return self

class TopPeerCategoryPeers(TLObject):
    DERIVED_OBJECTS = {0xfb834291: topPeerCategoryPeers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class contacts_topPeersNotModified(TLObject):
    ID = 0xde266ef5
    def __init__(self):
        pass
    def __str__(self):
        return 'contacts_topPeersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class contacts_topPeers(TLObject):
    ID = 0x70b772a8
    def __init__(self, categories = None, chats = None, users = None):
        self.categories = categories
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'contacts_topPeers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.categories))
        for vec_k_2 in self.categories:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.categories = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = TopPeerCategoryPeers()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.categories.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class contacts_topPeersDisabled(TLObject):
    ID = 0xb52c939d
    def __init__(self):
        pass
    def __str__(self):
        return 'contacts_topPeersDisabled'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class contacts_getTopPeers(TLObject):
    ID = 0x973478b6
    def __init__(self, flags = None, correspondents = None, bots_pm = None, bots_inline = None, phone_calls = None, forward_users = None, forward_chats = None, groups = None, channels = None, offset = None, limit = None, hash = None):
        self.flags = flags
        self.correspondents = correspondents
        self.bots_pm = bots_pm
        self.bots_inline = bots_inline
        self.phone_calls = phone_calls
        self.forward_users = forward_users
        self.forward_chats = forward_chats
        self.groups = groups
        self.channels = channels
        self.offset = offset
        self.limit = limit
        self.hash = hash
    def __str__(self):
        return 'contacts_getTopPeers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.correspondents:
            flags |= (1 << 0)
        if self.bots_pm:
            flags |= (1 << 1)
        if self.bots_inline:
            flags |= (1 << 2)
        if self.phone_calls:
            flags |= (1 << 3)
        if self.forward_users:
            flags |= (1 << 4)
        if self.forward_chats:
            flags |= (1 << 5)
        if self.groups:
            flags |= (1 << 10)
        if self.channels:
            flags |= (1 << 15)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.correspondents = True
        if flags.check_bit(1):
            self.bots_pm = True
        if flags.check_bit(2):
            self.bots_inline = True
        if flags.check_bit(3):
            self.phone_calls = True
        if flags.check_bit(4):
            self.forward_users = True
        if flags.check_bit(5):
            self.forward_chats = True
        if flags.check_bit(10):
            self.groups = True
        if flags.check_bit(15):
            self.channels = True
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class contacts_TopPeers(TLObject):
    DERIVED_OBJECTS = {0xde266ef5: contacts_topPeersNotModified, 0x70b772a8: contacts_topPeers, 0xb52c939d: contacts_topPeersDisabled, 0x973478b6: contacts_getTopPeers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class draftMessageEmpty(TLObject):
    ID = 0x1b0c841a
    def __init__(self, flags = None, date = None):
        self.flags = flags
        self.date = date
    def __str__(self):
        return 'draftMessageEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.date:
            flags |= (1 << 0)
            stream.pack_int32(self.date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.date = data.unpack_int32()
        return self

class draftMessage(TLObject):
    ID = 0xfd8e711f
    def __init__(self, flags = None, no_webpage = None, reply_to_msg_id = None, message = None, entities = None, date = None):
        self.flags = flags
        self.no_webpage = no_webpage
        self.reply_to_msg_id = reply_to_msg_id
        self.message = message
        self.entities = entities
        self.date = date
    def __str__(self):
        return 'draftMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.no_webpage:
            flags |= (1 << 1)
        if self.reply_to_msg_id:
            flags |= (1 << 0)
            stream.pack_int32(self.reply_to_msg_id)
        stream.pack_string(self.message)
        if self.entities:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.no_webpage = True
        if flags.check_bit(0):
            self.reply_to_msg_id = data.unpack_int32()
        self.message = data.unpack_string()
        if flags.check_bit(3):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        self.date = data.unpack_int32()
        return self

class DraftMessage(TLObject):
    DERIVED_OBJECTS = {0x1b0c841a: draftMessageEmpty, 0xfd8e711f: draftMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_featuredStickersNotModified(TLObject):
    ID = 0xc6dc0c66
    def __init__(self, count = None):
        self.count = count
    def __str__(self):
        return 'messages_featuredStickersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        return self

class messages_featuredStickers(TLObject):
    ID = 0x84c02310
    def __init__(self, hash = None, count = None, sets = None, unread = None):
        self.hash = hash
        self.count = count
        self.sets = sets
        self.unread = unread
    def __str__(self):
        return 'messages_featuredStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sets))
        for vec_k_2 in self.sets:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.unread))
        for vec_k_3 in self.unread:
            stream.pack_int64(vec_k_3)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.count = data.unpack_int32()
        self.sets = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerSetCovered()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.sets.append(elem_of_1_vec)
        self.unread = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            self.unread.append(data.unpack_int64())
        return self

class messages_getFeaturedStickers(TLObject):
    ID = 0x64780b14
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_getFeaturedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class messages_getOldFeaturedStickers(TLObject):
    ID = 0x7ed094a1
    def __init__(self, offset = None, limit = None, hash = None):
        self.offset = offset
        self.limit = limit
        self.hash = hash
    def __str__(self):
        return 'messages_getOldFeaturedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.hash = data.unpack_int64()
        return self

class messages_FeaturedStickers(TLObject):
    DERIVED_OBJECTS = {0xc6dc0c66: messages_featuredStickersNotModified, 0x84c02310: messages_featuredStickers, 0x64780b14: messages_getFeaturedStickers, 0x7ed094a1: messages_getOldFeaturedStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_recentStickersNotModified(TLObject):
    ID = 0xb17f890
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_recentStickersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_recentStickers(TLObject):
    ID = 0x88d37c56
    def __init__(self, hash = None, packs = None, stickers = None, dates = None):
        self.hash = hash
        self.packs = packs
        self.stickers = stickers
        self.dates = dates
    def __str__(self):
        return 'messages_recentStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.packs))
        for vec_k_2 in self.packs:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.stickers))
        for vec_k_3 in self.stickers:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dates))
        for vec_k_4 in self.dates:
            stream.pack_int32(vec_k_4)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.packs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerPack()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.packs.append(elem_of_1_vec)
        self.stickers = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Document()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.stickers.append(elem_of_2_vec)
        self.dates = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            self.dates.append(data.unpack_int32())
        return self

class messages_getRecentStickers(TLObject):
    ID = 0x9da9403b
    def __init__(self, flags = None, attached = None, hash = None):
        self.flags = flags
        self.attached = attached
        self.hash = hash
    def __str__(self):
        return 'messages_getRecentStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.attached:
            flags |= (1 << 0)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.attached = True
        self.hash = data.unpack_int64()
        return self

class messages_RecentStickers(TLObject):
    DERIVED_OBJECTS = {0xb17f890: messages_recentStickersNotModified, 0x88d37c56: messages_recentStickers, 0x9da9403b: messages_getRecentStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_archivedStickers(TLObject):
    ID = 0x4fcba9c8
    def __init__(self, count = None, sets = None):
        self.count = count
        self.sets = sets
    def __str__(self):
        return 'messages_archivedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sets))
        for vec_k_2 in self.sets:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.sets = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerSetCovered()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.sets.append(elem_of_1_vec)
        return self

class messages_getArchivedStickers(TLObject):
    ID = 0x57f17692
    def __init__(self, flags = None, masks = None, offset_id = None, limit = None):
        self.flags = flags
        self.masks = masks
        self.offset_id = offset_id
        self.limit = limit
    def __str__(self):
        return 'messages_getArchivedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.masks:
            flags |= (1 << 0)
        stream.pack_int64(self.offset_id)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.masks = True
        self.offset_id = data.unpack_int64()
        self.limit = data.unpack_int32()
        return self

class messages_ArchivedStickers(TLObject):
    DERIVED_OBJECTS = {0x4fcba9c8: messages_archivedStickers, 0x57f17692: messages_getArchivedStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_stickerSetInstallResultSuccess(TLObject):
    ID = 0x38641628
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_stickerSetInstallResultSuccess'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_stickerSetInstallResultArchive(TLObject):
    ID = 0x35e410a8
    def __init__(self, sets = None):
        self.sets = sets
    def __str__(self):
        return 'messages_stickerSetInstallResultArchive'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sets))
        for vec_k_2 in self.sets:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.sets = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerSetCovered()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.sets.append(elem_of_1_vec)
        return self

class messages_installStickerSet(TLObject):
    ID = 0xc78fe460
    def __init__(self, stickerset = None, archived = None):
        self.stickerset = stickerset
        self.archived = archived
    def __str__(self):
        return 'messages_installStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.stickerset.write())
        stream.pack_bytes(self.archived.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.stickerset = InputStickerSet()
        self.stickerset = self.stickerset.read(data)
        self.archived = Bool()
        self.archived = self.archived.read(data)
        return self

class messages_StickerSetInstallResult(TLObject):
    DERIVED_OBJECTS = {0x38641628: messages_stickerSetInstallResultSuccess, 0x35e410a8: messages_stickerSetInstallResultArchive, 0xc78fe460: messages_installStickerSet}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stickerSetCovered(TLObject):
    ID = 0x6410a5d2
    def __init__(self, set = None, cover = None):
        self.set = set
        self.cover = cover
    def __str__(self):
        return 'stickerSetCovered'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.set.write())
        stream.pack_bytes(self.cover.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.set = StickerSet()
        self.set = self.set.read(data)
        self.cover = Document()
        self.cover = self.cover.read(data)
        return self

class stickerSetMultiCovered(TLObject):
    ID = 0x3407e51b
    def __init__(self, set = None, covers = None):
        self.set = set
        self.covers = covers
    def __str__(self):
        return 'stickerSetMultiCovered'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.set.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.covers))
        for vec_k_2 in self.covers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.set = StickerSet()
        self.set = self.set.read(data)
        self.covers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Document()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.covers.append(elem_of_1_vec)
        return self

class StickerSetCovered(TLObject):
    DERIVED_OBJECTS = {0x6410a5d2: stickerSetCovered, 0x3407e51b: stickerSetMultiCovered}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class maskCoords(TLObject):
    ID = 0xaed6dbb2
    def __init__(self, n = None, x = None, y = None, zoom = None):
        self.n = n
        self.x = x
        self.y = y
        self.zoom = zoom
    def __str__(self):
        return 'maskCoords'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.n)
        stream.pack_double(self.x)
        stream.pack_double(self.y)
        stream.pack_double(self.zoom)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.n = data.unpack_int32()
        self.x = data.unpack_double()
        self.y = data.unpack_double()
        self.zoom = data.unpack_double()
        return self

class MaskCoords(TLObject):
    DERIVED_OBJECTS = {0xaed6dbb2: maskCoords}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputStickeredMediaPhoto(TLObject):
    ID = 0x4a992157
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputStickeredMediaPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputPhoto()
        self.id = self.id.read(data)
        return self

class inputStickeredMediaDocument(TLObject):
    ID = 0x438865b
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputStickeredMediaDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputDocument()
        self.id = self.id.read(data)
        return self

class InputStickeredMedia(TLObject):
    DERIVED_OBJECTS = {0x4a992157: inputStickeredMediaPhoto, 0x438865b: inputStickeredMediaDocument}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class game(TLObject):
    ID = 0xbdf9653b
    def __init__(self, flags = None, id = None, access_hash = None, short_name = None, title = None, description = None, photo = None, document = None):
        self.flags = flags
        self.id = id
        self.access_hash = access_hash
        self.short_name = short_name
        self.title = title
        self.description = description
        self.photo = photo
        self.document = document
    def __str__(self):
        return 'game'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.short_name)
        stream.pack_string(self.title)
        stream.pack_string(self.description)
        stream.pack_bytes(self.photo.write())
        flags = 0x0
        if self.document:
            flags |= (1 << 0)
            stream.pack_bytes(self.document.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.short_name = data.unpack_string()
        self.title = data.unpack_string()
        self.description = data.unpack_string()
        self.photo = Photo()
        self.photo = self.photo.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.document = Document()
            self.document = self.document.read(data)
        return self

class Game(TLObject):
    DERIVED_OBJECTS = {0xbdf9653b: game}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputGameID(TLObject):
    ID = 0x32c3e77
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputGameID'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputGameShortName(TLObject):
    ID = 0xc331e80a
    def __init__(self, bot_id = None, short_name = None):
        self.bot_id = bot_id
        self.short_name = short_name
    def __str__(self):
        return 'inputGameShortName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.bot_id.write())
        stream.pack_string(self.short_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.bot_id = InputUser()
        self.bot_id = self.bot_id.read(data)
        self.short_name = data.unpack_string()
        return self

class InputGame(TLObject):
    DERIVED_OBJECTS = {0x32c3e77: inputGameID, 0xc331e80a: inputGameShortName}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class highScore(TLObject):
    ID = 0x73a379eb
    def __init__(self, pos = None, user_id = None, score = None):
        self.pos = pos
        self.user_id = user_id
        self.score = score
    def __str__(self):
        return 'highScore'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pos)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.score)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pos = data.unpack_int32()
        self.user_id = data.unpack_int64()
        self.score = data.unpack_int32()
        return self

class HighScore(TLObject):
    DERIVED_OBJECTS = {0x73a379eb: highScore}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_highScores(TLObject):
    ID = 0x9a3bfd99
    def __init__(self, scores = None, users = None):
        self.scores = scores
        self.users = users
    def __str__(self):
        return 'messages_highScores'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.scores))
        for vec_k_2 in self.scores:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.scores = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = HighScore()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.scores.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class messages_getGameHighScores(TLObject):
    ID = 0xe822649d
    def __init__(self, peer = None, id = None, user_id = None):
        self.peer = peer
        self.id = id
        self.user_id = user_id
    def __str__(self):
        return 'messages_getGameHighScores'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.id)
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = data.unpack_int32()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class messages_getInlineGameHighScores(TLObject):
    ID = 0xf635e1b
    def __init__(self, id = None, user_id = None):
        self.id = id
        self.user_id = user_id
    def __str__(self):
        return 'messages_getInlineGameHighScores'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.id.write())
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = InputBotInlineMessageID()
        self.id = self.id.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class messages_HighScores(TLObject):
    DERIVED_OBJECTS = {0x9a3bfd99: messages_highScores, 0xe822649d: messages_getGameHighScores, 0xf635e1b: messages_getInlineGameHighScores}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class textEmpty(TLObject):
    ID = 0xdc3d824f
    def __init__(self):
        pass
    def __str__(self):
        return 'textEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class textPlain(TLObject):
    ID = 0x744694e0
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textPlain'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        return self

class textBold(TLObject):
    ID = 0x6724abc4
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textBold'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textItalic(TLObject):
    ID = 0xd912a59c
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textItalic'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textUnderline(TLObject):
    ID = 0xc12622c4
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textUnderline'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textStrike(TLObject):
    ID = 0x9bf8bb95
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textStrike'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textFixed(TLObject):
    ID = 0x6c3f19b9
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textFixed'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textUrl(TLObject):
    ID = 0x3c2884c1
    def __init__(self, text = None, url = None, webpage_id = None):
        self.text = text
        self.url = url
        self.webpage_id = webpage_id
    def __str__(self):
        return 'textUrl'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_string(self.url)
        stream.pack_int64(self.webpage_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.url = data.unpack_string()
        self.webpage_id = data.unpack_int64()
        return self

class textEmail(TLObject):
    ID = 0xde5a0dd6
    def __init__(self, text = None, email = None):
        self.text = text
        self.email = email
    def __str__(self):
        return 'textEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_string(self.email)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.email = data.unpack_string()
        return self

class textConcat(TLObject):
    ID = 0x7e6260d7
    def __init__(self, texts = None):
        self.texts = texts
    def __str__(self):
        return 'textConcat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.texts))
        for vec_k_2 in self.texts:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.texts = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = RichText()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.texts.append(elem_of_1_vec)
        return self

class textSubscript(TLObject):
    ID = 0xed6a8504
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textSubscript'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textSuperscript(TLObject):
    ID = 0xc7fb5e01
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textSuperscript'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textMarked(TLObject):
    ID = 0x34b8621
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'textMarked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class textPhone(TLObject):
    ID = 0x1ccb966a
    def __init__(self, text = None, phone = None):
        self.text = text
        self.phone = phone
    def __str__(self):
        return 'textPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_string(self.phone)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.phone = data.unpack_string()
        return self

class textImage(TLObject):
    ID = 0x81ccf4f
    def __init__(self, document_id = None, w = None, h = None):
        self.document_id = document_id
        self.w = w
        self.h = h
    def __str__(self):
        return 'textImage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.document_id)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.document_id = data.unpack_int64()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        return self

class textAnchor(TLObject):
    ID = 0x35553762
    def __init__(self, text = None, name = None):
        self.text = text
        self.name = name
    def __str__(self):
        return 'textAnchor'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_string(self.name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.name = data.unpack_string()
        return self

class RichText(TLObject):
    DERIVED_OBJECTS = {0xdc3d824f: textEmpty, 0x744694e0: textPlain, 0x6724abc4: textBold, 0xd912a59c: textItalic, 0xc12622c4: textUnderline, 0x9bf8bb95: textStrike, 0x6c3f19b9: textFixed, 0x3c2884c1: textUrl, 0xde5a0dd6: textEmail, 0x7e6260d7: textConcat, 0xed6a8504: textSubscript, 0xc7fb5e01: textSuperscript, 0x34b8621: textMarked, 0x1ccb966a: textPhone, 0x81ccf4f: textImage, 0x35553762: textAnchor}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageBlockUnsupported(TLObject):
    ID = 0x13567e8a
    def __init__(self):
        pass
    def __str__(self):
        return 'pageBlockUnsupported'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class pageBlockTitle(TLObject):
    ID = 0x70abc3fd
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockTitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockSubtitle(TLObject):
    ID = 0x8ffa9a1f
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockSubtitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockAuthorDate(TLObject):
    ID = 0xbaafe5e0
    def __init__(self, author = None, published_date = None):
        self.author = author
        self.published_date = published_date
    def __str__(self):
        return 'pageBlockAuthorDate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.author.write())
        stream.pack_int32(self.published_date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.author = RichText()
        self.author = self.author.read(data)
        self.published_date = data.unpack_int32()
        return self

class pageBlockHeader(TLObject):
    ID = 0xbfd064ec
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockHeader'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockSubheader(TLObject):
    ID = 0xf12bb6e1
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockSubheader'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockParagraph(TLObject):
    ID = 0x467a0766
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockParagraph'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockPreformatted(TLObject):
    ID = 0xc070d93e
    def __init__(self, text = None, language = None):
        self.text = text
        self.language = language
    def __str__(self):
        return 'pageBlockPreformatted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_string(self.language)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.language = data.unpack_string()
        return self

class pageBlockFooter(TLObject):
    ID = 0x48870999
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockFooter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockDivider(TLObject):
    ID = 0xdb20b188
    def __init__(self):
        pass
    def __str__(self):
        return 'pageBlockDivider'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class pageBlockAnchor(TLObject):
    ID = 0xce0d37b0
    def __init__(self, name = None):
        self.name = name
    def __str__(self):
        return 'pageBlockAnchor'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.name = data.unpack_string()
        return self

class pageBlockList(TLObject):
    ID = 0xe4e88011
    def __init__(self, items = None):
        self.items = items
    def __str__(self):
        return 'pageBlockList'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.items))
        for vec_k_2 in self.items:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.items = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageListItem()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.items.append(elem_of_1_vec)
        return self

class pageBlockBlockquote(TLObject):
    ID = 0x263d7c26
    def __init__(self, text = None, caption = None):
        self.text = text
        self.caption = caption
    def __str__(self):
        return 'pageBlockBlockquote'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.caption = RichText()
        self.caption = self.caption.read(data)
        return self

class pageBlockPullquote(TLObject):
    ID = 0x4f4456d3
    def __init__(self, text = None, caption = None):
        self.text = text
        self.caption = caption
    def __str__(self):
        return 'pageBlockPullquote'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.caption = RichText()
        self.caption = self.caption.read(data)
        return self

class pageBlockPhoto(TLObject):
    ID = 0x1759c560
    def __init__(self, flags = None, photo_id = None, caption = None, url = None, webpage_id = None):
        self.flags = flags
        self.photo_id = photo_id
        self.caption = caption
        self.url = url
        self.webpage_id = webpage_id
    def __str__(self):
        return 'pageBlockPhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.photo_id)
        stream.pack_bytes(self.caption.write())
        flags = 0x0
        if self.url:
            flags |= (1 << 0)
            stream.pack_string(self.url)
        if self.webpage_id:
            flags |= (1 << 0)
            stream.pack_int64(self.webpage_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.photo_id = data.unpack_int64()
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.url = data.unpack_string()
        if flags.check_bit(0):
            self.webpage_id = data.unpack_int64()
        return self

class pageBlockVideo(TLObject):
    ID = 0x7c8fe7b6
    def __init__(self, flags = None, autoplay = None, loop = None, video_id = None, caption = None):
        self.flags = flags
        self.autoplay = autoplay
        self.loop = loop
        self.video_id = video_id
        self.caption = caption
    def __str__(self):
        return 'pageBlockVideo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.autoplay:
            flags |= (1 << 0)
        if self.loop:
            flags |= (1 << 1)
        stream.pack_int64(self.video_id)
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.autoplay = True
        if flags.check_bit(1):
            self.loop = True
        self.video_id = data.unpack_int64()
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class pageBlockCover(TLObject):
    ID = 0x39f23300
    def __init__(self, cover = None):
        self.cover = cover
    def __str__(self):
        return 'pageBlockCover'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.cover.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.cover = PageBlock()
        self.cover = self.cover.read(data)
        return self

class pageBlockEmbed(TLObject):
    ID = 0xa8718dc5
    def __init__(self, flags = None, full_width = None, allow_scrolling = None, url = None, html = None, poster_photo_id = None, w = None, h = None, caption = None):
        self.flags = flags
        self.full_width = full_width
        self.allow_scrolling = allow_scrolling
        self.url = url
        self.html = html
        self.poster_photo_id = poster_photo_id
        self.w = w
        self.h = h
        self.caption = caption
    def __str__(self):
        return 'pageBlockEmbed'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.full_width:
            flags |= (1 << 0)
        if self.allow_scrolling:
            flags |= (1 << 3)
        if self.url:
            flags |= (1 << 1)
            stream.pack_string(self.url)
        if self.html:
            flags |= (1 << 2)
            stream.pack_string(self.html)
        if self.poster_photo_id:
            flags |= (1 << 4)
            stream.pack_int64(self.poster_photo_id)
        if self.w:
            flags |= (1 << 5)
            stream.pack_int32(self.w)
        if self.h:
            flags |= (1 << 5)
            stream.pack_int32(self.h)
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.full_width = True
        if flags.check_bit(3):
            self.allow_scrolling = True
        if flags.check_bit(1):
            self.url = data.unpack_string()
        if flags.check_bit(2):
            self.html = data.unpack_string()
        if flags.check_bit(4):
            self.poster_photo_id = data.unpack_int64()
        if flags.check_bit(5):
            self.w = data.unpack_int32()
        if flags.check_bit(5):
            self.h = data.unpack_int32()
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class pageBlockEmbedPost(TLObject):
    ID = 0xf259a80b
    def __init__(self, url = None, webpage_id = None, author_photo_id = None, author = None, date = None, blocks = None, caption = None):
        self.url = url
        self.webpage_id = webpage_id
        self.author_photo_id = author_photo_id
        self.author = author
        self.date = date
        self.blocks = blocks
        self.caption = caption
    def __str__(self):
        return 'pageBlockEmbedPost'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int64(self.webpage_id)
        stream.pack_int64(self.author_photo_id)
        stream.pack_string(self.author)
        stream.pack_int32(self.date)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocks))
        for vec_k_2 in self.blocks:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.webpage_id = data.unpack_int64()
        self.author_photo_id = data.unpack_int64()
        self.author = data.unpack_string()
        self.date = data.unpack_int32()
        self.blocks = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocks.append(elem_of_1_vec)
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class pageBlockCollage(TLObject):
    ID = 0x65a0fa4d
    def __init__(self, items = None, caption = None):
        self.items = items
        self.caption = caption
    def __str__(self):
        return 'pageBlockCollage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.items))
        for vec_k_2 in self.items:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.items = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.items.append(elem_of_1_vec)
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class pageBlockSlideshow(TLObject):
    ID = 0x31f9590
    def __init__(self, items = None, caption = None):
        self.items = items
        self.caption = caption
    def __str__(self):
        return 'pageBlockSlideshow'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.items))
        for vec_k_2 in self.items:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.items = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.items.append(elem_of_1_vec)
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class pageBlockChannel(TLObject):
    ID = 0xef1751b5
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'pageBlockChannel'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = Chat()
        self.channel = self.channel.read(data)
        return self

class pageBlockAudio(TLObject):
    ID = 0x804361ea
    def __init__(self, audio_id = None, caption = None):
        self.audio_id = audio_id
        self.caption = caption
    def __str__(self):
        return 'pageBlockAudio'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.audio_id)
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.audio_id = data.unpack_int64()
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class pageBlockKicker(TLObject):
    ID = 0x1e148390
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageBlockKicker'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageBlockTable(TLObject):
    ID = 0xbf4dea82
    def __init__(self, flags = None, bordered = None, striped = None, title = None, rows = None):
        self.flags = flags
        self.bordered = bordered
        self.striped = striped
        self.title = title
        self.rows = rows
    def __str__(self):
        return 'pageBlockTable'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.bordered:
            flags |= (1 << 0)
        if self.striped:
            flags |= (1 << 1)
        stream.pack_bytes(self.title.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.rows))
        for vec_k_2 in self.rows:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.bordered = True
        if flags.check_bit(1):
            self.striped = True
        self.title = RichText()
        self.title = self.title.read(data)
        self.rows = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageTableRow()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.rows.append(elem_of_1_vec)
        return self

class pageBlockOrderedList(TLObject):
    ID = 0x9a8ae1e1
    def __init__(self, items = None):
        self.items = items
    def __str__(self):
        return 'pageBlockOrderedList'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.items))
        for vec_k_2 in self.items:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.items = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageListOrderedItem()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.items.append(elem_of_1_vec)
        return self

class pageBlockDetails(TLObject):
    ID = 0x76768bed
    def __init__(self, flags = None, open = None, blocks = None, title = None):
        self.flags = flags
        self.open = open
        self.blocks = blocks
        self.title = title
    def __str__(self):
        return 'pageBlockDetails'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.open:
            flags |= (1 << 0)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocks))
        for vec_k_2 in self.blocks:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_bytes(self.title.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.open = True
        self.blocks = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocks.append(elem_of_1_vec)
        self.title = RichText()
        self.title = self.title.read(data)
        return self

class pageBlockRelatedArticles(TLObject):
    ID = 0x16115a96
    def __init__(self, title = None, articles = None):
        self.title = title
        self.articles = articles
    def __str__(self):
        return 'pageBlockRelatedArticles'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.title.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.articles))
        for vec_k_2 in self.articles:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = RichText()
        self.title = self.title.read(data)
        self.articles = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageRelatedArticle()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.articles.append(elem_of_1_vec)
        return self

class pageBlockMap(TLObject):
    ID = 0xa44f3ef6
    def __init__(self, geo = None, zoom = None, w = None, h = None, caption = None):
        self.geo = geo
        self.zoom = zoom
        self.w = w
        self.h = h
        self.caption = caption
    def __str__(self):
        return 'pageBlockMap'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo.write())
        stream.pack_int32(self.zoom)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        stream.pack_bytes(self.caption.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo = GeoPoint()
        self.geo = self.geo.read(data)
        self.zoom = data.unpack_int32()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        self.caption = PageCaption()
        self.caption = self.caption.read(data)
        return self

class PageBlock(TLObject):
    DERIVED_OBJECTS = {0x13567e8a: pageBlockUnsupported, 0x70abc3fd: pageBlockTitle, 0x8ffa9a1f: pageBlockSubtitle, 0xbaafe5e0: pageBlockAuthorDate, 0xbfd064ec: pageBlockHeader, 0xf12bb6e1: pageBlockSubheader, 0x467a0766: pageBlockParagraph, 0xc070d93e: pageBlockPreformatted, 0x48870999: pageBlockFooter, 0xdb20b188: pageBlockDivider, 0xce0d37b0: pageBlockAnchor, 0xe4e88011: pageBlockList, 0x263d7c26: pageBlockBlockquote, 0x4f4456d3: pageBlockPullquote, 0x1759c560: pageBlockPhoto, 0x7c8fe7b6: pageBlockVideo, 0x39f23300: pageBlockCover, 0xa8718dc5: pageBlockEmbed, 0xf259a80b: pageBlockEmbedPost, 0x65a0fa4d: pageBlockCollage, 0x31f9590: pageBlockSlideshow, 0xef1751b5: pageBlockChannel, 0x804361ea: pageBlockAudio, 0x1e148390: pageBlockKicker, 0xbf4dea82: pageBlockTable, 0x9a8ae1e1: pageBlockOrderedList, 0x76768bed: pageBlockDetails, 0x16115a96: pageBlockRelatedArticles, 0xa44f3ef6: pageBlockMap}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phoneCallDiscardReasonMissed(TLObject):
    ID = 0x85e42301
    def __init__(self):
        pass
    def __str__(self):
        return 'phoneCallDiscardReasonMissed'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class phoneCallDiscardReasonDisconnect(TLObject):
    ID = 0xe095c1a0
    def __init__(self):
        pass
    def __str__(self):
        return 'phoneCallDiscardReasonDisconnect'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class phoneCallDiscardReasonHangup(TLObject):
    ID = 0x57adc690
    def __init__(self):
        pass
    def __str__(self):
        return 'phoneCallDiscardReasonHangup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class phoneCallDiscardReasonBusy(TLObject):
    ID = 0xfaf7e8c9
    def __init__(self):
        pass
    def __str__(self):
        return 'phoneCallDiscardReasonBusy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class PhoneCallDiscardReason(TLObject):
    DERIVED_OBJECTS = {0x85e42301: phoneCallDiscardReasonMissed, 0xe095c1a0: phoneCallDiscardReasonDisconnect, 0x57adc690: phoneCallDiscardReasonHangup, 0xfaf7e8c9: phoneCallDiscardReasonBusy}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class dataJSON(TLObject):
    ID = 0x7d748d04
    def __init__(self, data = None):
        self.data = data
    def __str__(self):
        return 'dataJSON'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.data)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.data = data.unpack_string()
        return self

class bots_sendCustomRequest(TLObject):
    ID = 0xaa2769ed
    def __init__(self, custom_method = None, params = None):
        self.custom_method = custom_method
        self.params = params
    def __str__(self):
        return 'bots_sendCustomRequest'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.custom_method)
        stream.pack_bytes(self.params.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.custom_method = data.unpack_string()
        self.params = DataJSON()
        self.params = self.params.read(data)
        return self

class phone_getCallConfig(TLObject):
    ID = 0x55451fa9
    def __init__(self):
        pass
    def __str__(self):
        return 'phone_getCallConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class DataJSON(TLObject):
    DERIVED_OBJECTS = {0x7d748d04: dataJSON, 0xaa2769ed: bots_sendCustomRequest, 0x55451fa9: phone_getCallConfig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class labeledPrice(TLObject):
    ID = 0xcb296bf8
    def __init__(self, label = None, amount = None):
        self.label = label
        self.amount = amount
    def __str__(self):
        return 'labeledPrice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.label)
        stream.pack_int64(self.amount)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.label = data.unpack_string()
        self.amount = data.unpack_int64()
        return self

class LabeledPrice(TLObject):
    DERIVED_OBJECTS = {0xcb296bf8: labeledPrice}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class invoice(TLObject):
    ID = 0xcd886e0
    def __init__(self, flags = None, test = None, name_requested = None, phone_requested = None, email_requested = None, shipping_address_requested = None, flexible = None, phone_to_provider = None, email_to_provider = None, currency = None, prices = None, max_tip_amount = None, suggested_tip_amounts = None):
        self.flags = flags
        self.test = test
        self.name_requested = name_requested
        self.phone_requested = phone_requested
        self.email_requested = email_requested
        self.shipping_address_requested = shipping_address_requested
        self.flexible = flexible
        self.phone_to_provider = phone_to_provider
        self.email_to_provider = email_to_provider
        self.currency = currency
        self.prices = prices
        self.max_tip_amount = max_tip_amount
        self.suggested_tip_amounts = suggested_tip_amounts
    def __str__(self):
        return 'invoice'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.test:
            flags |= (1 << 0)
        if self.name_requested:
            flags |= (1 << 1)
        if self.phone_requested:
            flags |= (1 << 2)
        if self.email_requested:
            flags |= (1 << 3)
        if self.shipping_address_requested:
            flags |= (1 << 4)
        if self.flexible:
            flags |= (1 << 5)
        if self.phone_to_provider:
            flags |= (1 << 6)
        if self.email_to_provider:
            flags |= (1 << 7)
        stream.pack_string(self.currency)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.prices))
        for vec_k_2 in self.prices:
            stream.pack_bytes(vec_k_2.write())
        if self.max_tip_amount:
            flags |= (1 << 8)
            stream.pack_int64(self.max_tip_amount)
        if self.suggested_tip_amounts:
            flags |= (1 << 8)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.suggested_tip_amounts))
            for vec_k_3 in self.suggested_tip_amounts:
                stream.pack_int64(vec_k_3)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.test = True
        if flags.check_bit(1):
            self.name_requested = True
        if flags.check_bit(2):
            self.phone_requested = True
        if flags.check_bit(3):
            self.email_requested = True
        if flags.check_bit(4):
            self.shipping_address_requested = True
        if flags.check_bit(5):
            self.flexible = True
        if flags.check_bit(6):
            self.phone_to_provider = True
        if flags.check_bit(7):
            self.email_to_provider = True
        self.currency = data.unpack_string()
        self.prices = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = LabeledPrice()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.prices.append(elem_of_1_vec)
        if flags.check_bit(8):
            self.max_tip_amount = data.unpack_int64()
        if flags.check_bit(8):
            self.suggested_tip_amounts = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                self.suggested_tip_amounts.append(data.unpack_int64())
        return self

class Invoice(TLObject):
    DERIVED_OBJECTS = {0xcd886e0: invoice}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class paymentCharge(TLObject):
    ID = 0xea02c27e
    def __init__(self, id = None, provider_charge_id = None):
        self.id = id
        self.provider_charge_id = provider_charge_id
    def __str__(self):
        return 'paymentCharge'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.provider_charge_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_string()
        self.provider_charge_id = data.unpack_string()
        return self

class PaymentCharge(TLObject):
    DERIVED_OBJECTS = {0xea02c27e: paymentCharge}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class postAddress(TLObject):
    ID = 0x1e8caaeb
    def __init__(self, street_line1 = None, street_line2 = None, city = None, state = None, country_iso2 = None, post_code = None):
        self.street_line1 = street_line1
        self.street_line2 = street_line2
        self.city = city
        self.state = state
        self.country_iso2 = country_iso2
        self.post_code = post_code
    def __str__(self):
        return 'postAddress'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.street_line1)
        stream.pack_string(self.street_line2)
        stream.pack_string(self.city)
        stream.pack_string(self.state)
        stream.pack_string(self.country_iso2)
        stream.pack_string(self.post_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.street_line1 = data.unpack_string()
        self.street_line2 = data.unpack_string()
        self.city = data.unpack_string()
        self.state = data.unpack_string()
        self.country_iso2 = data.unpack_string()
        self.post_code = data.unpack_string()
        return self

class PostAddress(TLObject):
    DERIVED_OBJECTS = {0x1e8caaeb: postAddress}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class paymentRequestedInfo(TLObject):
    ID = 0x909c3f94
    def __init__(self, flags = None, name = None, phone = None, email = None, shipping_address = None):
        self.flags = flags
        self.name = name
        self.phone = phone
        self.email = email
        self.shipping_address = shipping_address
    def __str__(self):
        return 'paymentRequestedInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.name:
            flags |= (1 << 0)
            stream.pack_string(self.name)
        if self.phone:
            flags |= (1 << 1)
            stream.pack_string(self.phone)
        if self.email:
            flags |= (1 << 2)
            stream.pack_string(self.email)
        if self.shipping_address:
            flags |= (1 << 3)
            stream.pack_bytes(self.shipping_address.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.name = data.unpack_string()
        if flags.check_bit(1):
            self.phone = data.unpack_string()
        if flags.check_bit(2):
            self.email = data.unpack_string()
        if flags.check_bit(3):
            self.shipping_address = PostAddress()
            self.shipping_address = self.shipping_address.read(data)
        return self

class PaymentRequestedInfo(TLObject):
    DERIVED_OBJECTS = {0x909c3f94: paymentRequestedInfo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class paymentSavedCredentialsCard(TLObject):
    ID = 0xcdc27a1f
    def __init__(self, id = None, title = None):
        self.id = id
        self.title = title
    def __str__(self):
        return 'paymentSavedCredentialsCard'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_string()
        self.title = data.unpack_string()
        return self

class PaymentSavedCredentials(TLObject):
    DERIVED_OBJECTS = {0xcdc27a1f: paymentSavedCredentialsCard}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class webDocument(TLObject):
    ID = 0x1c570ed1
    def __init__(self, url = None, access_hash = None, size = None, mime_type = None, attributes = None):
        self.url = url
        self.access_hash = access_hash
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes
    def __str__(self):
        return 'webDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.size)
        stream.pack_string(self.mime_type)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.attributes))
        for vec_k_2 in self.attributes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.access_hash = data.unpack_int64()
        self.size = data.unpack_int32()
        self.mime_type = data.unpack_string()
        self.attributes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = DocumentAttribute()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.attributes.append(elem_of_1_vec)
        return self

class webDocumentNoProxy(TLObject):
    ID = 0xf9c8bcc6
    def __init__(self, url = None, size = None, mime_type = None, attributes = None):
        self.url = url
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes
    def __str__(self):
        return 'webDocumentNoProxy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int32(self.size)
        stream.pack_string(self.mime_type)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.attributes))
        for vec_k_2 in self.attributes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.size = data.unpack_int32()
        self.mime_type = data.unpack_string()
        self.attributes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = DocumentAttribute()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.attributes.append(elem_of_1_vec)
        return self

class WebDocument(TLObject):
    DERIVED_OBJECTS = {0x1c570ed1: webDocument, 0xf9c8bcc6: webDocumentNoProxy}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputWebDocument(TLObject):
    ID = 0x9bed434d
    def __init__(self, url = None, size = None, mime_type = None, attributes = None):
        self.url = url
        self.size = size
        self.mime_type = mime_type
        self.attributes = attributes
    def __str__(self):
        return 'inputWebDocument'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int32(self.size)
        stream.pack_string(self.mime_type)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.attributes))
        for vec_k_2 in self.attributes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.size = data.unpack_int32()
        self.mime_type = data.unpack_string()
        self.attributes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = DocumentAttribute()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.attributes.append(elem_of_1_vec)
        return self

class InputWebDocument(TLObject):
    DERIVED_OBJECTS = {0x9bed434d: inputWebDocument}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputWebFileLocation(TLObject):
    ID = 0xc239d686
    def __init__(self, url = None, access_hash = None):
        self.url = url
        self.access_hash = access_hash
    def __str__(self):
        return 'inputWebFileLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.access_hash = data.unpack_int64()
        return self

class inputWebFileGeoPointLocation(TLObject):
    ID = 0x9f2221c9
    def __init__(self, geo_point = None, access_hash = None, w = None, h = None, zoom = None, scale = None):
        self.geo_point = geo_point
        self.access_hash = access_hash
        self.w = w
        self.h = h
        self.zoom = zoom
        self.scale = scale
    def __str__(self):
        return 'inputWebFileGeoPointLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo_point.write())
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        stream.pack_int32(self.zoom)
        stream.pack_int32(self.scale)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo_point = InputGeoPoint()
        self.geo_point = self.geo_point.read(data)
        self.access_hash = data.unpack_int64()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        self.zoom = data.unpack_int32()
        self.scale = data.unpack_int32()
        return self

class InputWebFileLocation(TLObject):
    DERIVED_OBJECTS = {0xc239d686: inputWebFileLocation, 0x9f2221c9: inputWebFileGeoPointLocation}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class upload_webFile(TLObject):
    ID = 0x21e753bc
    def __init__(self, size = None, mime_type = None, file_type = None, mtime = None, bytes = None):
        self.size = size
        self.mime_type = mime_type
        self.file_type = file_type
        self.mtime = mtime
        self.bytes = bytes
    def __str__(self):
        return 'upload_webFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.size)
        stream.pack_string(self.mime_type)
        stream.pack_bytes(self.file_type.write())
        stream.pack_int32(self.mtime)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.size = data.unpack_int32()
        self.mime_type = data.unpack_string()
        self.file_type = storage_FileType()
        self.file_type = self.file_type.read(data)
        self.mtime = data.unpack_int32()
        self.bytes = data.unpack_string()
        return self

class upload_getWebFile(TLObject):
    ID = 0x24e6818d
    def __init__(self, location = None, offset = None, limit = None):
        self.location = location
        self.offset = offset
        self.limit = limit
    def __str__(self):
        return 'upload_getWebFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.location.write())
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.location = InputWebFileLocation()
        self.location = self.location.read(data)
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class upload_WebFile(TLObject):
    DERIVED_OBJECTS = {0x21e753bc: upload_webFile, 0x24e6818d: upload_getWebFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class payments_paymentForm(TLObject):
    ID = 0x1694761b
    def __init__(self, flags = None, can_save_credentials = None, password_missing = None, form_id = None, bot_id = None, invoice = None, provider_id = None, url = None, native_provider = None, native_params = None, saved_info = None, saved_credentials = None, users = None):
        self.flags = flags
        self.can_save_credentials = can_save_credentials
        self.password_missing = password_missing
        self.form_id = form_id
        self.bot_id = bot_id
        self.invoice = invoice
        self.provider_id = provider_id
        self.url = url
        self.native_provider = native_provider
        self.native_params = native_params
        self.saved_info = saved_info
        self.saved_credentials = saved_credentials
        self.users = users
    def __str__(self):
        return 'payments_paymentForm'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.can_save_credentials:
            flags |= (1 << 2)
        if self.password_missing:
            flags |= (1 << 3)
        stream.pack_int64(self.form_id)
        stream.pack_int64(self.bot_id)
        stream.pack_bytes(self.invoice.write())
        stream.pack_int64(self.provider_id)
        stream.pack_string(self.url)
        if self.native_provider:
            flags |= (1 << 4)
            stream.pack_string(self.native_provider)
        if self.native_params:
            flags |= (1 << 4)
            stream.pack_bytes(self.native_params.write())
        if self.saved_info:
            flags |= (1 << 0)
            stream.pack_bytes(self.saved_info.write())
        if self.saved_credentials:
            flags |= (1 << 1)
            stream.pack_bytes(self.saved_credentials.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.can_save_credentials = True
        if flags.check_bit(3):
            self.password_missing = True
        self.form_id = data.unpack_int64()
        self.bot_id = data.unpack_int64()
        self.invoice = Invoice()
        self.invoice = self.invoice.read(data)
        self.provider_id = data.unpack_int64()
        self.url = data.unpack_string()
        if flags.check_bit(4):
            self.native_provider = data.unpack_string()
        if flags.check_bit(4):
            self.native_params = DataJSON()
            self.native_params = self.native_params.read(data)
        if flags.check_bit(0):
            self.saved_info = PaymentRequestedInfo()
            self.saved_info = self.saved_info.read(data)
        if flags.check_bit(1):
            self.saved_credentials = PaymentSavedCredentials()
            self.saved_credentials = self.saved_credentials.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = User()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class payments_getPaymentForm(TLObject):
    ID = 0x8a333c8d
    def __init__(self, flags = None, peer = None, msg_id = None, theme_params = None):
        self.flags = flags
        self.peer = peer
        self.msg_id = msg_id
        self.theme_params = theme_params
    def __str__(self):
        return 'payments_getPaymentForm'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        flags = 0x0
        if self.theme_params:
            flags |= (1 << 0)
            stream.pack_bytes(self.theme_params.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.theme_params = DataJSON()
            self.theme_params = self.theme_params.read(data)
        return self

class payments_PaymentForm(TLObject):
    DERIVED_OBJECTS = {0x1694761b: payments_paymentForm, 0x8a333c8d: payments_getPaymentForm}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class payments_validatedRequestedInfo(TLObject):
    ID = 0xd1451883
    def __init__(self, flags = None, id = None, shipping_options = None):
        self.flags = flags
        self.id = id
        self.shipping_options = shipping_options
    def __str__(self):
        return 'payments_validatedRequestedInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.id:
            flags |= (1 << 0)
            stream.pack_string(self.id)
        if self.shipping_options:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.shipping_options))
            for vec_k_2 in self.shipping_options:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.id = data.unpack_string()
        if flags.check_bit(1):
            self.shipping_options = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = ShippingOption()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.shipping_options.append(elem_of_1_vec)
        return self

class payments_validateRequestedInfo(TLObject):
    ID = 0xdb103170
    def __init__(self, flags = None, save = None, peer = None, msg_id = None, info = None):
        self.flags = flags
        self.save = save
        self.peer = peer
        self.msg_id = msg_id
        self.info = info
    def __str__(self):
        return 'payments_validateRequestedInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.save:
            flags |= (1 << 0)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        stream.pack_bytes(self.info.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.save = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        self.info = PaymentRequestedInfo()
        self.info = self.info.read(data)
        return self

class payments_ValidatedRequestedInfo(TLObject):
    DERIVED_OBJECTS = {0xd1451883: payments_validatedRequestedInfo, 0xdb103170: payments_validateRequestedInfo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class payments_paymentResult(TLObject):
    ID = 0x4e5f810d
    def __init__(self, updates = None):
        self.updates = updates
    def __str__(self):
        return 'payments_paymentResult'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.updates.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.updates = Updates()
        self.updates = self.updates.read(data)
        return self

class payments_paymentVerificationNeeded(TLObject):
    ID = 0xd8411139
    def __init__(self, url = None):
        self.url = url
    def __str__(self):
        return 'payments_paymentVerificationNeeded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        return self

class payments_sendPaymentForm(TLObject):
    ID = 0x30c3bc9d
    def __init__(self, flags = None, form_id = None, peer = None, msg_id = None, requested_info_id = None, shipping_option_id = None, credentials = None, tip_amount = None):
        self.flags = flags
        self.form_id = form_id
        self.peer = peer
        self.msg_id = msg_id
        self.requested_info_id = requested_info_id
        self.shipping_option_id = shipping_option_id
        self.credentials = credentials
        self.tip_amount = tip_amount
    def __str__(self):
        return 'payments_sendPaymentForm'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.form_id)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        flags = 0x0
        if self.requested_info_id:
            flags |= (1 << 0)
            stream.pack_string(self.requested_info_id)
        if self.shipping_option_id:
            flags |= (1 << 1)
            stream.pack_string(self.shipping_option_id)
        stream.pack_bytes(self.credentials.write())
        if self.tip_amount:
            flags |= (1 << 2)
            stream.pack_int64(self.tip_amount)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.form_id = data.unpack_int64()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.requested_info_id = data.unpack_string()
        if flags.check_bit(1):
            self.shipping_option_id = data.unpack_string()
        self.credentials = InputPaymentCredentials()
        self.credentials = self.credentials.read(data)
        if flags.check_bit(2):
            self.tip_amount = data.unpack_int64()
        return self

class payments_PaymentResult(TLObject):
    DERIVED_OBJECTS = {0x4e5f810d: payments_paymentResult, 0xd8411139: payments_paymentVerificationNeeded, 0x30c3bc9d: payments_sendPaymentForm}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class payments_paymentReceipt(TLObject):
    ID = 0x70c4fe03
    def __init__(self, flags = None, date = None, bot_id = None, provider_id = None, title = None, description = None, photo = None, invoice = None, info = None, shipping = None, tip_amount = None, currency = None, total_amount = None, credentials_title = None, users = None):
        self.flags = flags
        self.date = date
        self.bot_id = bot_id
        self.provider_id = provider_id
        self.title = title
        self.description = description
        self.photo = photo
        self.invoice = invoice
        self.info = info
        self.shipping = shipping
        self.tip_amount = tip_amount
        self.currency = currency
        self.total_amount = total_amount
        self.credentials_title = credentials_title
        self.users = users
    def __str__(self):
        return 'payments_paymentReceipt'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.date)
        stream.pack_int64(self.bot_id)
        stream.pack_int64(self.provider_id)
        stream.pack_string(self.title)
        stream.pack_string(self.description)
        flags = 0x0
        if self.photo:
            flags |= (1 << 2)
            stream.pack_bytes(self.photo.write())
        stream.pack_bytes(self.invoice.write())
        if self.info:
            flags |= (1 << 0)
            stream.pack_bytes(self.info.write())
        if self.shipping:
            flags |= (1 << 1)
            stream.pack_bytes(self.shipping.write())
        if self.tip_amount:
            flags |= (1 << 3)
            stream.pack_int64(self.tip_amount)
        stream.pack_string(self.currency)
        stream.pack_int64(self.total_amount)
        stream.pack_string(self.credentials_title)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.date = data.unpack_int32()
        self.bot_id = data.unpack_int64()
        self.provider_id = data.unpack_int64()
        self.title = data.unpack_string()
        self.description = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.photo = WebDocument()
            self.photo = self.photo.read(data)
        self.invoice = Invoice()
        self.invoice = self.invoice.read(data)
        if flags.check_bit(0):
            self.info = PaymentRequestedInfo()
            self.info = self.info.read(data)
        if flags.check_bit(1):
            self.shipping = ShippingOption()
            self.shipping = self.shipping.read(data)
        if flags.check_bit(3):
            self.tip_amount = data.unpack_int64()
        self.currency = data.unpack_string()
        self.total_amount = data.unpack_int64()
        self.credentials_title = data.unpack_string()
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = User()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class payments_getPaymentReceipt(TLObject):
    ID = 0x2478d1cc
    def __init__(self, peer = None, msg_id = None):
        self.peer = peer
        self.msg_id = msg_id
    def __str__(self):
        return 'payments_getPaymentReceipt'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        return self

class payments_PaymentReceipt(TLObject):
    DERIVED_OBJECTS = {0x70c4fe03: payments_paymentReceipt, 0x2478d1cc: payments_getPaymentReceipt}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class payments_savedInfo(TLObject):
    ID = 0xfb8fe43c
    def __init__(self, flags = None, has_saved_credentials = None, saved_info = None):
        self.flags = flags
        self.has_saved_credentials = has_saved_credentials
        self.saved_info = saved_info
    def __str__(self):
        return 'payments_savedInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.has_saved_credentials:
            flags |= (1 << 1)
        if self.saved_info:
            flags |= (1 << 0)
            stream.pack_bytes(self.saved_info.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.has_saved_credentials = True
        if flags.check_bit(0):
            self.saved_info = PaymentRequestedInfo()
            self.saved_info = self.saved_info.read(data)
        return self

class payments_getSavedInfo(TLObject):
    ID = 0x227d824b
    def __init__(self):
        pass
    def __str__(self):
        return 'payments_getSavedInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class payments_SavedInfo(TLObject):
    DERIVED_OBJECTS = {0xfb8fe43c: payments_savedInfo, 0x227d824b: payments_getSavedInfo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPaymentCredentialsSaved(TLObject):
    ID = 0xc10eb2cf
    def __init__(self, id = None, tmp_password = None):
        self.id = id
        self.tmp_password = tmp_password
    def __str__(self):
        return 'inputPaymentCredentialsSaved'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.tmp_password)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_string()
        self.tmp_password = data.unpack_string()
        return self

class inputPaymentCredentials(TLObject):
    ID = 0x3417d728
    def __init__(self, flags = None, save = None, data = None):
        self.flags = flags
        self.save = save
        self.data = data
    def __str__(self):
        return 'inputPaymentCredentials'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.save:
            flags |= (1 << 0)
        stream.pack_bytes(self.data.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.save = True
        self.data = DataJSON()
        self.data = self.data.read(data)
        return self

class inputPaymentCredentialsApplePay(TLObject):
    ID = 0xaa1c39f
    def __init__(self, payment_data = None):
        self.payment_data = payment_data
    def __str__(self):
        return 'inputPaymentCredentialsApplePay'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.payment_data.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.payment_data = DataJSON()
        self.payment_data = self.payment_data.read(data)
        return self

class inputPaymentCredentialsGooglePay(TLObject):
    ID = 0x8ac32801
    def __init__(self, payment_token = None):
        self.payment_token = payment_token
    def __str__(self):
        return 'inputPaymentCredentialsGooglePay'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.payment_token.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.payment_token = DataJSON()
        self.payment_token = self.payment_token.read(data)
        return self

class InputPaymentCredentials(TLObject):
    DERIVED_OBJECTS = {0xc10eb2cf: inputPaymentCredentialsSaved, 0x3417d728: inputPaymentCredentials, 0xaa1c39f: inputPaymentCredentialsApplePay, 0x8ac32801: inputPaymentCredentialsGooglePay}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_tmpPassword(TLObject):
    ID = 0xdb64fd34
    def __init__(self, tmp_password = None, valid_until = None):
        self.tmp_password = tmp_password
        self.valid_until = valid_until
    def __str__(self):
        return 'account_tmpPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.tmp_password)
        stream.pack_int32(self.valid_until)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.tmp_password = data.unpack_string()
        self.valid_until = data.unpack_int32()
        return self

class account_getTmpPassword(TLObject):
    ID = 0x449e0b51
    def __init__(self, password = None, period = None):
        self.password = password
        self.period = period
    def __str__(self):
        return 'account_getTmpPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.password.write())
        stream.pack_int32(self.period)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.password = InputCheckPasswordSRP()
        self.password = self.password.read(data)
        self.period = data.unpack_int32()
        return self

class account_TmpPassword(TLObject):
    DERIVED_OBJECTS = {0xdb64fd34: account_tmpPassword, 0x449e0b51: account_getTmpPassword}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class shippingOption(TLObject):
    ID = 0xb6213cdf
    def __init__(self, id = None, title = None, prices = None):
        self.id = id
        self.title = title
        self.prices = prices
    def __str__(self):
        return 'shippingOption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.id)
        stream.pack_string(self.title)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.prices))
        for vec_k_2 in self.prices:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_string()
        self.title = data.unpack_string()
        self.prices = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = LabeledPrice()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.prices.append(elem_of_1_vec)
        return self

class ShippingOption(TLObject):
    DERIVED_OBJECTS = {0xb6213cdf: shippingOption}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputStickerSetItem(TLObject):
    ID = 0xffa0a496
    def __init__(self, flags = None, document = None, emoji = None, mask_coords = None):
        self.flags = flags
        self.document = document
        self.emoji = emoji
        self.mask_coords = mask_coords
    def __str__(self):
        return 'inputStickerSetItem'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.document.write())
        stream.pack_string(self.emoji)
        flags = 0x0
        if self.mask_coords:
            flags |= (1 << 0)
            stream.pack_bytes(self.mask_coords.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.document = InputDocument()
        self.document = self.document.read(data)
        self.emoji = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.mask_coords = MaskCoords()
            self.mask_coords = self.mask_coords.read(data)
        return self

class InputStickerSetItem(TLObject):
    DERIVED_OBJECTS = {0xffa0a496: inputStickerSetItem}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputPhoneCall(TLObject):
    ID = 0x1e36fded
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputPhoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class InputPhoneCall(TLObject):
    DERIVED_OBJECTS = {0x1e36fded: inputPhoneCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phoneCallEmpty(TLObject):
    ID = 0x5366c915
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'phoneCallEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class phoneCallWaiting(TLObject):
    ID = 0xc5226f17
    def __init__(self, flags = None, video = None, id = None, access_hash = None, date = None, admin_id = None, participant_id = None, protocol = None, receive_date = None):
        self.flags = flags
        self.video = video
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.protocol = protocol
        self.receive_date = receive_date
    def __str__(self):
        return 'phoneCallWaiting'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.video:
            flags |= (1 << 6)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        stream.pack_bytes(self.protocol.write())
        if self.receive_date:
            flags |= (1 << 0)
            stream.pack_int32(self.receive_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(6):
            self.video = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        if flags.check_bit(0):
            self.receive_date = data.unpack_int32()
        return self

class phoneCallRequested(TLObject):
    ID = 0x14b0ed0c
    def __init__(self, flags = None, video = None, id = None, access_hash = None, date = None, admin_id = None, participant_id = None, g_a_hash = None, protocol = None):
        self.flags = flags
        self.video = video
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_hash = g_a_hash
        self.protocol = protocol
    def __str__(self):
        return 'phoneCallRequested'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.video:
            flags |= (1 << 6)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        stream.pack_string(self.g_a_hash)
        stream.pack_bytes(self.protocol.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(6):
            self.video = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        self.g_a_hash = data.unpack_string()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        return self

class phoneCallAccepted(TLObject):
    ID = 0x3660c311
    def __init__(self, flags = None, video = None, id = None, access_hash = None, date = None, admin_id = None, participant_id = None, g_b = None, protocol = None):
        self.flags = flags
        self.video = video
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_b = g_b
        self.protocol = protocol
    def __str__(self):
        return 'phoneCallAccepted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.video:
            flags |= (1 << 6)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        stream.pack_string(self.g_b)
        stream.pack_bytes(self.protocol.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(6):
            self.video = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        self.g_b = data.unpack_string()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        return self

class phoneCall(TLObject):
    ID = 0x967f7c67
    def __init__(self, flags = None, p2p_allowed = None, video = None, id = None, access_hash = None, date = None, admin_id = None, participant_id = None, g_a_or_b = None, key_fingerprint = None, protocol = None, connections = None, start_date = None):
        self.flags = flags
        self.p2p_allowed = p2p_allowed
        self.video = video
        self.id = id
        self.access_hash = access_hash
        self.date = date
        self.admin_id = admin_id
        self.participant_id = participant_id
        self.g_a_or_b = g_a_or_b
        self.key_fingerprint = key_fingerprint
        self.protocol = protocol
        self.connections = connections
        self.start_date = start_date
    def __str__(self):
        return 'phoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.p2p_allowed:
            flags |= (1 << 5)
        if self.video:
            flags |= (1 << 6)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.date)
        stream.pack_int64(self.admin_id)
        stream.pack_int64(self.participant_id)
        stream.pack_string(self.g_a_or_b)
        stream.pack_int64(self.key_fingerprint)
        stream.pack_bytes(self.protocol.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.connections))
        for vec_k_2 in self.connections:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.start_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(5):
            self.p2p_allowed = True
        if flags.check_bit(6):
            self.video = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.date = data.unpack_int32()
        self.admin_id = data.unpack_int64()
        self.participant_id = data.unpack_int64()
        self.g_a_or_b = data.unpack_string()
        self.key_fingerprint = data.unpack_int64()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        self.connections = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PhoneConnection()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.connections.append(elem_of_1_vec)
        self.start_date = data.unpack_int32()
        return self

class phoneCallDiscarded(TLObject):
    ID = 0x50ca4de1
    def __init__(self, flags = None, need_rating = None, need_debug = None, video = None, id = None, reason = None, duration = None):
        self.flags = flags
        self.need_rating = need_rating
        self.need_debug = need_debug
        self.video = video
        self.id = id
        self.reason = reason
        self.duration = duration
    def __str__(self):
        return 'phoneCallDiscarded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.need_rating:
            flags |= (1 << 2)
        if self.need_debug:
            flags |= (1 << 3)
        if self.video:
            flags |= (1 << 6)
        stream.pack_int64(self.id)
        if self.reason:
            flags |= (1 << 0)
            stream.pack_bytes(self.reason.write())
        if self.duration:
            flags |= (1 << 1)
            stream.pack_int32(self.duration)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.need_rating = True
        if flags.check_bit(3):
            self.need_debug = True
        if flags.check_bit(6):
            self.video = True
        self.id = data.unpack_int64()
        if flags.check_bit(0):
            self.reason = PhoneCallDiscardReason()
            self.reason = self.reason.read(data)
        if flags.check_bit(1):
            self.duration = data.unpack_int32()
        return self

class PhoneCall(TLObject):
    DERIVED_OBJECTS = {0x5366c915: phoneCallEmpty, 0xc5226f17: phoneCallWaiting, 0x14b0ed0c: phoneCallRequested, 0x3660c311: phoneCallAccepted, 0x967f7c67: phoneCall, 0x50ca4de1: phoneCallDiscarded}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phoneConnection(TLObject):
    ID = 0x9d4c17c0
    def __init__(self, id = None, ip = None, ipv6 = None, port = None, peer_tag = None):
        self.id = id
        self.ip = ip
        self.ipv6 = ipv6
        self.port = port
        self.peer_tag = peer_tag
    def __str__(self):
        return 'phoneConnection'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_string(self.ip)
        stream.pack_string(self.ipv6)
        stream.pack_int32(self.port)
        stream.pack_string(self.peer_tag)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.ip = data.unpack_string()
        self.ipv6 = data.unpack_string()
        self.port = data.unpack_int32()
        self.peer_tag = data.unpack_string()
        return self

class phoneConnectionWebrtc(TLObject):
    ID = 0x635fe375
    def __init__(self, flags = None, turn = None, stun = None, id = None, ip = None, ipv6 = None, port = None, username = None, password = None):
        self.flags = flags
        self.turn = turn
        self.stun = stun
        self.id = id
        self.ip = ip
        self.ipv6 = ipv6
        self.port = port
        self.username = username
        self.password = password
    def __str__(self):
        return 'phoneConnectionWebrtc'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.turn:
            flags |= (1 << 0)
        if self.stun:
            flags |= (1 << 1)
        stream.pack_int64(self.id)
        stream.pack_string(self.ip)
        stream.pack_string(self.ipv6)
        stream.pack_int32(self.port)
        stream.pack_string(self.username)
        stream.pack_string(self.password)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.turn = True
        if flags.check_bit(1):
            self.stun = True
        self.id = data.unpack_int64()
        self.ip = data.unpack_string()
        self.ipv6 = data.unpack_string()
        self.port = data.unpack_int32()
        self.username = data.unpack_string()
        self.password = data.unpack_string()
        return self

class PhoneConnection(TLObject):
    DERIVED_OBJECTS = {0x9d4c17c0: phoneConnection, 0x635fe375: phoneConnectionWebrtc}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phoneCallProtocol(TLObject):
    ID = 0xfc878fc8
    def __init__(self, flags = None, udp_p2p = None, udp_reflector = None, min_layer = None, max_layer = None, library_versions = None):
        self.flags = flags
        self.udp_p2p = udp_p2p
        self.udp_reflector = udp_reflector
        self.min_layer = min_layer
        self.max_layer = max_layer
        self.library_versions = library_versions
    def __str__(self):
        return 'phoneCallProtocol'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.udp_p2p:
            flags |= (1 << 0)
        if self.udp_reflector:
            flags |= (1 << 1)
        stream.pack_int32(self.min_layer)
        stream.pack_int32(self.max_layer)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.library_versions))
        for vec_k_2 in self.library_versions:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.udp_p2p = True
        if flags.check_bit(1):
            self.udp_reflector = True
        self.min_layer = data.unpack_int32()
        self.max_layer = data.unpack_int32()
        self.library_versions = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.library_versions.append(data.unpack_string())
        return self

class PhoneCallProtocol(TLObject):
    DERIVED_OBJECTS = {0xfc878fc8: phoneCallProtocol}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phone_phoneCall(TLObject):
    ID = 0xec82e140
    def __init__(self, phone_call = None, users = None):
        self.phone_call = phone_call
        self.users = users
    def __str__(self):
        return 'phone_phoneCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.phone_call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone_call = PhoneCall()
        self.phone_call = self.phone_call.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = User()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class phone_requestCall(TLObject):
    ID = 0x42ff96ed
    def __init__(self, flags = None, video = None, user_id = None, random_id = None, g_a_hash = None, protocol = None):
        self.flags = flags
        self.video = video
        self.user_id = user_id
        self.random_id = random_id
        self.g_a_hash = g_a_hash
        self.protocol = protocol
    def __str__(self):
        return 'phone_requestCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.video:
            flags |= (1 << 0)
        stream.pack_bytes(self.user_id.write())
        stream.pack_int32(self.random_id)
        stream.pack_string(self.g_a_hash)
        stream.pack_bytes(self.protocol.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.video = True
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.random_id = data.unpack_int32()
        self.g_a_hash = data.unpack_string()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        return self

class phone_acceptCall(TLObject):
    ID = 0x3bd2b4a0
    def __init__(self, peer = None, g_b = None, protocol = None):
        self.peer = peer
        self.g_b = g_b
        self.protocol = protocol
    def __str__(self):
        return 'phone_acceptCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.g_b)
        stream.pack_bytes(self.protocol.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        self.g_b = data.unpack_string()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        return self

class phone_confirmCall(TLObject):
    ID = 0x2efe1722
    def __init__(self, peer = None, g_a = None, key_fingerprint = None, protocol = None):
        self.peer = peer
        self.g_a = g_a
        self.key_fingerprint = key_fingerprint
        self.protocol = protocol
    def __str__(self):
        return 'phone_confirmCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.g_a)
        stream.pack_int64(self.key_fingerprint)
        stream.pack_bytes(self.protocol.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPhoneCall()
        self.peer = self.peer.read(data)
        self.g_a = data.unpack_string()
        self.key_fingerprint = data.unpack_int64()
        self.protocol = PhoneCallProtocol()
        self.protocol = self.protocol.read(data)
        return self

class phone_PhoneCall(TLObject):
    DERIVED_OBJECTS = {0xec82e140: phone_phoneCall, 0x42ff96ed: phone_requestCall, 0x3bd2b4a0: phone_acceptCall, 0x2efe1722: phone_confirmCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class upload_cdnFileReuploadNeeded(TLObject):
    ID = 0xeea8e46e
    def __init__(self, request_token = None):
        self.request_token = request_token
    def __str__(self):
        return 'upload_cdnFileReuploadNeeded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.request_token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.request_token = data.unpack_string()
        return self

class upload_cdnFile(TLObject):
    ID = 0xa99fca4f
    def __init__(self, bytes = None):
        self.bytes = bytes
    def __str__(self):
        return 'upload_cdnFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.bytes)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.bytes = data.unpack_string()
        return self

class upload_getCdnFile(TLObject):
    ID = 0x2000bcc3
    def __init__(self, file_token = None, offset = None, limit = None):
        self.file_token = file_token
        self.offset = offset
        self.limit = limit
    def __str__(self):
        return 'upload_getCdnFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.file_token)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file_token = data.unpack_string()
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        return self

class upload_CdnFile(TLObject):
    DERIVED_OBJECTS = {0xeea8e46e: upload_cdnFileReuploadNeeded, 0xa99fca4f: upload_cdnFile, 0x2000bcc3: upload_getCdnFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class cdnPublicKey(TLObject):
    ID = 0xc982eaba
    def __init__(self, dc_id = None, public_key = None):
        self.dc_id = dc_id
        self.public_key = public_key
    def __str__(self):
        return 'cdnPublicKey'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.dc_id)
        stream.pack_string(self.public_key)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_id = data.unpack_int32()
        self.public_key = data.unpack_string()
        return self

class CdnPublicKey(TLObject):
    DERIVED_OBJECTS = {0xc982eaba: cdnPublicKey}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class cdnConfig(TLObject):
    ID = 0x5725e40a
    def __init__(self, public_keys = None):
        self.public_keys = public_keys
    def __str__(self):
        return 'cdnConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.public_keys))
        for vec_k_2 in self.public_keys:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.public_keys = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = CdnPublicKey()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.public_keys.append(elem_of_1_vec)
        return self

class help_getCdnConfig(TLObject):
    ID = 0x52029342
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getCdnConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class CdnConfig(TLObject):
    DERIVED_OBJECTS = {0x5725e40a: cdnConfig, 0x52029342: help_getCdnConfig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class langPackString(TLObject):
    ID = 0xcad181f6
    def __init__(self, key = None, value = None):
        self.key = key
        self.value = value
    def __str__(self):
        return 'langPackString'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.key)
        stream.pack_string(self.value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.key = data.unpack_string()
        self.value = data.unpack_string()
        return self

class langPackStringPluralized(TLObject):
    ID = 0x6c47ac9f
    def __init__(self, flags = None, key = None, zero_value = None, one_value = None, two_value = None, few_value = None, many_value = None, other_value = None):
        self.flags = flags
        self.key = key
        self.zero_value = zero_value
        self.one_value = one_value
        self.two_value = two_value
        self.few_value = few_value
        self.many_value = many_value
        self.other_value = other_value
    def __str__(self):
        return 'langPackStringPluralized'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.key)
        flags = 0x0
        if self.zero_value:
            flags |= (1 << 0)
            stream.pack_string(self.zero_value)
        if self.one_value:
            flags |= (1 << 1)
            stream.pack_string(self.one_value)
        if self.two_value:
            flags |= (1 << 2)
            stream.pack_string(self.two_value)
        if self.few_value:
            flags |= (1 << 3)
            stream.pack_string(self.few_value)
        if self.many_value:
            flags |= (1 << 4)
            stream.pack_string(self.many_value)
        stream.pack_string(self.other_value)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.key = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.zero_value = data.unpack_string()
        if flags.check_bit(1):
            self.one_value = data.unpack_string()
        if flags.check_bit(2):
            self.two_value = data.unpack_string()
        if flags.check_bit(3):
            self.few_value = data.unpack_string()
        if flags.check_bit(4):
            self.many_value = data.unpack_string()
        self.other_value = data.unpack_string()
        return self

class langPackStringDeleted(TLObject):
    ID = 0x2979eeb2
    def __init__(self, key = None):
        self.key = key
    def __str__(self):
        return 'langPackStringDeleted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.key)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.key = data.unpack_string()
        return self

class LangPackString(TLObject):
    DERIVED_OBJECTS = {0xcad181f6: langPackString, 0x6c47ac9f: langPackStringPluralized, 0x2979eeb2: langPackStringDeleted}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class langPackDifference(TLObject):
    ID = 0xf385c1f6
    def __init__(self, lang_code = None, from_version = None, version = None, strings = None):
        self.lang_code = lang_code
        self.from_version = from_version
        self.version = version
        self.strings = strings
    def __str__(self):
        return 'langPackDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        stream.pack_int32(self.from_version)
        stream.pack_int32(self.version)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.strings))
        for vec_k_2 in self.strings:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        self.from_version = data.unpack_int32()
        self.version = data.unpack_int32()
        self.strings = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = LangPackString()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.strings.append(elem_of_1_vec)
        return self

class langpack_getLangPack(TLObject):
    ID = 0xf2f2330a
    def __init__(self, lang_pack = None, lang_code = None):
        self.lang_pack = lang_pack
        self.lang_code = lang_code
    def __str__(self):
        return 'langpack_getLangPack'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_pack)
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_pack = data.unpack_string()
        self.lang_code = data.unpack_string()
        return self

class langpack_getDifference(TLObject):
    ID = 0xcd984aa5
    def __init__(self, lang_pack = None, lang_code = None, from_version = None):
        self.lang_pack = lang_pack
        self.lang_code = lang_code
        self.from_version = from_version
    def __str__(self):
        return 'langpack_getDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_pack)
        stream.pack_string(self.lang_code)
        stream.pack_int32(self.from_version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_pack = data.unpack_string()
        self.lang_code = data.unpack_string()
        self.from_version = data.unpack_int32()
        return self

class LangPackDifference(TLObject):
    DERIVED_OBJECTS = {0xf385c1f6: langPackDifference, 0xf2f2330a: langpack_getLangPack, 0xcd984aa5: langpack_getDifference}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class langPackLanguage(TLObject):
    ID = 0xeeca5ce3
    def __init__(self, flags = None, official = None, rtl = None, beta = None, name = None, native_name = None, lang_code = None, base_lang_code = None, plural_code = None, strings_count = None, translated_count = None, translations_url = None):
        self.flags = flags
        self.official = official
        self.rtl = rtl
        self.beta = beta
        self.name = name
        self.native_name = native_name
        self.lang_code = lang_code
        self.base_lang_code = base_lang_code
        self.plural_code = plural_code
        self.strings_count = strings_count
        self.translated_count = translated_count
        self.translations_url = translations_url
    def __str__(self):
        return 'langPackLanguage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.official:
            flags |= (1 << 0)
        if self.rtl:
            flags |= (1 << 2)
        if self.beta:
            flags |= (1 << 3)
        stream.pack_string(self.name)
        stream.pack_string(self.native_name)
        stream.pack_string(self.lang_code)
        if self.base_lang_code:
            flags |= (1 << 1)
            stream.pack_string(self.base_lang_code)
        stream.pack_string(self.plural_code)
        stream.pack_int32(self.strings_count)
        stream.pack_int32(self.translated_count)
        stream.pack_string(self.translations_url)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.official = True
        if flags.check_bit(2):
            self.rtl = True
        if flags.check_bit(3):
            self.beta = True
        self.name = data.unpack_string()
        self.native_name = data.unpack_string()
        self.lang_code = data.unpack_string()
        if flags.check_bit(1):
            self.base_lang_code = data.unpack_string()
        self.plural_code = data.unpack_string()
        self.strings_count = data.unpack_int32()
        self.translated_count = data.unpack_int32()
        self.translations_url = data.unpack_string()
        return self

class langpack_getLanguage(TLObject):
    ID = 0x6a596502
    def __init__(self, lang_pack = None, lang_code = None):
        self.lang_pack = lang_pack
        self.lang_code = lang_code
    def __str__(self):
        return 'langpack_getLanguage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_pack)
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_pack = data.unpack_string()
        self.lang_code = data.unpack_string()
        return self

class LangPackLanguage(TLObject):
    DERIVED_OBJECTS = {0xeeca5ce3: langPackLanguage, 0x6a596502: langpack_getLanguage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelAdminLogEventActionChangeTitle(TLObject):
    ID = 0xe6dfb825
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionChangeTitle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.prev_value)
        stream.pack_string(self.new_value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = data.unpack_string()
        self.new_value = data.unpack_string()
        return self

class channelAdminLogEventActionChangeAbout(TLObject):
    ID = 0x55188a2e
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionChangeAbout'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.prev_value)
        stream.pack_string(self.new_value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = data.unpack_string()
        self.new_value = data.unpack_string()
        return self

class channelAdminLogEventActionChangeUsername(TLObject):
    ID = 0x6a4afc38
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionChangeUsername'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.prev_value)
        stream.pack_string(self.new_value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = data.unpack_string()
        self.new_value = data.unpack_string()
        return self

class channelAdminLogEventActionChangePhoto(TLObject):
    ID = 0x434bd2af
    def __init__(self, prev_photo = None, new_photo = None):
        self.prev_photo = prev_photo
        self.new_photo = new_photo
    def __str__(self):
        return 'channelAdminLogEventActionChangePhoto'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_photo.write())
        stream.pack_bytes(self.new_photo.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_photo = Photo()
        self.prev_photo = self.prev_photo.read(data)
        self.new_photo = Photo()
        self.new_photo = self.new_photo.read(data)
        return self

class channelAdminLogEventActionToggleInvites(TLObject):
    ID = 0x1b7907ae
    def __init__(self, new_value = None):
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionToggleInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.new_value.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.new_value = Bool()
        self.new_value = self.new_value.read(data)
        return self

class channelAdminLogEventActionToggleSignatures(TLObject):
    ID = 0x26ae0971
    def __init__(self, new_value = None):
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionToggleSignatures'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.new_value.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.new_value = Bool()
        self.new_value = self.new_value.read(data)
        return self

class channelAdminLogEventActionUpdatePinned(TLObject):
    ID = 0xe9e82c18
    def __init__(self, message = None):
        self.message = message
    def __str__(self):
        return 'channelAdminLogEventActionUpdatePinned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        return self

class channelAdminLogEventActionEditMessage(TLObject):
    ID = 0x709b2405
    def __init__(self, prev_message = None, new_message = None):
        self.prev_message = prev_message
        self.new_message = new_message
    def __str__(self):
        return 'channelAdminLogEventActionEditMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_message.write())
        stream.pack_bytes(self.new_message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_message = Message()
        self.prev_message = self.prev_message.read(data)
        self.new_message = Message()
        self.new_message = self.new_message.read(data)
        return self

class channelAdminLogEventActionDeleteMessage(TLObject):
    ID = 0x42e047bb
    def __init__(self, message = None):
        self.message = message
    def __str__(self):
        return 'channelAdminLogEventActionDeleteMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        return self

class channelAdminLogEventActionParticipantJoin(TLObject):
    ID = 0x183040d3
    def __init__(self):
        pass
    def __str__(self):
        return 'channelAdminLogEventActionParticipantJoin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelAdminLogEventActionParticipantLeave(TLObject):
    ID = 0xf89777f2
    def __init__(self):
        pass
    def __str__(self):
        return 'channelAdminLogEventActionParticipantLeave'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelAdminLogEventActionParticipantInvite(TLObject):
    ID = 0xe31c34d8
    def __init__(self, participant = None):
        self.participant = participant
    def __str__(self):
        return 'channelAdminLogEventActionParticipantInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.participant = ChannelParticipant()
        self.participant = self.participant.read(data)
        return self

class channelAdminLogEventActionParticipantToggleBan(TLObject):
    ID = 0xe6d83d7e
    def __init__(self, prev_participant = None, new_participant = None):
        self.prev_participant = prev_participant
        self.new_participant = new_participant
    def __str__(self):
        return 'channelAdminLogEventActionParticipantToggleBan'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_participant.write())
        stream.pack_bytes(self.new_participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_participant = ChannelParticipant()
        self.prev_participant = self.prev_participant.read(data)
        self.new_participant = ChannelParticipant()
        self.new_participant = self.new_participant.read(data)
        return self

class channelAdminLogEventActionParticipantToggleAdmin(TLObject):
    ID = 0xd5676710
    def __init__(self, prev_participant = None, new_participant = None):
        self.prev_participant = prev_participant
        self.new_participant = new_participant
    def __str__(self):
        return 'channelAdminLogEventActionParticipantToggleAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_participant.write())
        stream.pack_bytes(self.new_participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_participant = ChannelParticipant()
        self.prev_participant = self.prev_participant.read(data)
        self.new_participant = ChannelParticipant()
        self.new_participant = self.new_participant.read(data)
        return self

class channelAdminLogEventActionChangeStickerSet(TLObject):
    ID = 0xb1c3caa7
    def __init__(self, prev_stickerset = None, new_stickerset = None):
        self.prev_stickerset = prev_stickerset
        self.new_stickerset = new_stickerset
    def __str__(self):
        return 'channelAdminLogEventActionChangeStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_stickerset.write())
        stream.pack_bytes(self.new_stickerset.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_stickerset = InputStickerSet()
        self.prev_stickerset = self.prev_stickerset.read(data)
        self.new_stickerset = InputStickerSet()
        self.new_stickerset = self.new_stickerset.read(data)
        return self

class channelAdminLogEventActionTogglePreHistoryHidden(TLObject):
    ID = 0x5f5c95f1
    def __init__(self, new_value = None):
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionTogglePreHistoryHidden'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.new_value.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.new_value = Bool()
        self.new_value = self.new_value.read(data)
        return self

class channelAdminLogEventActionDefaultBannedRights(TLObject):
    ID = 0x2df5fc0a
    def __init__(self, prev_banned_rights = None, new_banned_rights = None):
        self.prev_banned_rights = prev_banned_rights
        self.new_banned_rights = new_banned_rights
    def __str__(self):
        return 'channelAdminLogEventActionDefaultBannedRights'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_banned_rights.write())
        stream.pack_bytes(self.new_banned_rights.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_banned_rights = ChatBannedRights()
        self.prev_banned_rights = self.prev_banned_rights.read(data)
        self.new_banned_rights = ChatBannedRights()
        self.new_banned_rights = self.new_banned_rights.read(data)
        return self

class channelAdminLogEventActionStopPoll(TLObject):
    ID = 0x8f079643
    def __init__(self, message = None):
        self.message = message
    def __str__(self):
        return 'channelAdminLogEventActionStopPoll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.message.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = Message()
        self.message = self.message.read(data)
        return self

class channelAdminLogEventActionChangeLinkedChat(TLObject):
    ID = 0x50c7ac8
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionChangeLinkedChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.prev_value)
        stream.pack_int64(self.new_value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = data.unpack_int64()
        self.new_value = data.unpack_int64()
        return self

class channelAdminLogEventActionChangeLocation(TLObject):
    ID = 0xe6b76ae
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionChangeLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_value.write())
        stream.pack_bytes(self.new_value.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = ChannelLocation()
        self.prev_value = self.prev_value.read(data)
        self.new_value = ChannelLocation()
        self.new_value = self.new_value.read(data)
        return self

class channelAdminLogEventActionToggleSlowMode(TLObject):
    ID = 0x53909779
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionToggleSlowMode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.prev_value)
        stream.pack_int32(self.new_value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = data.unpack_int32()
        self.new_value = data.unpack_int32()
        return self

class channelAdminLogEventActionStartGroupCall(TLObject):
    ID = 0x23209745
    def __init__(self, call = None):
        self.call = call
    def __str__(self):
        return 'channelAdminLogEventActionStartGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        return self

class channelAdminLogEventActionDiscardGroupCall(TLObject):
    ID = 0xdb9f9140
    def __init__(self, call = None):
        self.call = call
    def __str__(self):
        return 'channelAdminLogEventActionDiscardGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        return self

class channelAdminLogEventActionParticipantMute(TLObject):
    ID = 0xf92424d2
    def __init__(self, participant = None):
        self.participant = participant
    def __str__(self):
        return 'channelAdminLogEventActionParticipantMute'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.participant = GroupCallParticipant()
        self.participant = self.participant.read(data)
        return self

class channelAdminLogEventActionParticipantUnmute(TLObject):
    ID = 0xe64429c0
    def __init__(self, participant = None):
        self.participant = participant
    def __str__(self):
        return 'channelAdminLogEventActionParticipantUnmute'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.participant = GroupCallParticipant()
        self.participant = self.participant.read(data)
        return self

class channelAdminLogEventActionToggleGroupCallSetting(TLObject):
    ID = 0x56d6a247
    def __init__(self, join_muted = None):
        self.join_muted = join_muted
    def __str__(self):
        return 'channelAdminLogEventActionToggleGroupCallSetting'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.join_muted.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.join_muted = Bool()
        self.join_muted = self.join_muted.read(data)
        return self

class channelAdminLogEventActionParticipantJoinByInvite(TLObject):
    ID = 0x5cdada77
    def __init__(self, invite = None):
        self.invite = invite
    def __str__(self):
        return 'channelAdminLogEventActionParticipantJoinByInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.invite.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.invite = ExportedChatInvite()
        self.invite = self.invite.read(data)
        return self

class channelAdminLogEventActionExportedInviteDelete(TLObject):
    ID = 0x5a50fca4
    def __init__(self, invite = None):
        self.invite = invite
    def __str__(self):
        return 'channelAdminLogEventActionExportedInviteDelete'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.invite.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.invite = ExportedChatInvite()
        self.invite = self.invite.read(data)
        return self

class channelAdminLogEventActionExportedInviteRevoke(TLObject):
    ID = 0x410a134e
    def __init__(self, invite = None):
        self.invite = invite
    def __str__(self):
        return 'channelAdminLogEventActionExportedInviteRevoke'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.invite.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.invite = ExportedChatInvite()
        self.invite = self.invite.read(data)
        return self

class channelAdminLogEventActionExportedInviteEdit(TLObject):
    ID = 0xe90ebb59
    def __init__(self, prev_invite = None, new_invite = None):
        self.prev_invite = prev_invite
        self.new_invite = new_invite
    def __str__(self):
        return 'channelAdminLogEventActionExportedInviteEdit'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.prev_invite.write())
        stream.pack_bytes(self.new_invite.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_invite = ExportedChatInvite()
        self.prev_invite = self.prev_invite.read(data)
        self.new_invite = ExportedChatInvite()
        self.new_invite = self.new_invite.read(data)
        return self

class channelAdminLogEventActionParticipantVolume(TLObject):
    ID = 0x3e7f6847
    def __init__(self, participant = None):
        self.participant = participant
    def __str__(self):
        return 'channelAdminLogEventActionParticipantVolume'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.participant.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.participant = GroupCallParticipant()
        self.participant = self.participant.read(data)
        return self

class channelAdminLogEventActionChangeHistoryTTL(TLObject):
    ID = 0x6e941a38
    def __init__(self, prev_value = None, new_value = None):
        self.prev_value = prev_value
        self.new_value = new_value
    def __str__(self):
        return 'channelAdminLogEventActionChangeHistoryTTL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.prev_value)
        stream.pack_int32(self.new_value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.prev_value = data.unpack_int32()
        self.new_value = data.unpack_int32()
        return self

class ChannelAdminLogEventAction(TLObject):
    DERIVED_OBJECTS = {0xe6dfb825: channelAdminLogEventActionChangeTitle, 0x55188a2e: channelAdminLogEventActionChangeAbout, 0x6a4afc38: channelAdminLogEventActionChangeUsername, 0x434bd2af: channelAdminLogEventActionChangePhoto, 0x1b7907ae: channelAdminLogEventActionToggleInvites, 0x26ae0971: channelAdminLogEventActionToggleSignatures, 0xe9e82c18: channelAdminLogEventActionUpdatePinned, 0x709b2405: channelAdminLogEventActionEditMessage, 0x42e047bb: channelAdminLogEventActionDeleteMessage, 0x183040d3: channelAdminLogEventActionParticipantJoin, 0xf89777f2: channelAdminLogEventActionParticipantLeave, 0xe31c34d8: channelAdminLogEventActionParticipantInvite, 0xe6d83d7e: channelAdminLogEventActionParticipantToggleBan, 0xd5676710: channelAdminLogEventActionParticipantToggleAdmin, 0xb1c3caa7: channelAdminLogEventActionChangeStickerSet, 0x5f5c95f1: channelAdminLogEventActionTogglePreHistoryHidden, 0x2df5fc0a: channelAdminLogEventActionDefaultBannedRights, 0x8f079643: channelAdminLogEventActionStopPoll, 0x50c7ac8: channelAdminLogEventActionChangeLinkedChat, 0xe6b76ae: channelAdminLogEventActionChangeLocation, 0x53909779: channelAdminLogEventActionToggleSlowMode, 0x23209745: channelAdminLogEventActionStartGroupCall, 0xdb9f9140: channelAdminLogEventActionDiscardGroupCall, 0xf92424d2: channelAdminLogEventActionParticipantMute, 0xe64429c0: channelAdminLogEventActionParticipantUnmute, 0x56d6a247: channelAdminLogEventActionToggleGroupCallSetting, 0x5cdada77: channelAdminLogEventActionParticipantJoinByInvite, 0x5a50fca4: channelAdminLogEventActionExportedInviteDelete, 0x410a134e: channelAdminLogEventActionExportedInviteRevoke, 0xe90ebb59: channelAdminLogEventActionExportedInviteEdit, 0x3e7f6847: channelAdminLogEventActionParticipantVolume, 0x6e941a38: channelAdminLogEventActionChangeHistoryTTL}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelAdminLogEvent(TLObject):
    ID = 0x1fad68cd
    def __init__(self, id = None, date = None, user_id = None, action = None):
        self.id = id
        self.date = date
        self.user_id = user_id
        self.action = action
    def __str__(self):
        return 'channelAdminLogEvent'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.date)
        stream.pack_int64(self.user_id)
        stream.pack_bytes(self.action.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.date = data.unpack_int32()
        self.user_id = data.unpack_int64()
        self.action = ChannelAdminLogEventAction()
        self.action = self.action.read(data)
        return self

class ChannelAdminLogEvent(TLObject):
    DERIVED_OBJECTS = {0x1fad68cd: channelAdminLogEvent}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channels_adminLogResults(TLObject):
    ID = 0xed8af74d
    def __init__(self, events = None, chats = None, users = None):
        self.events = events
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'channels_adminLogResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.events))
        for vec_k_2 in self.events:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.events = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ChannelAdminLogEvent()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.events.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class channels_getAdminLog(TLObject):
    ID = 0x33ddf480
    def __init__(self, flags = None, channel = None, q = None, events_filter = None, admins = None, max_id = None, min_id = None, limit = None):
        self.flags = flags
        self.channel = channel
        self.q = q
        self.events_filter = events_filter
        self.admins = admins
        self.max_id = max_id
        self.min_id = min_id
        self.limit = limit
    def __str__(self):
        return 'channels_getAdminLog'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        stream.pack_string(self.q)
        flags = 0x0
        if self.events_filter:
            flags |= (1 << 0)
            stream.pack_bytes(self.events_filter.write())
        if self.admins:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.admins))
            for vec_k_2 in self.admins:
                stream.pack_bytes(vec_k_2.write())
        stream.pack_int64(self.max_id)
        stream.pack_int64(self.min_id)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.q = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.events_filter = ChannelAdminLogEventsFilter()
            self.events_filter = self.events_filter.read(data)
        if flags.check_bit(1):
            self.admins = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = InputUser()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.admins.append(elem_of_1_vec)
        self.max_id = data.unpack_int64()
        self.min_id = data.unpack_int64()
        self.limit = data.unpack_int32()
        return self

class channels_AdminLogResults(TLObject):
    DERIVED_OBJECTS = {0xed8af74d: channels_adminLogResults, 0x33ddf480: channels_getAdminLog}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelAdminLogEventsFilter(TLObject):
    ID = 0xea107ae4
    def __init__(self, flags = None, join = None, leave = None, invite = None, ban = None, unban = None, kick = None, unkick = None, promote = None, demote = None, info = None, settings = None, pinned = None, edit = None, delete = None, group_call = None, invites = None):
        self.flags = flags
        self.join = join
        self.leave = leave
        self.invite = invite
        self.ban = ban
        self.unban = unban
        self.kick = kick
        self.unkick = unkick
        self.promote = promote
        self.demote = demote
        self.info = info
        self.settings = settings
        self.pinned = pinned
        self.edit = edit
        self.delete = delete
        self.group_call = group_call
        self.invites = invites
    def __str__(self):
        return 'channelAdminLogEventsFilter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.join:
            flags |= (1 << 0)
        if self.leave:
            flags |= (1 << 1)
        if self.invite:
            flags |= (1 << 2)
        if self.ban:
            flags |= (1 << 3)
        if self.unban:
            flags |= (1 << 4)
        if self.kick:
            flags |= (1 << 5)
        if self.unkick:
            flags |= (1 << 6)
        if self.promote:
            flags |= (1 << 7)
        if self.demote:
            flags |= (1 << 8)
        if self.info:
            flags |= (1 << 9)
        if self.settings:
            flags |= (1 << 10)
        if self.pinned:
            flags |= (1 << 11)
        if self.edit:
            flags |= (1 << 12)
        if self.delete:
            flags |= (1 << 13)
        if self.group_call:
            flags |= (1 << 14)
        if self.invites:
            flags |= (1 << 15)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.join = True
        if flags.check_bit(1):
            self.leave = True
        if flags.check_bit(2):
            self.invite = True
        if flags.check_bit(3):
            self.ban = True
        if flags.check_bit(4):
            self.unban = True
        if flags.check_bit(5):
            self.kick = True
        if flags.check_bit(6):
            self.unkick = True
        if flags.check_bit(7):
            self.promote = True
        if flags.check_bit(8):
            self.demote = True
        if flags.check_bit(9):
            self.info = True
        if flags.check_bit(10):
            self.settings = True
        if flags.check_bit(11):
            self.pinned = True
        if flags.check_bit(12):
            self.edit = True
        if flags.check_bit(13):
            self.delete = True
        if flags.check_bit(14):
            self.group_call = True
        if flags.check_bit(15):
            self.invites = True
        return self

class ChannelAdminLogEventsFilter(TLObject):
    DERIVED_OBJECTS = {0xea107ae4: channelAdminLogEventsFilter}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class popularContact(TLObject):
    ID = 0x5ce14175
    def __init__(self, client_id = None, importers = None):
        self.client_id = client_id
        self.importers = importers
    def __str__(self):
        return 'popularContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.client_id)
        stream.pack_int32(self.importers)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.client_id = data.unpack_int64()
        self.importers = data.unpack_int32()
        return self

class PopularContact(TLObject):
    DERIVED_OBJECTS = {0x5ce14175: popularContact}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_favedStickersNotModified(TLObject):
    ID = 0x9e8fa6d3
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_favedStickersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_favedStickers(TLObject):
    ID = 0x2cb51097
    def __init__(self, hash = None, packs = None, stickers = None):
        self.hash = hash
        self.packs = packs
        self.stickers = stickers
    def __str__(self):
        return 'messages_favedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.packs))
        for vec_k_2 in self.packs:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.stickers))
        for vec_k_3 in self.stickers:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.packs = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerPack()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.packs.append(elem_of_1_vec)
        self.stickers = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Document()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.stickers.append(elem_of_2_vec)
        return self

class messages_getFavedStickers(TLObject):
    ID = 0x4f1aaa9
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'messages_getFavedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class messages_FavedStickers(TLObject):
    DERIVED_OBJECTS = {0x9e8fa6d3: messages_favedStickersNotModified, 0x2cb51097: messages_favedStickers, 0x4f1aaa9: messages_getFavedStickers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class recentMeUrlUnknown(TLObject):
    ID = 0x46e1d13d
    def __init__(self, url = None):
        self.url = url
    def __str__(self):
        return 'recentMeUrlUnknown'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        return self

class recentMeUrlUser(TLObject):
    ID = 0xb92c09e2
    def __init__(self, url = None, user_id = None):
        self.url = url
        self.user_id = user_id
    def __str__(self):
        return 'recentMeUrlUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int64(self.user_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.user_id = data.unpack_int64()
        return self

class recentMeUrlChat(TLObject):
    ID = 0xb2da71d2
    def __init__(self, url = None, chat_id = None):
        self.url = url
        self.chat_id = chat_id
    def __str__(self):
        return 'recentMeUrlChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int64(self.chat_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.chat_id = data.unpack_int64()
        return self

class recentMeUrlChatInvite(TLObject):
    ID = 0xeb49081d
    def __init__(self, url = None, chat_invite = None):
        self.url = url
        self.chat_invite = chat_invite
    def __str__(self):
        return 'recentMeUrlChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_bytes(self.chat_invite.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.chat_invite = ChatInvite()
        self.chat_invite = self.chat_invite.read(data)
        return self

class recentMeUrlStickerSet(TLObject):
    ID = 0xbc0a57dc
    def __init__(self, url = None, set = None):
        self.url = url
        self.set = set
    def __str__(self):
        return 'recentMeUrlStickerSet'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_bytes(self.set.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.set = StickerSetCovered()
        self.set = self.set.read(data)
        return self

class RecentMeUrl(TLObject):
    DERIVED_OBJECTS = {0x46e1d13d: recentMeUrlUnknown, 0xb92c09e2: recentMeUrlUser, 0xb2da71d2: recentMeUrlChat, 0xeb49081d: recentMeUrlChatInvite, 0xbc0a57dc: recentMeUrlStickerSet}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_recentMeUrls(TLObject):
    ID = 0xe0310d7
    def __init__(self, urls = None, chats = None, users = None):
        self.urls = urls
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'help_recentMeUrls'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.urls))
        for vec_k_2 in self.urls:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.urls = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = RecentMeUrl()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.urls.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class help_getRecentMeUrls(TLObject):
    ID = 0x3dc0f114
    def __init__(self, referer = None):
        self.referer = referer
    def __str__(self):
        return 'help_getRecentMeUrls'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.referer)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.referer = data.unpack_string()
        return self

class help_RecentMeUrls(TLObject):
    DERIVED_OBJECTS = {0xe0310d7: help_recentMeUrls, 0x3dc0f114: help_getRecentMeUrls}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputSingleMedia(TLObject):
    ID = 0x1cc6e91f
    def __init__(self, flags = None, media = None, random_id = None, message = None, entities = None):
        self.flags = flags
        self.media = media
        self.random_id = random_id
        self.message = message
        self.entities = entities
    def __str__(self):
        return 'inputSingleMedia'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.media.write())
        stream.pack_int64(self.random_id)
        stream.pack_string(self.message)
        flags = 0x0
        if self.entities:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.media = InputMedia()
        self.media = self.media.read(data)
        self.random_id = data.unpack_int64()
        self.message = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        return self

class InputSingleMedia(TLObject):
    DERIVED_OBJECTS = {0x1cc6e91f: inputSingleMedia}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class webAuthorization(TLObject):
    ID = 0xa6f8f452
    def __init__(self, hash = None, bot_id = None, domain = None, browser = None, platform = None, date_created = None, date_active = None, ip = None, region = None):
        self.hash = hash
        self.bot_id = bot_id
        self.domain = domain
        self.browser = browser
        self.platform = platform
        self.date_created = date_created
        self.date_active = date_active
        self.ip = ip
        self.region = region
    def __str__(self):
        return 'webAuthorization'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int64(self.bot_id)
        stream.pack_string(self.domain)
        stream.pack_string(self.browser)
        stream.pack_string(self.platform)
        stream.pack_int32(self.date_created)
        stream.pack_int32(self.date_active)
        stream.pack_string(self.ip)
        stream.pack_string(self.region)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.bot_id = data.unpack_int64()
        self.domain = data.unpack_string()
        self.browser = data.unpack_string()
        self.platform = data.unpack_string()
        self.date_created = data.unpack_int32()
        self.date_active = data.unpack_int32()
        self.ip = data.unpack_string()
        self.region = data.unpack_string()
        return self

class WebAuthorization(TLObject):
    DERIVED_OBJECTS = {0xa6f8f452: webAuthorization}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_webAuthorizations(TLObject):
    ID = 0xed56c9fc
    def __init__(self, authorizations = None, users = None):
        self.authorizations = authorizations
        self.users = users
    def __str__(self):
        return 'account_webAuthorizations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.authorizations))
        for vec_k_2 in self.authorizations:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.authorizations = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = WebAuthorization()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.authorizations.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class account_getWebAuthorizations(TLObject):
    ID = 0x182e6d6f
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getWebAuthorizations'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_WebAuthorizations(TLObject):
    DERIVED_OBJECTS = {0xed56c9fc: account_webAuthorizations, 0x182e6d6f: account_getWebAuthorizations}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputMessageID(TLObject):
    ID = 0xa676a322
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputMessageID'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        return self

class inputMessageReplyTo(TLObject):
    ID = 0xbad88395
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputMessageReplyTo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        return self

class inputMessagePinned(TLObject):
    ID = 0x86872538
    def __init__(self):
        pass
    def __str__(self):
        return 'inputMessagePinned'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputMessageCallbackQuery(TLObject):
    ID = 0xacfa1a7e
    def __init__(self, id = None, query_id = None):
        self.id = id
        self.query_id = query_id
    def __str__(self):
        return 'inputMessageCallbackQuery'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.id)
        stream.pack_int64(self.query_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int32()
        self.query_id = data.unpack_int64()
        return self

class InputMessage(TLObject):
    DERIVED_OBJECTS = {0xa676a322: inputMessageID, 0xbad88395: inputMessageReplyTo, 0x86872538: inputMessagePinned, 0xacfa1a7e: inputMessageCallbackQuery}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputDialogPeer(TLObject):
    ID = 0xfcaafeb7
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'inputDialogPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class inputDialogPeerFolder(TLObject):
    ID = 0x64600527
    def __init__(self, folder_id = None):
        self.folder_id = folder_id
    def __str__(self):
        return 'inputDialogPeerFolder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.folder_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.folder_id = data.unpack_int32()
        return self

class InputDialogPeer(TLObject):
    DERIVED_OBJECTS = {0xfcaafeb7: inputDialogPeer, 0x64600527: inputDialogPeerFolder}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class dialogPeer(TLObject):
    ID = 0xe56dbf05
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'dialogPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        return self

class dialogPeerFolder(TLObject):
    ID = 0x514519e2
    def __init__(self, folder_id = None):
        self.folder_id = folder_id
    def __str__(self):
        return 'dialogPeerFolder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.folder_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.folder_id = data.unpack_int32()
        return self

class DialogPeer(TLObject):
    DERIVED_OBJECTS = {0xe56dbf05: dialogPeer, 0x514519e2: dialogPeerFolder}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_foundStickerSetsNotModified(TLObject):
    ID = 0xd54b65d
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_foundStickerSetsNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_foundStickerSets(TLObject):
    ID = 0x8af09dd2
    def __init__(self, hash = None, sets = None):
        self.hash = hash
        self.sets = sets
    def __str__(self):
        return 'messages_foundStickerSets'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sets))
        for vec_k_2 in self.sets:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.sets = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StickerSetCovered()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.sets.append(elem_of_1_vec)
        return self

class messages_searchStickerSets(TLObject):
    ID = 0x35705b8a
    def __init__(self, flags = None, exclude_featured = None, q = None, hash = None):
        self.flags = flags
        self.exclude_featured = exclude_featured
        self.q = q
        self.hash = hash
    def __str__(self):
        return 'messages_searchStickerSets'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.exclude_featured:
            flags |= (1 << 0)
        stream.pack_string(self.q)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.exclude_featured = True
        self.q = data.unpack_string()
        self.hash = data.unpack_int64()
        return self

class messages_FoundStickerSets(TLObject):
    DERIVED_OBJECTS = {0xd54b65d: messages_foundStickerSetsNotModified, 0x8af09dd2: messages_foundStickerSets, 0x35705b8a: messages_searchStickerSets}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class fileHash(TLObject):
    ID = 0x6242c773
    def __init__(self, offset = None, limit = None, hash = None):
        self.offset = offset
        self.limit = limit
        self.hash = hash
    def __str__(self):
        return 'fileHash'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.offset)
        stream.pack_int32(self.limit)
        stream.pack_string(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.offset = data.unpack_int32()
        self.limit = data.unpack_int32()
        self.hash = data.unpack_string()
        return self

class FileHash(TLObject):
    DERIVED_OBJECTS = {0x6242c773: fileHash}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputClientProxy(TLObject):
    ID = 0x75588b3f
    def __init__(self, address = None, port = None):
        self.address = address
        self.port = port
    def __str__(self):
        return 'inputClientProxy'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.address)
        stream.pack_int32(self.port)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.address = data.unpack_string()
        self.port = data.unpack_int32()
        return self

class InputClientProxy(TLObject):
    DERIVED_OBJECTS = {0x75588b3f: inputClientProxy}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_termsOfServiceUpdateEmpty(TLObject):
    ID = 0xe3309f7f
    def __init__(self, expires = None):
        self.expires = expires
    def __str__(self):
        return 'help_termsOfServiceUpdateEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.expires)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.expires = data.unpack_int32()
        return self

class help_termsOfServiceUpdate(TLObject):
    ID = 0x28ecf961
    def __init__(self, expires = None, terms_of_service = None):
        self.expires = expires
        self.terms_of_service = terms_of_service
    def __str__(self):
        return 'help_termsOfServiceUpdate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.expires)
        stream.pack_bytes(self.terms_of_service.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.expires = data.unpack_int32()
        self.terms_of_service = help_TermsOfService()
        self.terms_of_service = self.terms_of_service.read(data)
        return self

class help_getTermsOfServiceUpdate(TLObject):
    ID = 0x2ca51fd1
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getTermsOfServiceUpdate'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_TermsOfServiceUpdate(TLObject):
    DERIVED_OBJECTS = {0xe3309f7f: help_termsOfServiceUpdateEmpty, 0x28ecf961: help_termsOfServiceUpdate, 0x2ca51fd1: help_getTermsOfServiceUpdate}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputSecureFileUploaded(TLObject):
    ID = 0x3334b0f0
    def __init__(self, id = None, parts = None, md5_checksum = None, file_hash = None, secret = None):
        self.id = id
        self.parts = parts
        self.md5_checksum = md5_checksum
        self.file_hash = file_hash
        self.secret = secret
    def __str__(self):
        return 'inputSecureFileUploaded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int32(self.parts)
        stream.pack_string(self.md5_checksum)
        stream.pack_string(self.file_hash)
        stream.pack_string(self.secret)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.parts = data.unpack_int32()
        self.md5_checksum = data.unpack_string()
        self.file_hash = data.unpack_string()
        self.secret = data.unpack_string()
        return self

class inputSecureFile(TLObject):
    ID = 0x5367e5be
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputSecureFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class InputSecureFile(TLObject):
    DERIVED_OBJECTS = {0x3334b0f0: inputSecureFileUploaded, 0x5367e5be: inputSecureFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureFileEmpty(TLObject):
    ID = 0x64199744
    def __init__(self):
        pass
    def __str__(self):
        return 'secureFileEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureFile(TLObject):
    ID = 0xe0277a62
    def __init__(self, id = None, access_hash = None, size = None, dc_id = None, date = None, file_hash = None, secret = None):
        self.id = id
        self.access_hash = access_hash
        self.size = size
        self.dc_id = dc_id
        self.date = date
        self.file_hash = file_hash
        self.secret = secret
    def __str__(self):
        return 'secureFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.size)
        stream.pack_int32(self.dc_id)
        stream.pack_int32(self.date)
        stream.pack_string(self.file_hash)
        stream.pack_string(self.secret)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.size = data.unpack_int32()
        self.dc_id = data.unpack_int32()
        self.date = data.unpack_int32()
        self.file_hash = data.unpack_string()
        self.secret = data.unpack_string()
        return self

class SecureFile(TLObject):
    DERIVED_OBJECTS = {0x64199744: secureFileEmpty, 0xe0277a62: secureFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureData(TLObject):
    ID = 0x8aeabec3
    def __init__(self, data = None, data_hash = None, secret = None):
        self.data = data
        self.data_hash = data_hash
        self.secret = secret
    def __str__(self):
        return 'secureData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.data)
        stream.pack_string(self.data_hash)
        stream.pack_string(self.secret)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.data = data.unpack_string()
        self.data_hash = data.unpack_string()
        self.secret = data.unpack_string()
        return self

class SecureData(TLObject):
    DERIVED_OBJECTS = {0x8aeabec3: secureData}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class securePlainPhone(TLObject):
    ID = 0x7d6099dd
    def __init__(self, phone = None):
        self.phone = phone
    def __str__(self):
        return 'securePlainPhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone = data.unpack_string()
        return self

class securePlainEmail(TLObject):
    ID = 0x21ec5a5f
    def __init__(self, email = None):
        self.email = email
    def __str__(self):
        return 'securePlainEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.email)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.email = data.unpack_string()
        return self

class SecurePlainData(TLObject):
    DERIVED_OBJECTS = {0x7d6099dd: securePlainPhone, 0x21ec5a5f: securePlainEmail}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureValueTypePersonalDetails(TLObject):
    ID = 0x9d2a81e3
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypePersonalDetails'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypePassport(TLObject):
    ID = 0x3dac6a00
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypePassport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeDriverLicense(TLObject):
    ID = 0x6e425c4
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeDriverLicense'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeIdentityCard(TLObject):
    ID = 0xa0d0744b
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeIdentityCard'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeInternalPassport(TLObject):
    ID = 0x99a48f23
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeInternalPassport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeAddress(TLObject):
    ID = 0xcbe31e26
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeAddress'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeUtilityBill(TLObject):
    ID = 0xfc36954e
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeUtilityBill'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeBankStatement(TLObject):
    ID = 0x89137c0d
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeBankStatement'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeRentalAgreement(TLObject):
    ID = 0x8b883488
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeRentalAgreement'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypePassportRegistration(TLObject):
    ID = 0x99e3806a
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypePassportRegistration'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeTemporaryRegistration(TLObject):
    ID = 0xea02ec33
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeTemporaryRegistration'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypePhone(TLObject):
    ID = 0xb320aadb
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypePhone'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class secureValueTypeEmail(TLObject):
    ID = 0x8e3ca7ee
    def __init__(self):
        pass
    def __str__(self):
        return 'secureValueTypeEmail'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class SecureValueType(TLObject):
    DERIVED_OBJECTS = {0x9d2a81e3: secureValueTypePersonalDetails, 0x3dac6a00: secureValueTypePassport, 0x6e425c4: secureValueTypeDriverLicense, 0xa0d0744b: secureValueTypeIdentityCard, 0x99a48f23: secureValueTypeInternalPassport, 0xcbe31e26: secureValueTypeAddress, 0xfc36954e: secureValueTypeUtilityBill, 0x89137c0d: secureValueTypeBankStatement, 0x8b883488: secureValueTypeRentalAgreement, 0x99e3806a: secureValueTypePassportRegistration, 0xea02ec33: secureValueTypeTemporaryRegistration, 0xb320aadb: secureValueTypePhone, 0x8e3ca7ee: secureValueTypeEmail}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureValue(TLObject):
    ID = 0x187fa0ca
    def __init__(self, flags = None, type = None, data = None, front_side = None, reverse_side = None, selfie = None, translation = None, files = None, plain_data = None, hash = None):
        self.flags = flags
        self.type = type
        self.data = data
        self.front_side = front_side
        self.reverse_side = reverse_side
        self.selfie = selfie
        self.translation = translation
        self.files = files
        self.plain_data = plain_data
        self.hash = hash
    def __str__(self):
        return 'secureValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        flags = 0x0
        if self.data:
            flags |= (1 << 0)
            stream.pack_bytes(self.data.write())
        if self.front_side:
            flags |= (1 << 1)
            stream.pack_bytes(self.front_side.write())
        if self.reverse_side:
            flags |= (1 << 2)
            stream.pack_bytes(self.reverse_side.write())
        if self.selfie:
            flags |= (1 << 3)
            stream.pack_bytes(self.selfie.write())
        if self.translation:
            flags |= (1 << 6)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.translation))
            for vec_k_2 in self.translation:
                stream.pack_bytes(vec_k_2.write())
        if self.files:
            flags |= (1 << 4)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.files))
            for vec_k_3 in self.files:
                stream.pack_bytes(vec_k_3.write())
        if self.plain_data:
            flags |= (1 << 5)
            stream.pack_bytes(self.plain_data.write())
        stream.pack_string(self.hash)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.data = SecureData()
            self.data = self.data.read(data)
        if flags.check_bit(1):
            self.front_side = SecureFile()
            self.front_side = self.front_side.read(data)
        if flags.check_bit(2):
            self.reverse_side = SecureFile()
            self.reverse_side = self.reverse_side.read(data)
        if flags.check_bit(3):
            self.selfie = SecureFile()
            self.selfie = self.selfie.read(data)
        if flags.check_bit(6):
            self.translation = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = SecureFile()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.translation.append(elem_of_1_vec)
        if flags.check_bit(4):
            self.files = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = SecureFile()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.files.append(elem_of_2_vec)
        if flags.check_bit(5):
            self.plain_data = SecurePlainData()
            self.plain_data = self.plain_data.read(data)
        self.hash = data.unpack_string()
        return self

class account_saveSecureValue(TLObject):
    ID = 0x899fe31d
    def __init__(self, value = None, secure_secret_id = None):
        self.value = value
        self.secure_secret_id = secure_secret_id
    def __str__(self):
        return 'account_saveSecureValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.value.write())
        stream.pack_int64(self.secure_secret_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = InputSecureValue()
        self.value = self.value.read(data)
        self.secure_secret_id = data.unpack_int64()
        return self

class SecureValue(TLObject):
    DERIVED_OBJECTS = {0x187fa0ca: secureValue, 0x899fe31d: account_saveSecureValue}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputSecureValue(TLObject):
    ID = 0xdb21d0a7
    def __init__(self, flags = None, type = None, data = None, front_side = None, reverse_side = None, selfie = None, translation = None, files = None, plain_data = None):
        self.flags = flags
        self.type = type
        self.data = data
        self.front_side = front_side
        self.reverse_side = reverse_side
        self.selfie = selfie
        self.translation = translation
        self.files = files
        self.plain_data = plain_data
    def __str__(self):
        return 'inputSecureValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        flags = 0x0
        if self.data:
            flags |= (1 << 0)
            stream.pack_bytes(self.data.write())
        if self.front_side:
            flags |= (1 << 1)
            stream.pack_bytes(self.front_side.write())
        if self.reverse_side:
            flags |= (1 << 2)
            stream.pack_bytes(self.reverse_side.write())
        if self.selfie:
            flags |= (1 << 3)
            stream.pack_bytes(self.selfie.write())
        if self.translation:
            flags |= (1 << 6)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.translation))
            for vec_k_2 in self.translation:
                stream.pack_bytes(vec_k_2.write())
        if self.files:
            flags |= (1 << 4)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.files))
            for vec_k_3 in self.files:
                stream.pack_bytes(vec_k_3.write())
        if self.plain_data:
            flags |= (1 << 5)
            stream.pack_bytes(self.plain_data.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.data = SecureData()
            self.data = self.data.read(data)
        if flags.check_bit(1):
            self.front_side = InputSecureFile()
            self.front_side = self.front_side.read(data)
        if flags.check_bit(2):
            self.reverse_side = InputSecureFile()
            self.reverse_side = self.reverse_side.read(data)
        if flags.check_bit(3):
            self.selfie = InputSecureFile()
            self.selfie = self.selfie.read(data)
        if flags.check_bit(6):
            self.translation = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = InputSecureFile()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.translation.append(elem_of_1_vec)
        if flags.check_bit(4):
            self.files = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                elem_of_2_vec = InputSecureFile()
                elem_of_2_vec = elem_of_2_vec.read(data)
                self.files.append(elem_of_2_vec)
        if flags.check_bit(5):
            self.plain_data = SecurePlainData()
            self.plain_data = self.plain_data.read(data)
        return self

class InputSecureValue(TLObject):
    DERIVED_OBJECTS = {0xdb21d0a7: inputSecureValue}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureValueHash(TLObject):
    ID = 0xed1ecdb0
    def __init__(self, type = None, hash = None):
        self.type = type
        self.hash = hash
    def __str__(self):
        return 'secureValueHash'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.hash = data.unpack_string()
        return self

class SecureValueHash(TLObject):
    DERIVED_OBJECTS = {0xed1ecdb0: secureValueHash}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureValueErrorData(TLObject):
    ID = 0xe8a40bd9
    def __init__(self, type = None, data_hash = None, field = None, text = None):
        self.type = type
        self.data_hash = data_hash
        self.field = field
        self.text = text
    def __str__(self):
        return 'secureValueErrorData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.data_hash)
        stream.pack_string(self.field)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.data_hash = data.unpack_string()
        self.field = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorFrontSide(TLObject):
    ID = 0xbe3dfa
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorFrontSide'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.file_hash)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorReverseSide(TLObject):
    ID = 0x868a2aa5
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorReverseSide'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.file_hash)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorSelfie(TLObject):
    ID = 0xe537ced6
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorSelfie'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.file_hash)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorFile(TLObject):
    ID = 0x7a700873
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.file_hash)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorFiles(TLObject):
    ID = 0x666220e9
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorFiles'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.file_hash))
        for vec_k_2 in self.file_hash:
            stream.pack_string(vec_k_2)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.file_hash.append(data.unpack_string())
        self.text = data.unpack_string()
        return self

class secureValueError(TLObject):
    ID = 0x869d758f
    def __init__(self, type = None, hash = None, text = None):
        self.type = type
        self.hash = hash
        self.text = text
    def __str__(self):
        return 'secureValueError'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.hash)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.hash = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorTranslationFile(TLObject):
    ID = 0xa1144770
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorTranslationFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_string(self.file_hash)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = data.unpack_string()
        self.text = data.unpack_string()
        return self

class secureValueErrorTranslationFiles(TLObject):
    ID = 0x34636dd8
    def __init__(self, type = None, file_hash = None, text = None):
        self.type = type
        self.file_hash = file_hash
        self.text = text
    def __str__(self):
        return 'secureValueErrorTranslationFiles'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.type.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.file_hash))
        for vec_k_2 in self.file_hash:
            stream.pack_string(vec_k_2)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.type = SecureValueType()
        self.type = self.type.read(data)
        self.file_hash = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.file_hash.append(data.unpack_string())
        self.text = data.unpack_string()
        return self

class SecureValueError(TLObject):
    DERIVED_OBJECTS = {0xe8a40bd9: secureValueErrorData, 0xbe3dfa: secureValueErrorFrontSide, 0x868a2aa5: secureValueErrorReverseSide, 0xe537ced6: secureValueErrorSelfie, 0x7a700873: secureValueErrorFile, 0x666220e9: secureValueErrorFiles, 0x869d758f: secureValueError, 0xa1144770: secureValueErrorTranslationFile, 0x34636dd8: secureValueErrorTranslationFiles}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureCredentialsEncrypted(TLObject):
    ID = 0x33f0ea47
    def __init__(self, data = None, hash = None, secret = None):
        self.data = data
        self.hash = hash
        self.secret = secret
    def __str__(self):
        return 'secureCredentialsEncrypted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.data)
        stream.pack_string(self.hash)
        stream.pack_string(self.secret)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.data = data.unpack_string()
        self.hash = data.unpack_string()
        self.secret = data.unpack_string()
        return self

class SecureCredentialsEncrypted(TLObject):
    DERIVED_OBJECTS = {0x33f0ea47: secureCredentialsEncrypted}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_authorizationForm(TLObject):
    ID = 0xad2e1cd8
    def __init__(self, flags = None, required_types = None, values = None, errors = None, users = None, privacy_policy_url = None):
        self.flags = flags
        self.required_types = required_types
        self.values = values
        self.errors = errors
        self.users = users
        self.privacy_policy_url = privacy_policy_url
    def __str__(self):
        return 'account_authorizationForm'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.required_types))
        for vec_k_2 in self.required_types:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.values))
        for vec_k_3 in self.values:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.errors))
        for vec_k_4 in self.errors:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        flags = 0x0
        if self.privacy_policy_url:
            flags |= (1 << 0)
            stream.pack_string(self.privacy_policy_url)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.required_types = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureRequiredType()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.required_types.append(elem_of_1_vec)
        self.values = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = SecureValue()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.values.append(elem_of_2_vec)
        self.errors = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = SecureValueError()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.errors.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.privacy_policy_url = data.unpack_string()
        return self

class account_getAuthorizationForm(TLObject):
    ID = 0xa929597a
    def __init__(self, bot_id = None, scope = None, public_key = None):
        self.bot_id = bot_id
        self.scope = scope
        self.public_key = public_key
    def __str__(self):
        return 'account_getAuthorizationForm'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.bot_id)
        stream.pack_string(self.scope)
        stream.pack_string(self.public_key)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.bot_id = data.unpack_int64()
        self.scope = data.unpack_string()
        self.public_key = data.unpack_string()
        return self

class account_AuthorizationForm(TLObject):
    DERIVED_OBJECTS = {0xad2e1cd8: account_authorizationForm, 0xa929597a: account_getAuthorizationForm}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_sentEmailCode(TLObject):
    ID = 0x811f854f
    def __init__(self, email_pattern = None, length = None):
        self.email_pattern = email_pattern
        self.length = length
    def __str__(self):
        return 'account_sentEmailCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.email_pattern)
        stream.pack_int32(self.length)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.email_pattern = data.unpack_string()
        self.length = data.unpack_int32()
        return self

class account_sendVerifyEmailCode(TLObject):
    ID = 0x7011509f
    def __init__(self, email = None):
        self.email = email
    def __str__(self):
        return 'account_sendVerifyEmailCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.email)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.email = data.unpack_string()
        return self

class account_SentEmailCode(TLObject):
    DERIVED_OBJECTS = {0x811f854f: account_sentEmailCode, 0x7011509f: account_sendVerifyEmailCode}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_deepLinkInfoEmpty(TLObject):
    ID = 0x66afa166
    def __init__(self):
        pass
    def __str__(self):
        return 'help_deepLinkInfoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_deepLinkInfo(TLObject):
    ID = 0x6a4ee832
    def __init__(self, flags = None, update_app = None, message = None, entities = None):
        self.flags = flags
        self.update_app = update_app
        self.message = message
        self.entities = entities
    def __str__(self):
        return 'help_deepLinkInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.update_app:
            flags |= (1 << 0)
        stream.pack_string(self.message)
        if self.entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.update_app = True
        self.message = data.unpack_string()
        if flags.check_bit(1):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        return self

class help_getDeepLinkInfo(TLObject):
    ID = 0x3fedc75f
    def __init__(self, path = None):
        self.path = path
    def __str__(self):
        return 'help_getDeepLinkInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.path)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.path = data.unpack_string()
        return self

class help_DeepLinkInfo(TLObject):
    DERIVED_OBJECTS = {0x66afa166: help_deepLinkInfoEmpty, 0x6a4ee832: help_deepLinkInfo, 0x3fedc75f: help_getDeepLinkInfo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class savedPhoneContact(TLObject):
    ID = 0x1142bd56
    def __init__(self, phone = None, first_name = None, last_name = None, date = None):
        self.phone = phone
        self.first_name = first_name
        self.last_name = last_name
        self.date = date
    def __str__(self):
        return 'savedPhoneContact'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.phone)
        stream.pack_string(self.first_name)
        stream.pack_string(self.last_name)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.phone = data.unpack_string()
        self.first_name = data.unpack_string()
        self.last_name = data.unpack_string()
        self.date = data.unpack_int32()
        return self

class SavedContact(TLObject):
    DERIVED_OBJECTS = {0x1142bd56: savedPhoneContact}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_takeout(TLObject):
    ID = 0x4dba4501
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'account_takeout'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class account_initTakeoutSession(TLObject):
    ID = 0xf05b4804
    def __init__(self, flags = None, contacts = None, message_users = None, message_chats = None, message_megagroups = None, message_channels = None, files = None, file_max_size = None):
        self.flags = flags
        self.contacts = contacts
        self.message_users = message_users
        self.message_chats = message_chats
        self.message_megagroups = message_megagroups
        self.message_channels = message_channels
        self.files = files
        self.file_max_size = file_max_size
    def __str__(self):
        return 'account_initTakeoutSession'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.contacts:
            flags |= (1 << 0)
        if self.message_users:
            flags |= (1 << 1)
        if self.message_chats:
            flags |= (1 << 2)
        if self.message_megagroups:
            flags |= (1 << 3)
        if self.message_channels:
            flags |= (1 << 4)
        if self.files:
            flags |= (1 << 5)
        if self.file_max_size:
            flags |= (1 << 5)
            stream.pack_int32(self.file_max_size)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.contacts = True
        if flags.check_bit(1):
            self.message_users = True
        if flags.check_bit(2):
            self.message_chats = True
        if flags.check_bit(3):
            self.message_megagroups = True
        if flags.check_bit(4):
            self.message_channels = True
        if flags.check_bit(5):
            self.files = True
        if flags.check_bit(5):
            self.file_max_size = data.unpack_int32()
        return self

class account_Takeout(TLObject):
    DERIVED_OBJECTS = {0x4dba4501: account_takeout, 0xf05b4804: account_initTakeoutSession}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class passwordKdfAlgoUnknown(TLObject):
    ID = 0xd45ab096
    def __init__(self):
        pass
    def __str__(self):
        return 'passwordKdfAlgoUnknown'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow(TLObject):
    ID = 0x3a912d4a
    def __init__(self, salt1 = None, salt2 = None, g = None, p = None):
        self.salt1 = salt1
        self.salt2 = salt2
        self.g = g
        self.p = p
    def __str__(self):
        return 'passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.salt1)
        stream.pack_string(self.salt2)
        stream.pack_int32(self.g)
        stream.pack_string(self.p)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.salt1 = data.unpack_string()
        self.salt2 = data.unpack_string()
        self.g = data.unpack_int32()
        self.p = data.unpack_string()
        return self

class PasswordKdfAlgo(TLObject):
    DERIVED_OBJECTS = {0xd45ab096: passwordKdfAlgoUnknown, 0x3a912d4a: passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class securePasswordKdfAlgoUnknown(TLObject):
    ID = 0x4a8537
    def __init__(self):
        pass
    def __str__(self):
        return 'securePasswordKdfAlgoUnknown'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class securePasswordKdfAlgoPBKDF2HMACSHA512iter100000(TLObject):
    ID = 0xbbf2dda0
    def __init__(self, salt = None):
        self.salt = salt
    def __str__(self):
        return 'securePasswordKdfAlgoPBKDF2HMACSHA512iter100000'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.salt)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.salt = data.unpack_string()
        return self

class securePasswordKdfAlgoSHA512(TLObject):
    ID = 0x86471d92
    def __init__(self, salt = None):
        self.salt = salt
    def __str__(self):
        return 'securePasswordKdfAlgoSHA512'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.salt)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.salt = data.unpack_string()
        return self

class SecurePasswordKdfAlgo(TLObject):
    DERIVED_OBJECTS = {0x4a8537: securePasswordKdfAlgoUnknown, 0xbbf2dda0: securePasswordKdfAlgoPBKDF2HMACSHA512iter100000, 0x86471d92: securePasswordKdfAlgoSHA512}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureSecretSettings(TLObject):
    ID = 0x1527bcac
    def __init__(self, secure_algo = None, secure_secret = None, secure_secret_id = None):
        self.secure_algo = secure_algo
        self.secure_secret = secure_secret
        self.secure_secret_id = secure_secret_id
    def __str__(self):
        return 'secureSecretSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.secure_algo.write())
        stream.pack_string(self.secure_secret)
        stream.pack_int64(self.secure_secret_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.secure_algo = SecurePasswordKdfAlgo()
        self.secure_algo = self.secure_algo.read(data)
        self.secure_secret = data.unpack_string()
        self.secure_secret_id = data.unpack_int64()
        return self

class SecureSecretSettings(TLObject):
    DERIVED_OBJECTS = {0x1527bcac: secureSecretSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputCheckPasswordEmpty(TLObject):
    ID = 0x9880f658
    def __init__(self):
        pass
    def __str__(self):
        return 'inputCheckPasswordEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inputCheckPasswordSRP(TLObject):
    ID = 0xd27ff082
    def __init__(self, srp_id = None, A = None, M1 = None):
        self.srp_id = srp_id
        self.A = A
        self.M1 = M1
    def __str__(self):
        return 'inputCheckPasswordSRP'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.srp_id)
        stream.pack_string(self.A)
        stream.pack_string(self.M1)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.srp_id = data.unpack_int64()
        self.A = data.unpack_string()
        self.M1 = data.unpack_string()
        return self

class InputCheckPasswordSRP(TLObject):
    DERIVED_OBJECTS = {0x9880f658: inputCheckPasswordEmpty, 0xd27ff082: inputCheckPasswordSRP}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class secureRequiredType(TLObject):
    ID = 0x829d99da
    def __init__(self, flags = None, native_names = None, selfie_required = None, translation_required = None, type = None):
        self.flags = flags
        self.native_names = native_names
        self.selfie_required = selfie_required
        self.translation_required = translation_required
        self.type = type
    def __str__(self):
        return 'secureRequiredType'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.native_names:
            flags |= (1 << 0)
        if self.selfie_required:
            flags |= (1 << 1)
        if self.translation_required:
            flags |= (1 << 2)
        stream.pack_bytes(self.type.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.native_names = True
        if flags.check_bit(1):
            self.selfie_required = True
        if flags.check_bit(2):
            self.translation_required = True
        self.type = SecureValueType()
        self.type = self.type.read(data)
        return self

class secureRequiredTypeOneOf(TLObject):
    ID = 0x27477b4
    def __init__(self, types = None):
        self.types = types
    def __str__(self):
        return 'secureRequiredTypeOneOf'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.types))
        for vec_k_2 in self.types:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.types = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureRequiredType()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.types.append(elem_of_1_vec)
        return self

class SecureRequiredType(TLObject):
    DERIVED_OBJECTS = {0x829d99da: secureRequiredType, 0x27477b4: secureRequiredTypeOneOf}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_passportConfigNotModified(TLObject):
    ID = 0xbfb9f457
    def __init__(self):
        pass
    def __str__(self):
        return 'help_passportConfigNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_passportConfig(TLObject):
    ID = 0xa098d6af
    def __init__(self, hash = None, countries_langs = None):
        self.hash = hash
        self.countries_langs = countries_langs
    def __str__(self):
        return 'help_passportConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.hash)
        stream.pack_bytes(self.countries_langs.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int32()
        self.countries_langs = DataJSON()
        self.countries_langs = self.countries_langs.read(data)
        return self

class help_getPassportConfig(TLObject):
    ID = 0xc661ad08
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'help_getPassportConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int32()
        return self

class help_PassportConfig(TLObject):
    DERIVED_OBJECTS = {0xbfb9f457: help_passportConfigNotModified, 0xa098d6af: help_passportConfig, 0xc661ad08: help_getPassportConfig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputAppEvent(TLObject):
    ID = 0x1d1b1245
    def __init__(self, time = None, type = None, peer = None, data = None):
        self.time = time
        self.type = type
        self.peer = peer
        self.data = data
    def __str__(self):
        return 'inputAppEvent'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_double(self.time)
        stream.pack_string(self.type)
        stream.pack_int64(self.peer)
        stream.pack_bytes(self.data.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.time = data.unpack_double()
        self.type = data.unpack_string()
        self.peer = data.unpack_int64()
        self.data = JSONValue()
        self.data = self.data.read(data)
        return self

class InputAppEvent(TLObject):
    DERIVED_OBJECTS = {0x1d1b1245: inputAppEvent}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class jsonObjectValue(TLObject):
    ID = 0xc0de1bd9
    def __init__(self, key = None, value = None):
        self.key = key
        self.value = value
    def __str__(self):
        return 'jsonObjectValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.key)
        stream.pack_bytes(self.value.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.key = data.unpack_string()
        self.value = JSONValue()
        self.value = self.value.read(data)
        return self

class JSONObjectValue(TLObject):
    DERIVED_OBJECTS = {0xc0de1bd9: jsonObjectValue}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class jsonNull(TLObject):
    ID = 0x3f6d7b68
    def __init__(self):
        pass
    def __str__(self):
        return 'jsonNull'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class jsonBool(TLObject):
    ID = 0xc7345e6a
    def __init__(self, value = None):
        self.value = value
    def __str__(self):
        return 'jsonBool'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.value.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = Bool()
        self.value = self.value.read(data)
        return self

class jsonNumber(TLObject):
    ID = 0x2be0dfa4
    def __init__(self, value = None):
        self.value = value
    def __str__(self):
        return 'jsonNumber'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_double(self.value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = data.unpack_double()
        return self

class jsonString(TLObject):
    ID = 0xb71e767a
    def __init__(self, value = None):
        self.value = value
    def __str__(self):
        return 'jsonString'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.value)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = data.unpack_string()
        return self

class jsonArray(TLObject):
    ID = 0xf7444763
    def __init__(self, value = None):
        self.value = value
    def __str__(self):
        return 'jsonArray'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.value))
        for vec_k_2 in self.value:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = JSONValue()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.value.append(elem_of_1_vec)
        return self

class jsonObject(TLObject):
    ID = 0x99c1d49d
    def __init__(self, value = None):
        self.value = value
    def __str__(self):
        return 'jsonObject'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.value))
        for vec_k_2 in self.value:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.value = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = JSONObjectValue()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.value.append(elem_of_1_vec)
        return self

class help_getAppConfig(TLObject):
    ID = 0x98914110
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getAppConfig'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class JSONValue(TLObject):
    DERIVED_OBJECTS = {0x3f6d7b68: jsonNull, 0xc7345e6a: jsonBool, 0x2be0dfa4: jsonNumber, 0xb71e767a: jsonString, 0xf7444763: jsonArray, 0x99c1d49d: jsonObject, 0x98914110: help_getAppConfig}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageTableCell(TLObject):
    ID = 0x34566b6a
    def __init__(self, flags = None, header = None, align_center = None, align_right = None, valign_middle = None, valign_bottom = None, text = None, colspan = None, rowspan = None):
        self.flags = flags
        self.header = header
        self.align_center = align_center
        self.align_right = align_right
        self.valign_middle = valign_middle
        self.valign_bottom = valign_bottom
        self.text = text
        self.colspan = colspan
        self.rowspan = rowspan
    def __str__(self):
        return 'pageTableCell'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.header:
            flags |= (1 << 0)
        if self.align_center:
            flags |= (1 << 3)
        if self.align_right:
            flags |= (1 << 4)
        if self.valign_middle:
            flags |= (1 << 5)
        if self.valign_bottom:
            flags |= (1 << 6)
        if self.text:
            flags |= (1 << 7)
            stream.pack_bytes(self.text.write())
        if self.colspan:
            flags |= (1 << 1)
            stream.pack_int32(self.colspan)
        if self.rowspan:
            flags |= (1 << 2)
            stream.pack_int32(self.rowspan)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.header = True
        if flags.check_bit(3):
            self.align_center = True
        if flags.check_bit(4):
            self.align_right = True
        if flags.check_bit(5):
            self.valign_middle = True
        if flags.check_bit(6):
            self.valign_bottom = True
        if flags.check_bit(7):
            self.text = RichText()
            self.text = self.text.read(data)
        if flags.check_bit(1):
            self.colspan = data.unpack_int32()
        if flags.check_bit(2):
            self.rowspan = data.unpack_int32()
        return self

class PageTableCell(TLObject):
    DERIVED_OBJECTS = {0x34566b6a: pageTableCell}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageTableRow(TLObject):
    ID = 0xe0c0c5e5
    def __init__(self, cells = None):
        self.cells = cells
    def __str__(self):
        return 'pageTableRow'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.cells))
        for vec_k_2 in self.cells:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.cells = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageTableCell()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.cells.append(elem_of_1_vec)
        return self

class PageTableRow(TLObject):
    DERIVED_OBJECTS = {0xe0c0c5e5: pageTableRow}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageCaption(TLObject):
    ID = 0x6f747657
    def __init__(self, text = None, credit = None):
        self.text = text
        self.credit = credit
    def __str__(self):
        return 'pageCaption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        stream.pack_bytes(self.credit.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        self.credit = RichText()
        self.credit = self.credit.read(data)
        return self

class PageCaption(TLObject):
    DERIVED_OBJECTS = {0x6f747657: pageCaption}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageListItemText(TLObject):
    ID = 0xb92fb6cd
    def __init__(self, text = None):
        self.text = text
    def __str__(self):
        return 'pageListItemText'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageListItemBlocks(TLObject):
    ID = 0x25e073fc
    def __init__(self, blocks = None):
        self.blocks = blocks
    def __str__(self):
        return 'pageListItemBlocks'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocks))
        for vec_k_2 in self.blocks:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.blocks = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocks.append(elem_of_1_vec)
        return self

class PageListItem(TLObject):
    DERIVED_OBJECTS = {0xb92fb6cd: pageListItemText, 0x25e073fc: pageListItemBlocks}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageListOrderedItemText(TLObject):
    ID = 0x5e068047
    def __init__(self, num = None, text = None):
        self.num = num
        self.text = text
    def __str__(self):
        return 'pageListOrderedItemText'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.num)
        stream.pack_bytes(self.text.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.num = data.unpack_string()
        self.text = RichText()
        self.text = self.text.read(data)
        return self

class pageListOrderedItemBlocks(TLObject):
    ID = 0x98dd8936
    def __init__(self, num = None, blocks = None):
        self.num = num
        self.blocks = blocks
    def __str__(self):
        return 'pageListOrderedItemBlocks'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.num)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocks))
        for vec_k_2 in self.blocks:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.num = data.unpack_string()
        self.blocks = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocks.append(elem_of_1_vec)
        return self

class PageListOrderedItem(TLObject):
    DERIVED_OBJECTS = {0x5e068047: pageListOrderedItemText, 0x98dd8936: pageListOrderedItemBlocks}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pageRelatedArticle(TLObject):
    ID = 0xb390dc08
    def __init__(self, flags = None, url = None, webpage_id = None, title = None, description = None, photo_id = None, author = None, published_date = None):
        self.flags = flags
        self.url = url
        self.webpage_id = webpage_id
        self.title = title
        self.description = description
        self.photo_id = photo_id
        self.author = author
        self.published_date = published_date
    def __str__(self):
        return 'pageRelatedArticle'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_int64(self.webpage_id)
        flags = 0x0
        if self.title:
            flags |= (1 << 0)
            stream.pack_string(self.title)
        if self.description:
            flags |= (1 << 1)
            stream.pack_string(self.description)
        if self.photo_id:
            flags |= (1 << 2)
            stream.pack_int64(self.photo_id)
        if self.author:
            flags |= (1 << 3)
            stream.pack_string(self.author)
        if self.published_date:
            flags |= (1 << 4)
            stream.pack_int32(self.published_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.url = data.unpack_string()
        self.webpage_id = data.unpack_int64()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.title = data.unpack_string()
        if flags.check_bit(1):
            self.description = data.unpack_string()
        if flags.check_bit(2):
            self.photo_id = data.unpack_int64()
        if flags.check_bit(3):
            self.author = data.unpack_string()
        if flags.check_bit(4):
            self.published_date = data.unpack_int32()
        return self

class PageRelatedArticle(TLObject):
    DERIVED_OBJECTS = {0xb390dc08: pageRelatedArticle}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class page(TLObject):
    ID = 0x98657f0d
    def __init__(self, flags = None, part = None, rtl = None, v2 = None, url = None, blocks = None, photos = None, documents = None, views = None):
        self.flags = flags
        self.part = part
        self.rtl = rtl
        self.v2 = v2
        self.url = url
        self.blocks = blocks
        self.photos = photos
        self.documents = documents
        self.views = views
    def __str__(self):
        return 'page'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.part:
            flags |= (1 << 0)
        if self.rtl:
            flags |= (1 << 1)
        if self.v2:
            flags |= (1 << 2)
        stream.pack_string(self.url)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.blocks))
        for vec_k_2 in self.blocks:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.photos))
        for vec_k_3 in self.photos:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.documents))
        for vec_k_4 in self.documents:
            stream.pack_bytes(vec_k_4.write())
        if self.views:
            flags |= (1 << 3)
            stream.pack_int32(self.views)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.part = True
        if flags.check_bit(1):
            self.rtl = True
        if flags.check_bit(2):
            self.v2 = True
        self.url = data.unpack_string()
        self.blocks = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PageBlock()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.blocks.append(elem_of_1_vec)
        self.photos = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Photo()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.photos.append(elem_of_2_vec)
        self.documents = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = Document()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.documents.append(elem_of_3_vec)
        if flags.check_bit(3):
            self.views = data.unpack_int32()
        return self

class Page(TLObject):
    DERIVED_OBJECTS = {0x98657f0d: page}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_supportName(TLObject):
    ID = 0x8c05f1c9
    def __init__(self, name = None):
        self.name = name
    def __str__(self):
        return 'help_supportName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.name = data.unpack_string()
        return self

class help_getSupportName(TLObject):
    ID = 0xd360e72c
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getSupportName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_SupportName(TLObject):
    DERIVED_OBJECTS = {0x8c05f1c9: help_supportName, 0xd360e72c: help_getSupportName}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_userInfoEmpty(TLObject):
    ID = 0xf3ae2eed
    def __init__(self):
        pass
    def __str__(self):
        return 'help_userInfoEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_userInfo(TLObject):
    ID = 0x1eb3758
    def __init__(self, message = None, entities = None, author = None, date = None):
        self.message = message
        self.entities = entities
        self.author = author
        self.date = date
    def __str__(self):
        return 'help_userInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.message)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.entities))
        for vec_k_2 in self.entities:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_string(self.author)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.message = data.unpack_string()
        self.entities = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageEntity()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.entities.append(elem_of_1_vec)
        self.author = data.unpack_string()
        self.date = data.unpack_int32()
        return self

class help_getUserInfo(TLObject):
    ID = 0x38a08d3
    def __init__(self, user_id = None):
        self.user_id = user_id
    def __str__(self):
        return 'help_getUserInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class help_editUserInfo(TLObject):
    ID = 0x66b91b70
    def __init__(self, user_id = None, message = None, entities = None):
        self.user_id = user_id
        self.message = message
        self.entities = entities
    def __str__(self):
        return 'help_editUserInfo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.user_id.write())
        stream.pack_string(self.message)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.entities))
        for vec_k_2 in self.entities:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        self.message = data.unpack_string()
        self.entities = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageEntity()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.entities.append(elem_of_1_vec)
        return self

class help_UserInfo(TLObject):
    DERIVED_OBJECTS = {0xf3ae2eed: help_userInfoEmpty, 0x1eb3758: help_userInfo, 0x38a08d3: help_getUserInfo, 0x66b91b70: help_editUserInfo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pollAnswer(TLObject):
    ID = 0x6ca9c2e9
    def __init__(self, text = None, option = None):
        self.text = text
        self.option = option
    def __str__(self):
        return 'pollAnswer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.text)
        stream.pack_string(self.option)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.text = data.unpack_string()
        self.option = data.unpack_string()
        return self

class PollAnswer(TLObject):
    DERIVED_OBJECTS = {0x6ca9c2e9: pollAnswer}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class poll(TLObject):
    ID = 0x86e18161
    def __init__(self, id = None, flags = None, closed = None, public_voters = None, multiple_choice = None, quiz = None, question = None, answers = None, close_period = None, close_date = None):
        self.id = id
        self.flags = flags
        self.closed = closed
        self.public_voters = public_voters
        self.multiple_choice = multiple_choice
        self.quiz = quiz
        self.question = question
        self.answers = answers
        self.close_period = close_period
        self.close_date = close_date
    def __str__(self):
        return 'poll'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        flags = 0x0
        if self.closed:
            flags |= (1 << 0)
        if self.public_voters:
            flags |= (1 << 1)
        if self.multiple_choice:
            flags |= (1 << 2)
        if self.quiz:
            flags |= (1 << 3)
        stream.pack_string(self.question)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.answers))
        for vec_k_2 in self.answers:
            stream.pack_bytes(vec_k_2.write())
        if self.close_period:
            flags |= (1 << 4)
            stream.pack_int32(self.close_period)
        if self.close_date:
            flags |= (1 << 5)
            stream.pack_int32(self.close_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.closed = True
        if flags.check_bit(1):
            self.public_voters = True
        if flags.check_bit(2):
            self.multiple_choice = True
        if flags.check_bit(3):
            self.quiz = True
        self.question = data.unpack_string()
        self.answers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = PollAnswer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.answers.append(elem_of_1_vec)
        if flags.check_bit(4):
            self.close_period = data.unpack_int32()
        if flags.check_bit(5):
            self.close_date = data.unpack_int32()
        return self

class Poll(TLObject):
    DERIVED_OBJECTS = {0x86e18161: poll}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pollAnswerVoters(TLObject):
    ID = 0x3b6ddad2
    def __init__(self, flags = None, chosen = None, correct = None, option = None, voters = None):
        self.flags = flags
        self.chosen = chosen
        self.correct = correct
        self.option = option
        self.voters = voters
    def __str__(self):
        return 'pollAnswerVoters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.chosen:
            flags |= (1 << 0)
        if self.correct:
            flags |= (1 << 1)
        stream.pack_string(self.option)
        stream.pack_int32(self.voters)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.chosen = True
        if flags.check_bit(1):
            self.correct = True
        self.option = data.unpack_string()
        self.voters = data.unpack_int32()
        return self

class PollAnswerVoters(TLObject):
    DERIVED_OBJECTS = {0x3b6ddad2: pollAnswerVoters}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class pollResults(TLObject):
    ID = 0xdcb82ea3
    def __init__(self, flags = None, min = None, results = None, total_voters = None, recent_voters = None, solution = None, solution_entities = None):
        self.flags = flags
        self.min = min
        self.results = results
        self.total_voters = total_voters
        self.recent_voters = recent_voters
        self.solution = solution
        self.solution_entities = solution_entities
    def __str__(self):
        return 'pollResults'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.min:
            flags |= (1 << 0)
        if self.results:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.results))
            for vec_k_2 in self.results:
                stream.pack_bytes(vec_k_2.write())
        if self.total_voters:
            flags |= (1 << 2)
            stream.pack_int32(self.total_voters)
        if self.recent_voters:
            flags |= (1 << 3)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.recent_voters))
            for vec_k_3 in self.recent_voters:
                stream.pack_int64(vec_k_3)
        if self.solution:
            flags |= (1 << 4)
            stream.pack_string(self.solution)
        if self.solution_entities:
            flags |= (1 << 4)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.solution_entities))
            for vec_k_4 in self.solution_entities:
                stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.min = True
        if flags.check_bit(1):
            self.results = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = PollAnswerVoters()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.results.append(elem_of_1_vec)
        if flags.check_bit(2):
            self.total_voters = data.unpack_int32()
        if flags.check_bit(3):
            self.recent_voters = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                self.recent_voters.append(data.unpack_int64())
        if flags.check_bit(4):
            self.solution = data.unpack_string()
        if flags.check_bit(4):
            self.solution_entities = list()
            data.unpack_int32()
            vector_3_size = data.unpack_int32()
            for vec_i_3 in range(vector_3_size):
                elem_of_3_vec = MessageEntity()
                elem_of_3_vec = elem_of_3_vec.read(data)
                self.solution_entities.append(elem_of_3_vec)
        return self

class PollResults(TLObject):
    DERIVED_OBJECTS = {0xdcb82ea3: pollResults}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatOnlines(TLObject):
    ID = 0xf041e250
    def __init__(self, onlines = None):
        self.onlines = onlines
    def __str__(self):
        return 'chatOnlines'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.onlines)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.onlines = data.unpack_int32()
        return self

class messages_getOnlines(TLObject):
    ID = 0x6e2be050
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_getOnlines'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class ChatOnlines(TLObject):
    DERIVED_OBJECTS = {0xf041e250: chatOnlines, 0x6e2be050: messages_getOnlines}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsURL(TLObject):
    ID = 0x47a971e0
    def __init__(self, url = None):
        self.url = url
    def __str__(self):
        return 'statsURL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        return self

class StatsURL(TLObject):
    DERIVED_OBJECTS = {0x47a971e0: statsURL}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatAdminRights(TLObject):
    ID = 0x5fb224d5
    def __init__(self, flags = None, change_info = None, post_messages = None, edit_messages = None, delete_messages = None, ban_users = None, invite_users = None, pin_messages = None, add_admins = None, anonymous = None, manage_call = None, other = None):
        self.flags = flags
        self.change_info = change_info
        self.post_messages = post_messages
        self.edit_messages = edit_messages
        self.delete_messages = delete_messages
        self.ban_users = ban_users
        self.invite_users = invite_users
        self.pin_messages = pin_messages
        self.add_admins = add_admins
        self.anonymous = anonymous
        self.manage_call = manage_call
        self.other = other
    def __str__(self):
        return 'chatAdminRights'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.change_info:
            flags |= (1 << 0)
        if self.post_messages:
            flags |= (1 << 1)
        if self.edit_messages:
            flags |= (1 << 2)
        if self.delete_messages:
            flags |= (1 << 3)
        if self.ban_users:
            flags |= (1 << 4)
        if self.invite_users:
            flags |= (1 << 5)
        if self.pin_messages:
            flags |= (1 << 7)
        if self.add_admins:
            flags |= (1 << 9)
        if self.anonymous:
            flags |= (1 << 10)
        if self.manage_call:
            flags |= (1 << 11)
        if self.other:
            flags |= (1 << 12)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.change_info = True
        if flags.check_bit(1):
            self.post_messages = True
        if flags.check_bit(2):
            self.edit_messages = True
        if flags.check_bit(3):
            self.delete_messages = True
        if flags.check_bit(4):
            self.ban_users = True
        if flags.check_bit(5):
            self.invite_users = True
        if flags.check_bit(7):
            self.pin_messages = True
        if flags.check_bit(9):
            self.add_admins = True
        if flags.check_bit(10):
            self.anonymous = True
        if flags.check_bit(11):
            self.manage_call = True
        if flags.check_bit(12):
            self.other = True
        return self

class ChatAdminRights(TLObject):
    DERIVED_OBJECTS = {0x5fb224d5: chatAdminRights}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatBannedRights(TLObject):
    ID = 0x9f120418
    def __init__(self, flags = None, view_messages = None, send_messages = None, send_media = None, send_stickers = None, send_gifs = None, send_games = None, send_inline = None, embed_links = None, send_polls = None, change_info = None, invite_users = None, pin_messages = None, until_date = None):
        self.flags = flags
        self.view_messages = view_messages
        self.send_messages = send_messages
        self.send_media = send_media
        self.send_stickers = send_stickers
        self.send_gifs = send_gifs
        self.send_games = send_games
        self.send_inline = send_inline
        self.embed_links = embed_links
        self.send_polls = send_polls
        self.change_info = change_info
        self.invite_users = invite_users
        self.pin_messages = pin_messages
        self.until_date = until_date
    def __str__(self):
        return 'chatBannedRights'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.view_messages:
            flags |= (1 << 0)
        if self.send_messages:
            flags |= (1 << 1)
        if self.send_media:
            flags |= (1 << 2)
        if self.send_stickers:
            flags |= (1 << 3)
        if self.send_gifs:
            flags |= (1 << 4)
        if self.send_games:
            flags |= (1 << 5)
        if self.send_inline:
            flags |= (1 << 6)
        if self.embed_links:
            flags |= (1 << 7)
        if self.send_polls:
            flags |= (1 << 8)
        if self.change_info:
            flags |= (1 << 10)
        if self.invite_users:
            flags |= (1 << 15)
        if self.pin_messages:
            flags |= (1 << 17)
        stream.pack_int32(self.until_date)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.view_messages = True
        if flags.check_bit(1):
            self.send_messages = True
        if flags.check_bit(2):
            self.send_media = True
        if flags.check_bit(3):
            self.send_stickers = True
        if flags.check_bit(4):
            self.send_gifs = True
        if flags.check_bit(5):
            self.send_games = True
        if flags.check_bit(6):
            self.send_inline = True
        if flags.check_bit(7):
            self.embed_links = True
        if flags.check_bit(8):
            self.send_polls = True
        if flags.check_bit(10):
            self.change_info = True
        if flags.check_bit(15):
            self.invite_users = True
        if flags.check_bit(17):
            self.pin_messages = True
        self.until_date = data.unpack_int32()
        return self

class ChatBannedRights(TLObject):
    DERIVED_OBJECTS = {0x9f120418: chatBannedRights}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputWallPaper(TLObject):
    ID = 0xe630b979
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputWallPaper'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputWallPaperSlug(TLObject):
    ID = 0x72091c80
    def __init__(self, slug = None):
        self.slug = slug
    def __str__(self):
        return 'inputWallPaperSlug'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.slug)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.slug = data.unpack_string()
        return self

class inputWallPaperNoFile(TLObject):
    ID = 0x967a462e
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'inputWallPaperNoFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class InputWallPaper(TLObject):
    DERIVED_OBJECTS = {0xe630b979: inputWallPaper, 0x72091c80: inputWallPaperSlug, 0x967a462e: inputWallPaperNoFile}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_wallPapersNotModified(TLObject):
    ID = 0x1c199183
    def __init__(self):
        pass
    def __str__(self):
        return 'account_wallPapersNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_wallPapers(TLObject):
    ID = 0xcdc3858c
    def __init__(self, hash = None, wallpapers = None):
        self.hash = hash
        self.wallpapers = wallpapers
    def __str__(self):
        return 'account_wallPapers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.wallpapers))
        for vec_k_2 in self.wallpapers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.wallpapers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = WallPaper()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.wallpapers.append(elem_of_1_vec)
        return self

class account_getWallPapers(TLObject):
    ID = 0x7967d36
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'account_getWallPapers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class account_WallPapers(TLObject):
    DERIVED_OBJECTS = {0x1c199183: account_wallPapersNotModified, 0xcdc3858c: account_wallPapers, 0x7967d36: account_getWallPapers}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class codeSettings(TLObject):
    ID = 0xdebebe83
    def __init__(self, flags = None, allow_flashcall = None, current_number = None, allow_app_hash = None):
        self.flags = flags
        self.allow_flashcall = allow_flashcall
        self.current_number = current_number
        self.allow_app_hash = allow_app_hash
    def __str__(self):
        return 'codeSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.allow_flashcall:
            flags |= (1 << 0)
        if self.current_number:
            flags |= (1 << 1)
        if self.allow_app_hash:
            flags |= (1 << 4)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.allow_flashcall = True
        if flags.check_bit(1):
            self.current_number = True
        if flags.check_bit(4):
            self.allow_app_hash = True
        return self

class CodeSettings(TLObject):
    DERIVED_OBJECTS = {0xdebebe83: codeSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class wallPaperSettings(TLObject):
    ID = 0x1dc1bca4
    def __init__(self, flags = None, blur = None, motion = None, background_color = None, second_background_color = None, third_background_color = None, fourth_background_color = None, intensity = None, rotation = None):
        self.flags = flags
        self.blur = blur
        self.motion = motion
        self.background_color = background_color
        self.second_background_color = second_background_color
        self.third_background_color = third_background_color
        self.fourth_background_color = fourth_background_color
        self.intensity = intensity
        self.rotation = rotation
    def __str__(self):
        return 'wallPaperSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.blur:
            flags |= (1 << 1)
        if self.motion:
            flags |= (1 << 2)
        if self.background_color:
            flags |= (1 << 0)
            stream.pack_int32(self.background_color)
        if self.second_background_color:
            flags |= (1 << 4)
            stream.pack_int32(self.second_background_color)
        if self.third_background_color:
            flags |= (1 << 5)
            stream.pack_int32(self.third_background_color)
        if self.fourth_background_color:
            flags |= (1 << 6)
            stream.pack_int32(self.fourth_background_color)
        if self.intensity:
            flags |= (1 << 3)
            stream.pack_int32(self.intensity)
        if self.rotation:
            flags |= (1 << 4)
            stream.pack_int32(self.rotation)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.blur = True
        if flags.check_bit(2):
            self.motion = True
        if flags.check_bit(0):
            self.background_color = data.unpack_int32()
        if flags.check_bit(4):
            self.second_background_color = data.unpack_int32()
        if flags.check_bit(5):
            self.third_background_color = data.unpack_int32()
        if flags.check_bit(6):
            self.fourth_background_color = data.unpack_int32()
        if flags.check_bit(3):
            self.intensity = data.unpack_int32()
        if flags.check_bit(4):
            self.rotation = data.unpack_int32()
        return self

class WallPaperSettings(TLObject):
    DERIVED_OBJECTS = {0x1dc1bca4: wallPaperSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class autoDownloadSettings(TLObject):
    ID = 0xe04232f3
    def __init__(self, flags = None, disabled = None, video_preload_large = None, audio_preload_next = None, phonecalls_less_data = None, photo_size_max = None, video_size_max = None, file_size_max = None, video_upload_maxbitrate = None):
        self.flags = flags
        self.disabled = disabled
        self.video_preload_large = video_preload_large
        self.audio_preload_next = audio_preload_next
        self.phonecalls_less_data = phonecalls_less_data
        self.photo_size_max = photo_size_max
        self.video_size_max = video_size_max
        self.file_size_max = file_size_max
        self.video_upload_maxbitrate = video_upload_maxbitrate
    def __str__(self):
        return 'autoDownloadSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.disabled:
            flags |= (1 << 0)
        if self.video_preload_large:
            flags |= (1 << 1)
        if self.audio_preload_next:
            flags |= (1 << 2)
        if self.phonecalls_less_data:
            flags |= (1 << 3)
        stream.pack_int32(self.photo_size_max)
        stream.pack_int32(self.video_size_max)
        stream.pack_int32(self.file_size_max)
        stream.pack_int32(self.video_upload_maxbitrate)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.disabled = True
        if flags.check_bit(1):
            self.video_preload_large = True
        if flags.check_bit(2):
            self.audio_preload_next = True
        if flags.check_bit(3):
            self.phonecalls_less_data = True
        self.photo_size_max = data.unpack_int32()
        self.video_size_max = data.unpack_int32()
        self.file_size_max = data.unpack_int32()
        self.video_upload_maxbitrate = data.unpack_int32()
        return self

class AutoDownloadSettings(TLObject):
    DERIVED_OBJECTS = {0xe04232f3: autoDownloadSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_autoDownloadSettings(TLObject):
    ID = 0x63cacf26
    def __init__(self, low = None, medium = None, high = None):
        self.low = low
        self.medium = medium
        self.high = high
    def __str__(self):
        return 'account_autoDownloadSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.low.write())
        stream.pack_bytes(self.medium.write())
        stream.pack_bytes(self.high.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.low = AutoDownloadSettings()
        self.low = self.low.read(data)
        self.medium = AutoDownloadSettings()
        self.medium = self.medium.read(data)
        self.high = AutoDownloadSettings()
        self.high = self.high.read(data)
        return self

class account_getAutoDownloadSettings(TLObject):
    ID = 0x56da0b3f
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getAutoDownloadSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_AutoDownloadSettings(TLObject):
    DERIVED_OBJECTS = {0x63cacf26: account_autoDownloadSettings, 0x56da0b3f: account_getAutoDownloadSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class emojiKeyword(TLObject):
    ID = 0xd5b3b9f9
    def __init__(self, keyword = None, emoticons = None):
        self.keyword = keyword
        self.emoticons = emoticons
    def __str__(self):
        return 'emojiKeyword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.keyword)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.emoticons))
        for vec_k_2 in self.emoticons:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.keyword = data.unpack_string()
        self.emoticons = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.emoticons.append(data.unpack_string())
        return self

class emojiKeywordDeleted(TLObject):
    ID = 0x236df622
    def __init__(self, keyword = None, emoticons = None):
        self.keyword = keyword
        self.emoticons = emoticons
    def __str__(self):
        return 'emojiKeywordDeleted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.keyword)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.emoticons))
        for vec_k_2 in self.emoticons:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.keyword = data.unpack_string()
        self.emoticons = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.emoticons.append(data.unpack_string())
        return self

class EmojiKeyword(TLObject):
    DERIVED_OBJECTS = {0xd5b3b9f9: emojiKeyword, 0x236df622: emojiKeywordDeleted}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class emojiKeywordsDifference(TLObject):
    ID = 0x5cc761bd
    def __init__(self, lang_code = None, from_version = None, version = None, keywords = None):
        self.lang_code = lang_code
        self.from_version = from_version
        self.version = version
        self.keywords = keywords
    def __str__(self):
        return 'emojiKeywordsDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        stream.pack_int32(self.from_version)
        stream.pack_int32(self.version)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.keywords))
        for vec_k_2 in self.keywords:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        self.from_version = data.unpack_int32()
        self.version = data.unpack_int32()
        self.keywords = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = EmojiKeyword()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.keywords.append(elem_of_1_vec)
        return self

class messages_getEmojiKeywords(TLObject):
    ID = 0x35a0e062
    def __init__(self, lang_code = None):
        self.lang_code = lang_code
    def __str__(self):
        return 'messages_getEmojiKeywords'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        return self

class messages_getEmojiKeywordsDifference(TLObject):
    ID = 0x1508b6af
    def __init__(self, lang_code = None, from_version = None):
        self.lang_code = lang_code
        self.from_version = from_version
    def __str__(self):
        return 'messages_getEmojiKeywordsDifference'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        stream.pack_int32(self.from_version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        self.from_version = data.unpack_int32()
        return self

class EmojiKeywordsDifference(TLObject):
    DERIVED_OBJECTS = {0x5cc761bd: emojiKeywordsDifference, 0x35a0e062: messages_getEmojiKeywords, 0x1508b6af: messages_getEmojiKeywordsDifference}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class emojiURL(TLObject):
    ID = 0xa575739d
    def __init__(self, url = None):
        self.url = url
    def __str__(self):
        return 'emojiURL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        return self

class messages_getEmojiURL(TLObject):
    ID = 0xd5b10c26
    def __init__(self, lang_code = None):
        self.lang_code = lang_code
    def __str__(self):
        return 'messages_getEmojiURL'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        return self

class EmojiURL(TLObject):
    DERIVED_OBJECTS = {0xa575739d: emojiURL, 0xd5b10c26: messages_getEmojiURL}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class emojiLanguage(TLObject):
    ID = 0xb3fb5361
    def __init__(self, lang_code = None):
        self.lang_code = lang_code
    def __str__(self):
        return 'emojiLanguage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        return self

class EmojiLanguage(TLObject):
    DERIVED_OBJECTS = {0xb3fb5361: emojiLanguage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class folder(TLObject):
    ID = 0xff544e65
    def __init__(self, flags = None, autofill_new_broadcasts = None, autofill_public_groups = None, autofill_new_correspondents = None, id = None, title = None, photo = None):
        self.flags = flags
        self.autofill_new_broadcasts = autofill_new_broadcasts
        self.autofill_public_groups = autofill_public_groups
        self.autofill_new_correspondents = autofill_new_correspondents
        self.id = id
        self.title = title
        self.photo = photo
    def __str__(self):
        return 'folder'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.autofill_new_broadcasts:
            flags |= (1 << 0)
        if self.autofill_public_groups:
            flags |= (1 << 1)
        if self.autofill_new_correspondents:
            flags |= (1 << 2)
        stream.pack_int32(self.id)
        stream.pack_string(self.title)
        if self.photo:
            flags |= (1 << 3)
            stream.pack_bytes(self.photo.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.autofill_new_broadcasts = True
        if flags.check_bit(1):
            self.autofill_public_groups = True
        if flags.check_bit(2):
            self.autofill_new_correspondents = True
        self.id = data.unpack_int32()
        self.title = data.unpack_string()
        if flags.check_bit(3):
            self.photo = ChatPhoto()
            self.photo = self.photo.read(data)
        return self

class Folder(TLObject):
    DERIVED_OBJECTS = {0xff544e65: folder}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputFolderPeer(TLObject):
    ID = 0xfbd2c296
    def __init__(self, peer = None, folder_id = None):
        self.peer = peer
        self.folder_id = folder_id
    def __str__(self):
        return 'inputFolderPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.folder_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.folder_id = data.unpack_int32()
        return self

class InputFolderPeer(TLObject):
    DERIVED_OBJECTS = {0xfbd2c296: inputFolderPeer}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class folderPeer(TLObject):
    ID = 0xe9baa668
    def __init__(self, peer = None, folder_id = None):
        self.peer = peer
        self.folder_id = folder_id
    def __str__(self):
        return 'folderPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.folder_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.folder_id = data.unpack_int32()
        return self

class FolderPeer(TLObject):
    DERIVED_OBJECTS = {0xe9baa668: folderPeer}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_searchCounter(TLObject):
    ID = 0xe844ebff
    def __init__(self, flags = None, inexact = None, filter = None, count = None):
        self.flags = flags
        self.inexact = inexact
        self.filter = filter
        self.count = count
    def __str__(self):
        return 'messages_searchCounter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.inexact:
            flags |= (1 << 1)
        stream.pack_bytes(self.filter.write())
        stream.pack_int32(self.count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.inexact = True
        self.filter = MessagesFilter()
        self.filter = self.filter.read(data)
        self.count = data.unpack_int32()
        return self

class messages_SearchCounter(TLObject):
    DERIVED_OBJECTS = {0xe844ebff: messages_searchCounter}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class urlAuthResultRequest(TLObject):
    ID = 0x92d33a0e
    def __init__(self, flags = None, request_write_access = None, bot = None, domain = None):
        self.flags = flags
        self.request_write_access = request_write_access
        self.bot = bot
        self.domain = domain
    def __str__(self):
        return 'urlAuthResultRequest'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.request_write_access:
            flags |= (1 << 0)
        stream.pack_bytes(self.bot.write())
        stream.pack_string(self.domain)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.request_write_access = True
        self.bot = User()
        self.bot = self.bot.read(data)
        self.domain = data.unpack_string()
        return self

class urlAuthResultAccepted(TLObject):
    ID = 0x8f8c0e4e
    def __init__(self, url = None):
        self.url = url
    def __str__(self):
        return 'urlAuthResultAccepted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        return self

class urlAuthResultDefault(TLObject):
    ID = 0xa9d6db1f
    def __init__(self):
        pass
    def __str__(self):
        return 'urlAuthResultDefault'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_requestUrlAuth(TLObject):
    ID = 0x198fb446
    def __init__(self, flags = None, peer = None, msg_id = None, button_id = None, url = None):
        self.flags = flags
        self.peer = peer
        self.msg_id = msg_id
        self.button_id = button_id
        self.url = url
    def __str__(self):
        return 'messages_requestUrlAuth'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.peer:
            flags |= (1 << 1)
            stream.pack_bytes(self.peer.write())
        if self.msg_id:
            flags |= (1 << 1)
            stream.pack_int32(self.msg_id)
        if self.button_id:
            flags |= (1 << 1)
            stream.pack_int32(self.button_id)
        if self.url:
            flags |= (1 << 2)
            stream.pack_string(self.url)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.peer = InputPeer()
            self.peer = self.peer.read(data)
        if flags.check_bit(1):
            self.msg_id = data.unpack_int32()
        if flags.check_bit(1):
            self.button_id = data.unpack_int32()
        if flags.check_bit(2):
            self.url = data.unpack_string()
        return self

class messages_acceptUrlAuth(TLObject):
    ID = 0xb12c7125
    def __init__(self, flags = None, write_allowed = None, peer = None, msg_id = None, button_id = None, url = None):
        self.flags = flags
        self.write_allowed = write_allowed
        self.peer = peer
        self.msg_id = msg_id
        self.button_id = button_id
        self.url = url
    def __str__(self):
        return 'messages_acceptUrlAuth'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.write_allowed:
            flags |= (1 << 0)
        if self.peer:
            flags |= (1 << 1)
            stream.pack_bytes(self.peer.write())
        if self.msg_id:
            flags |= (1 << 1)
            stream.pack_int32(self.msg_id)
        if self.button_id:
            flags |= (1 << 1)
            stream.pack_int32(self.button_id)
        if self.url:
            flags |= (1 << 2)
            stream.pack_string(self.url)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.write_allowed = True
        if flags.check_bit(1):
            self.peer = InputPeer()
            self.peer = self.peer.read(data)
        if flags.check_bit(1):
            self.msg_id = data.unpack_int32()
        if flags.check_bit(1):
            self.button_id = data.unpack_int32()
        if flags.check_bit(2):
            self.url = data.unpack_string()
        return self

class UrlAuthResult(TLObject):
    DERIVED_OBJECTS = {0x92d33a0e: urlAuthResultRequest, 0x8f8c0e4e: urlAuthResultAccepted, 0xa9d6db1f: urlAuthResultDefault, 0x198fb446: messages_requestUrlAuth, 0xb12c7125: messages_acceptUrlAuth}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class channelLocationEmpty(TLObject):
    ID = 0xbfb5ad8b
    def __init__(self):
        pass
    def __str__(self):
        return 'channelLocationEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class channelLocation(TLObject):
    ID = 0x209b82db
    def __init__(self, geo_point = None, address = None):
        self.geo_point = geo_point
        self.address = address
    def __str__(self):
        return 'channelLocation'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.geo_point.write())
        stream.pack_string(self.address)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.geo_point = GeoPoint()
        self.geo_point = self.geo_point.read(data)
        self.address = data.unpack_string()
        return self

class ChannelLocation(TLObject):
    DERIVED_OBJECTS = {0xbfb5ad8b: channelLocationEmpty, 0x209b82db: channelLocation}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class peerLocated(TLObject):
    ID = 0xca461b5d
    def __init__(self, peer = None, expires = None, distance = None):
        self.peer = peer
        self.expires = expires
        self.distance = distance
    def __str__(self):
        return 'peerLocated'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.expires)
        stream.pack_int32(self.distance)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.expires = data.unpack_int32()
        self.distance = data.unpack_int32()
        return self

class peerSelfLocated(TLObject):
    ID = 0xf8ec284b
    def __init__(self, expires = None):
        self.expires = expires
    def __str__(self):
        return 'peerSelfLocated'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.expires)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.expires = data.unpack_int32()
        return self

class PeerLocated(TLObject):
    DERIVED_OBJECTS = {0xca461b5d: peerLocated, 0xf8ec284b: peerSelfLocated}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class restrictionReason(TLObject):
    ID = 0xd072acb4
    def __init__(self, platform = None, reason = None, text = None):
        self.platform = platform
        self.reason = reason
        self.text = text
    def __str__(self):
        return 'restrictionReason'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.platform)
        stream.pack_string(self.reason)
        stream.pack_string(self.text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.platform = data.unpack_string()
        self.reason = data.unpack_string()
        self.text = data.unpack_string()
        return self

class RestrictionReason(TLObject):
    DERIVED_OBJECTS = {0xd072acb4: restrictionReason}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputTheme(TLObject):
    ID = 0x3c5693e9
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class inputThemeSlug(TLObject):
    ID = 0xf5890df1
    def __init__(self, slug = None):
        self.slug = slug
    def __str__(self):
        return 'inputThemeSlug'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.slug)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.slug = data.unpack_string()
        return self

class InputTheme(TLObject):
    DERIVED_OBJECTS = {0x3c5693e9: inputTheme, 0xf5890df1: inputThemeSlug}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class theme(TLObject):
    ID = 0xe802b8dc
    def __init__(self, flags = None, creator = None, default = None, for_chat = None, id = None, access_hash = None, slug = None, title = None, document = None, settings = None, installs_count = None):
        self.flags = flags
        self.creator = creator
        self.default = default
        self.for_chat = for_chat
        self.id = id
        self.access_hash = access_hash
        self.slug = slug
        self.title = title
        self.document = document
        self.settings = settings
        self.installs_count = installs_count
    def __str__(self):
        return 'theme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.creator:
            flags |= (1 << 0)
        if self.default:
            flags |= (1 << 1)
        if self.for_chat:
            flags |= (1 << 5)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_string(self.slug)
        stream.pack_string(self.title)
        if self.document:
            flags |= (1 << 2)
            stream.pack_bytes(self.document.write())
        if self.settings:
            flags |= (1 << 3)
            stream.pack_bytes(self.settings.write())
        if self.installs_count:
            flags |= (1 << 4)
            stream.pack_int32(self.installs_count)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.creator = True
        if flags.check_bit(1):
            self.default = True
        if flags.check_bit(5):
            self.for_chat = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.slug = data.unpack_string()
        self.title = data.unpack_string()
        if flags.check_bit(2):
            self.document = Document()
            self.document = self.document.read(data)
        if flags.check_bit(3):
            self.settings = ThemeSettings()
            self.settings = self.settings.read(data)
        if flags.check_bit(4):
            self.installs_count = data.unpack_int32()
        return self

class account_createTheme(TLObject):
    ID = 0x8432c21f
    def __init__(self, flags = None, slug = None, title = None, document = None, settings = None):
        self.flags = flags
        self.slug = slug
        self.title = title
        self.document = document
        self.settings = settings
    def __str__(self):
        return 'account_createTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.slug)
        stream.pack_string(self.title)
        flags = 0x0
        if self.document:
            flags |= (1 << 2)
            stream.pack_bytes(self.document.write())
        if self.settings:
            flags |= (1 << 3)
            stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.slug = data.unpack_string()
        self.title = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.document = InputDocument()
            self.document = self.document.read(data)
        if flags.check_bit(3):
            self.settings = InputThemeSettings()
            self.settings = self.settings.read(data)
        return self

class account_updateTheme(TLObject):
    ID = 0x5cb367d5
    def __init__(self, flags = None, format = None, theme = None, slug = None, title = None, document = None, settings = None):
        self.flags = flags
        self.format = format
        self.theme = theme
        self.slug = slug
        self.title = title
        self.document = document
        self.settings = settings
    def __str__(self):
        return 'account_updateTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.format)
        stream.pack_bytes(self.theme.write())
        flags = 0x0
        if self.slug:
            flags |= (1 << 0)
            stream.pack_string(self.slug)
        if self.title:
            flags |= (1 << 1)
            stream.pack_string(self.title)
        if self.document:
            flags |= (1 << 2)
            stream.pack_bytes(self.document.write())
        if self.settings:
            flags |= (1 << 3)
            stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.format = data.unpack_string()
        self.theme = InputTheme()
        self.theme = self.theme.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.slug = data.unpack_string()
        if flags.check_bit(1):
            self.title = data.unpack_string()
        if flags.check_bit(2):
            self.document = InputDocument()
            self.document = self.document.read(data)
        if flags.check_bit(3):
            self.settings = InputThemeSettings()
            self.settings = self.settings.read(data)
        return self

class account_getTheme(TLObject):
    ID = 0x8d9d742b
    def __init__(self, format = None, theme = None, document_id = None):
        self.format = format
        self.theme = theme
        self.document_id = document_id
    def __str__(self):
        return 'account_getTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.format)
        stream.pack_bytes(self.theme.write())
        stream.pack_int64(self.document_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.format = data.unpack_string()
        self.theme = InputTheme()
        self.theme = self.theme.read(data)
        self.document_id = data.unpack_int64()
        return self

class Theme(TLObject):
    DERIVED_OBJECTS = {0xe802b8dc: theme, 0x8432c21f: account_createTheme, 0x5cb367d5: account_updateTheme, 0x8d9d742b: account_getTheme}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_themesNotModified(TLObject):
    ID = 0xf41eb622
    def __init__(self):
        pass
    def __str__(self):
        return 'account_themesNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_themes(TLObject):
    ID = 0x9a3d8c6d
    def __init__(self, hash = None, themes = None):
        self.hash = hash
        self.themes = themes
    def __str__(self):
        return 'account_themes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.themes))
        for vec_k_2 in self.themes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        self.themes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Theme()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.themes.append(elem_of_1_vec)
        return self

class account_getThemes(TLObject):
    ID = 0x7206e458
    def __init__(self, format = None, hash = None):
        self.format = format
        self.hash = hash
    def __str__(self):
        return 'account_getThemes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.format)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.format = data.unpack_string()
        self.hash = data.unpack_int64()
        return self

class account_Themes(TLObject):
    DERIVED_OBJECTS = {0xf41eb622: account_themesNotModified, 0x9a3d8c6d: account_themes, 0x7206e458: account_getThemes}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class auth_loginToken(TLObject):
    ID = 0x629f1980
    def __init__(self, expires = None, token = None):
        self.expires = expires
        self.token = token
    def __str__(self):
        return 'auth_loginToken'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.expires)
        stream.pack_string(self.token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.expires = data.unpack_int32()
        self.token = data.unpack_string()
        return self

class auth_loginTokenMigrateTo(TLObject):
    ID = 0x68e9916
    def __init__(self, dc_id = None, token = None):
        self.dc_id = dc_id
        self.token = token
    def __str__(self):
        return 'auth_loginTokenMigrateTo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.dc_id)
        stream.pack_string(self.token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dc_id = data.unpack_int32()
        self.token = data.unpack_string()
        return self

class auth_loginTokenSuccess(TLObject):
    ID = 0x390d5c5e
    def __init__(self, authorization = None):
        self.authorization = authorization
    def __str__(self):
        return 'auth_loginTokenSuccess'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.authorization.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.authorization = auth_Authorization()
        self.authorization = self.authorization.read(data)
        return self

class auth_exportLoginToken(TLObject):
    ID = 0xb7e085fe
    def __init__(self, api_id = None, api_hash = None, except_ids = None):
        self.api_id = api_id
        self.api_hash = api_hash
        self.except_ids = except_ids
    def __str__(self):
        return 'auth_exportLoginToken'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.api_id)
        stream.pack_string(self.api_hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.except_ids))
        for vec_k_2 in self.except_ids:
            stream.pack_int64(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.api_id = data.unpack_int32()
        self.api_hash = data.unpack_string()
        self.except_ids = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.except_ids.append(data.unpack_int64())
        return self

class auth_importLoginToken(TLObject):
    ID = 0x95ac5ce4
    def __init__(self, token = None):
        self.token = token
    def __str__(self):
        return 'auth_importLoginToken'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.token = data.unpack_string()
        return self

class auth_LoginToken(TLObject):
    DERIVED_OBJECTS = {0x629f1980: auth_loginToken, 0x68e9916: auth_loginTokenMigrateTo, 0x390d5c5e: auth_loginTokenSuccess, 0xb7e085fe: auth_exportLoginToken, 0x95ac5ce4: auth_importLoginToken}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_contentSettings(TLObject):
    ID = 0x57e28221
    def __init__(self, flags = None, sensitive_enabled = None, sensitive_can_change = None):
        self.flags = flags
        self.sensitive_enabled = sensitive_enabled
        self.sensitive_can_change = sensitive_can_change
    def __str__(self):
        return 'account_contentSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.sensitive_enabled:
            flags |= (1 << 0)
        if self.sensitive_can_change:
            flags |= (1 << 1)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.sensitive_enabled = True
        if flags.check_bit(1):
            self.sensitive_can_change = True
        return self

class account_getContentSettings(TLObject):
    ID = 0x8b9b4dae
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getContentSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_ContentSettings(TLObject):
    DERIVED_OBJECTS = {0x57e28221: account_contentSettings, 0x8b9b4dae: account_getContentSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_inactiveChats(TLObject):
    ID = 0xa927fec5
    def __init__(self, dates = None, chats = None, users = None):
        self.dates = dates
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_inactiveChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.dates))
        for vec_k_2 in self.dates:
            stream.pack_int32(vec_k_2)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.dates = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.dates.append(data.unpack_int32())
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class channels_getInactiveChannels(TLObject):
    ID = 0x11e831ee
    def __init__(self):
        pass
    def __str__(self):
        return 'channels_getInactiveChannels'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_InactiveChats(TLObject):
    DERIVED_OBJECTS = {0xa927fec5: messages_inactiveChats, 0x11e831ee: channels_getInactiveChannels}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class baseThemeClassic(TLObject):
    ID = 0xc3a12462
    def __init__(self):
        pass
    def __str__(self):
        return 'baseThemeClassic'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class baseThemeDay(TLObject):
    ID = 0xfbd81688
    def __init__(self):
        pass
    def __str__(self):
        return 'baseThemeDay'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class baseThemeNight(TLObject):
    ID = 0xb7b31ea8
    def __init__(self):
        pass
    def __str__(self):
        return 'baseThemeNight'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class baseThemeTinted(TLObject):
    ID = 0x6d5f77ee
    def __init__(self):
        pass
    def __str__(self):
        return 'baseThemeTinted'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class baseThemeArctic(TLObject):
    ID = 0x5b11125a
    def __init__(self):
        pass
    def __str__(self):
        return 'baseThemeArctic'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class BaseTheme(TLObject):
    DERIVED_OBJECTS = {0xc3a12462: baseThemeClassic, 0xfbd81688: baseThemeDay, 0xb7b31ea8: baseThemeNight, 0x6d5f77ee: baseThemeTinted, 0x5b11125a: baseThemeArctic}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputThemeSettings(TLObject):
    ID = 0x8fde504f
    def __init__(self, flags = None, message_colors_animated = None, base_theme = None, accent_color = None, outbox_accent_color = None, message_colors = None, wallpaper = None, wallpaper_settings = None):
        self.flags = flags
        self.message_colors_animated = message_colors_animated
        self.base_theme = base_theme
        self.accent_color = accent_color
        self.outbox_accent_color = outbox_accent_color
        self.message_colors = message_colors
        self.wallpaper = wallpaper
        self.wallpaper_settings = wallpaper_settings
    def __str__(self):
        return 'inputThemeSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.message_colors_animated:
            flags |= (1 << 2)
        stream.pack_bytes(self.base_theme.write())
        stream.pack_int32(self.accent_color)
        if self.outbox_accent_color:
            flags |= (1 << 3)
            stream.pack_int32(self.outbox_accent_color)
        if self.message_colors:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.message_colors))
            for vec_k_2 in self.message_colors:
                stream.pack_int32(vec_k_2)
        if self.wallpaper:
            flags |= (1 << 1)
            stream.pack_bytes(self.wallpaper.write())
        if self.wallpaper_settings:
            flags |= (1 << 1)
            stream.pack_bytes(self.wallpaper_settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.message_colors_animated = True
        self.base_theme = BaseTheme()
        self.base_theme = self.base_theme.read(data)
        self.accent_color = data.unpack_int32()
        if flags.check_bit(3):
            self.outbox_accent_color = data.unpack_int32()
        if flags.check_bit(0):
            self.message_colors = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                self.message_colors.append(data.unpack_int32())
        if flags.check_bit(1):
            self.wallpaper = InputWallPaper()
            self.wallpaper = self.wallpaper.read(data)
        if flags.check_bit(1):
            self.wallpaper_settings = WallPaperSettings()
            self.wallpaper_settings = self.wallpaper_settings.read(data)
        return self

class InputThemeSettings(TLObject):
    DERIVED_OBJECTS = {0x8fde504f: inputThemeSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class themeSettings(TLObject):
    ID = 0xfa58b6d4
    def __init__(self, flags = None, message_colors_animated = None, base_theme = None, accent_color = None, outbox_accent_color = None, message_colors = None, wallpaper = None):
        self.flags = flags
        self.message_colors_animated = message_colors_animated
        self.base_theme = base_theme
        self.accent_color = accent_color
        self.outbox_accent_color = outbox_accent_color
        self.message_colors = message_colors
        self.wallpaper = wallpaper
    def __str__(self):
        return 'themeSettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.message_colors_animated:
            flags |= (1 << 2)
        stream.pack_bytes(self.base_theme.write())
        stream.pack_int32(self.accent_color)
        if self.outbox_accent_color:
            flags |= (1 << 3)
            stream.pack_int32(self.outbox_accent_color)
        if self.message_colors:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.message_colors))
            for vec_k_2 in self.message_colors:
                stream.pack_int32(vec_k_2)
        if self.wallpaper:
            flags |= (1 << 1)
            stream.pack_bytes(self.wallpaper.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.message_colors_animated = True
        self.base_theme = BaseTheme()
        self.base_theme = self.base_theme.read(data)
        self.accent_color = data.unpack_int32()
        if flags.check_bit(3):
            self.outbox_accent_color = data.unpack_int32()
        if flags.check_bit(0):
            self.message_colors = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                self.message_colors.append(data.unpack_int32())
        if flags.check_bit(1):
            self.wallpaper = WallPaper()
            self.wallpaper = self.wallpaper.read(data)
        return self

class ThemeSettings(TLObject):
    DERIVED_OBJECTS = {0xfa58b6d4: themeSettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class webPageAttributeTheme(TLObject):
    ID = 0x54b56617
    def __init__(self, flags = None, documents = None, settings = None):
        self.flags = flags
        self.documents = documents
        self.settings = settings
    def __str__(self):
        return 'webPageAttributeTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.documents:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.documents))
            for vec_k_2 in self.documents:
                stream.pack_bytes(vec_k_2.write())
        if self.settings:
            flags |= (1 << 1)
            stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.documents = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = Document()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.documents.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.settings = ThemeSettings()
            self.settings = self.settings.read(data)
        return self

class WebPageAttribute(TLObject):
    DERIVED_OBJECTS = {0x54b56617: webPageAttributeTheme}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageUserVote(TLObject):
    ID = 0x34d247b4
    def __init__(self, user_id = None, option = None, date = None):
        self.user_id = user_id
        self.option = option
        self.date = date
    def __str__(self):
        return 'messageUserVote'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_string(self.option)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.option = data.unpack_string()
        self.date = data.unpack_int32()
        return self

class messageUserVoteInputOption(TLObject):
    ID = 0x3ca5b0ec
    def __init__(self, user_id = None, date = None):
        self.user_id = user_id
        self.date = date
    def __str__(self):
        return 'messageUserVoteInputOption'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class messageUserVoteMultiple(TLObject):
    ID = 0x8a65e557
    def __init__(self, user_id = None, options = None, date = None):
        self.user_id = user_id
        self.options = options
        self.date = date
    def __str__(self):
        return 'messageUserVoteMultiple'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.options))
        for vec_k_2 in self.options:
            stream.pack_string(vec_k_2)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.options = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.options.append(data.unpack_string())
        self.date = data.unpack_int32()
        return self

class MessageUserVote(TLObject):
    DERIVED_OBJECTS = {0x34d247b4: messageUserVote, 0x3ca5b0ec: messageUserVoteInputOption, 0x8a65e557: messageUserVoteMultiple}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_votesList(TLObject):
    ID = 0x823f649
    def __init__(self, flags = None, count = None, votes = None, users = None, next_offset = None):
        self.flags = flags
        self.count = count
        self.votes = votes
        self.users = users
        self.next_offset = next_offset
    def __str__(self):
        return 'messages_votesList'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.votes))
        for vec_k_2 in self.votes:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        flags = 0x0
        if self.next_offset:
            flags |= (1 << 0)
            stream.pack_string(self.next_offset)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.count = data.unpack_int32()
        self.votes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageUserVote()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.votes.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.next_offset = data.unpack_string()
        return self

class messages_getPollVotes(TLObject):
    ID = 0xb86e380e
    def __init__(self, flags = None, peer = None, id = None, option = None, offset = None, limit = None):
        self.flags = flags
        self.peer = peer
        self.id = id
        self.option = option
        self.offset = offset
        self.limit = limit
    def __str__(self):
        return 'messages_getPollVotes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.id)
        flags = 0x0
        if self.option:
            flags |= (1 << 0)
            stream.pack_string(self.option)
        if self.offset:
            flags |= (1 << 1)
            stream.pack_string(self.offset)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.option = data.unpack_string()
        if flags.check_bit(1):
            self.offset = data.unpack_string()
        self.limit = data.unpack_int32()
        return self

class messages_VotesList(TLObject):
    DERIVED_OBJECTS = {0x823f649: messages_votesList, 0xb86e380e: messages_getPollVotes}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class bankCardOpenUrl(TLObject):
    ID = 0xf568028a
    def __init__(self, url = None, name = None):
        self.url = url
        self.name = name
    def __str__(self):
        return 'bankCardOpenUrl'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.url)
        stream.pack_string(self.name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.url = data.unpack_string()
        self.name = data.unpack_string()
        return self

class BankCardOpenUrl(TLObject):
    DERIVED_OBJECTS = {0xf568028a: bankCardOpenUrl}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class payments_bankCardData(TLObject):
    ID = 0x3e24e573
    def __init__(self, title = None, open_urls = None):
        self.title = title
        self.open_urls = open_urls
    def __str__(self):
        return 'payments_bankCardData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.open_urls))
        for vec_k_2 in self.open_urls:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = data.unpack_string()
        self.open_urls = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = BankCardOpenUrl()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.open_urls.append(elem_of_1_vec)
        return self

class payments_getBankCardData(TLObject):
    ID = 0x2e79d779
    def __init__(self, number = None):
        self.number = number
    def __str__(self):
        return 'payments_getBankCardData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.number)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.number = data.unpack_string()
        return self

class payments_BankCardData(TLObject):
    DERIVED_OBJECTS = {0x3e24e573: payments_bankCardData, 0x2e79d779: payments_getBankCardData}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class dialogFilter(TLObject):
    ID = 0x7438f7e8
    def __init__(self, flags = None, contacts = None, non_contacts = None, groups = None, broadcasts = None, bots = None, exclude_muted = None, exclude_read = None, exclude_archived = None, id = None, title = None, emoticon = None, pinned_peers = None, include_peers = None, exclude_peers = None):
        self.flags = flags
        self.contacts = contacts
        self.non_contacts = non_contacts
        self.groups = groups
        self.broadcasts = broadcasts
        self.bots = bots
        self.exclude_muted = exclude_muted
        self.exclude_read = exclude_read
        self.exclude_archived = exclude_archived
        self.id = id
        self.title = title
        self.emoticon = emoticon
        self.pinned_peers = pinned_peers
        self.include_peers = include_peers
        self.exclude_peers = exclude_peers
    def __str__(self):
        return 'dialogFilter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.contacts:
            flags |= (1 << 0)
        if self.non_contacts:
            flags |= (1 << 1)
        if self.groups:
            flags |= (1 << 2)
        if self.broadcasts:
            flags |= (1 << 3)
        if self.bots:
            flags |= (1 << 4)
        if self.exclude_muted:
            flags |= (1 << 11)
        if self.exclude_read:
            flags |= (1 << 12)
        if self.exclude_archived:
            flags |= (1 << 13)
        stream.pack_int32(self.id)
        stream.pack_string(self.title)
        if self.emoticon:
            flags |= (1 << 25)
            stream.pack_string(self.emoticon)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.pinned_peers))
        for vec_k_2 in self.pinned_peers:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.include_peers))
        for vec_k_3 in self.include_peers:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.exclude_peers))
        for vec_k_4 in self.exclude_peers:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.contacts = True
        if flags.check_bit(1):
            self.non_contacts = True
        if flags.check_bit(2):
            self.groups = True
        if flags.check_bit(3):
            self.broadcasts = True
        if flags.check_bit(4):
            self.bots = True
        if flags.check_bit(11):
            self.exclude_muted = True
        if flags.check_bit(12):
            self.exclude_read = True
        if flags.check_bit(13):
            self.exclude_archived = True
        self.id = data.unpack_int32()
        self.title = data.unpack_string()
        if flags.check_bit(25):
            self.emoticon = data.unpack_string()
        self.pinned_peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.pinned_peers.append(elem_of_1_vec)
        self.include_peers = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = InputPeer()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.include_peers.append(elem_of_2_vec)
        self.exclude_peers = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = InputPeer()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.exclude_peers.append(elem_of_3_vec)
        return self

class DialogFilter(TLObject):
    DERIVED_OBJECTS = {0x7438f7e8: dialogFilter}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class dialogFilterSuggested(TLObject):
    ID = 0x77744d4a
    def __init__(self, filter = None, description = None):
        self.filter = filter
        self.description = description
    def __str__(self):
        return 'dialogFilterSuggested'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.filter.write())
        stream.pack_string(self.description)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.filter = DialogFilter()
        self.filter = self.filter.read(data)
        self.description = data.unpack_string()
        return self

class DialogFilterSuggested(TLObject):
    DERIVED_OBJECTS = {0x77744d4a: dialogFilterSuggested}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsDateRangeDays(TLObject):
    ID = 0xb637edaf
    def __init__(self, min_date = None, max_date = None):
        self.min_date = min_date
        self.max_date = max_date
    def __str__(self):
        return 'statsDateRangeDays'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.min_date)
        stream.pack_int32(self.max_date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.min_date = data.unpack_int32()
        self.max_date = data.unpack_int32()
        return self

class StatsDateRangeDays(TLObject):
    DERIVED_OBJECTS = {0xb637edaf: statsDateRangeDays}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsAbsValueAndPrev(TLObject):
    ID = 0xcb43acde
    def __init__(self, current = None, previous = None):
        self.current = current
        self.previous = previous
    def __str__(self):
        return 'statsAbsValueAndPrev'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_double(self.current)
        stream.pack_double(self.previous)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.current = data.unpack_double()
        self.previous = data.unpack_double()
        return self

class StatsAbsValueAndPrev(TLObject):
    DERIVED_OBJECTS = {0xcb43acde: statsAbsValueAndPrev}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsPercentValue(TLObject):
    ID = 0xcbce2fe0
    def __init__(self, part = None, total = None):
        self.part = part
        self.total = total
    def __str__(self):
        return 'statsPercentValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_double(self.part)
        stream.pack_double(self.total)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.part = data.unpack_double()
        self.total = data.unpack_double()
        return self

class StatsPercentValue(TLObject):
    DERIVED_OBJECTS = {0xcbce2fe0: statsPercentValue}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsGraphAsync(TLObject):
    ID = 0x4a27eb2d
    def __init__(self, token = None):
        self.token = token
    def __str__(self):
        return 'statsGraphAsync'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.token = data.unpack_string()
        return self

class statsGraphError(TLObject):
    ID = 0xbedc9822
    def __init__(self, error = None):
        self.error = error
    def __str__(self):
        return 'statsGraphError'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.error)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.error = data.unpack_string()
        return self

class statsGraph(TLObject):
    ID = 0x8ea464b6
    def __init__(self, flags = None, json = None, zoom_token = None):
        self.flags = flags
        self.json = json
        self.zoom_token = zoom_token
    def __str__(self):
        return 'statsGraph'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.json.write())
        flags = 0x0
        if self.zoom_token:
            flags |= (1 << 0)
            stream.pack_string(self.zoom_token)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.json = DataJSON()
        self.json = self.json.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.zoom_token = data.unpack_string()
        return self

class stats_loadAsyncGraph(TLObject):
    ID = 0x621d5fa0
    def __init__(self, flags = None, token = None, x = None):
        self.flags = flags
        self.token = token
        self.x = x
    def __str__(self):
        return 'stats_loadAsyncGraph'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.token)
        flags = 0x0
        if self.x:
            flags |= (1 << 0)
            stream.pack_int64(self.x)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.token = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.x = data.unpack_int64()
        return self

class StatsGraph(TLObject):
    DERIVED_OBJECTS = {0x4a27eb2d: statsGraphAsync, 0xbedc9822: statsGraphError, 0x8ea464b6: statsGraph, 0x621d5fa0: stats_loadAsyncGraph}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageInteractionCounters(TLObject):
    ID = 0xad4fc9bd
    def __init__(self, msg_id = None, views = None, forwards = None):
        self.msg_id = msg_id
        self.views = views
        self.forwards = forwards
    def __str__(self):
        return 'messageInteractionCounters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.msg_id)
        stream.pack_int32(self.views)
        stream.pack_int32(self.forwards)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.msg_id = data.unpack_int32()
        self.views = data.unpack_int32()
        self.forwards = data.unpack_int32()
        return self

class MessageInteractionCounters(TLObject):
    DERIVED_OBJECTS = {0xad4fc9bd: messageInteractionCounters}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stats_broadcastStats(TLObject):
    ID = 0xbdf78394
    def __init__(self, period = None, followers = None, views_per_post = None, shares_per_post = None, enabled_notifications = None, growth_graph = None, followers_graph = None, mute_graph = None, top_hours_graph = None, interactions_graph = None, iv_interactions_graph = None, views_by_source_graph = None, new_followers_by_source_graph = None, languages_graph = None, recent_message_interactions = None):
        self.period = period
        self.followers = followers
        self.views_per_post = views_per_post
        self.shares_per_post = shares_per_post
        self.enabled_notifications = enabled_notifications
        self.growth_graph = growth_graph
        self.followers_graph = followers_graph
        self.mute_graph = mute_graph
        self.top_hours_graph = top_hours_graph
        self.interactions_graph = interactions_graph
        self.iv_interactions_graph = iv_interactions_graph
        self.views_by_source_graph = views_by_source_graph
        self.new_followers_by_source_graph = new_followers_by_source_graph
        self.languages_graph = languages_graph
        self.recent_message_interactions = recent_message_interactions
    def __str__(self):
        return 'stats_broadcastStats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.period.write())
        stream.pack_bytes(self.followers.write())
        stream.pack_bytes(self.views_per_post.write())
        stream.pack_bytes(self.shares_per_post.write())
        stream.pack_bytes(self.enabled_notifications.write())
        stream.pack_bytes(self.growth_graph.write())
        stream.pack_bytes(self.followers_graph.write())
        stream.pack_bytes(self.mute_graph.write())
        stream.pack_bytes(self.top_hours_graph.write())
        stream.pack_bytes(self.interactions_graph.write())
        stream.pack_bytes(self.iv_interactions_graph.write())
        stream.pack_bytes(self.views_by_source_graph.write())
        stream.pack_bytes(self.new_followers_by_source_graph.write())
        stream.pack_bytes(self.languages_graph.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.recent_message_interactions))
        for vec_k_2 in self.recent_message_interactions:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.period = StatsDateRangeDays()
        self.period = self.period.read(data)
        self.followers = StatsAbsValueAndPrev()
        self.followers = self.followers.read(data)
        self.views_per_post = StatsAbsValueAndPrev()
        self.views_per_post = self.views_per_post.read(data)
        self.shares_per_post = StatsAbsValueAndPrev()
        self.shares_per_post = self.shares_per_post.read(data)
        self.enabled_notifications = StatsPercentValue()
        self.enabled_notifications = self.enabled_notifications.read(data)
        self.growth_graph = StatsGraph()
        self.growth_graph = self.growth_graph.read(data)
        self.followers_graph = StatsGraph()
        self.followers_graph = self.followers_graph.read(data)
        self.mute_graph = StatsGraph()
        self.mute_graph = self.mute_graph.read(data)
        self.top_hours_graph = StatsGraph()
        self.top_hours_graph = self.top_hours_graph.read(data)
        self.interactions_graph = StatsGraph()
        self.interactions_graph = self.interactions_graph.read(data)
        self.iv_interactions_graph = StatsGraph()
        self.iv_interactions_graph = self.iv_interactions_graph.read(data)
        self.views_by_source_graph = StatsGraph()
        self.views_by_source_graph = self.views_by_source_graph.read(data)
        self.new_followers_by_source_graph = StatsGraph()
        self.new_followers_by_source_graph = self.new_followers_by_source_graph.read(data)
        self.languages_graph = StatsGraph()
        self.languages_graph = self.languages_graph.read(data)
        self.recent_message_interactions = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageInteractionCounters()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.recent_message_interactions.append(elem_of_1_vec)
        return self

class stats_getBroadcastStats(TLObject):
    ID = 0xab42441a
    def __init__(self, flags = None, dark = None, channel = None):
        self.flags = flags
        self.dark = dark
        self.channel = channel
    def __str__(self):
        return 'stats_getBroadcastStats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.dark:
            flags |= (1 << 0)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.dark = True
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class stats_BroadcastStats(TLObject):
    DERIVED_OBJECTS = {0xbdf78394: stats_broadcastStats, 0xab42441a: stats_getBroadcastStats}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_promoDataEmpty(TLObject):
    ID = 0x98f6ac75
    def __init__(self, expires = None):
        self.expires = expires
    def __str__(self):
        return 'help_promoDataEmpty'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.expires)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.expires = data.unpack_int32()
        return self

class help_promoData(TLObject):
    ID = 0x8c39793f
    def __init__(self, flags = None, proxy = None, expires = None, peer = None, chats = None, users = None, psa_type = None, psa_message = None):
        self.flags = flags
        self.proxy = proxy
        self.expires = expires
        self.peer = peer
        self.chats = chats
        self.users = users
        self.psa_type = psa_type
        self.psa_message = psa_message
    def __str__(self):
        return 'help_promoData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.proxy:
            flags |= (1 << 0)
        stream.pack_int32(self.expires)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_2 in self.chats:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        if self.psa_type:
            flags |= (1 << 1)
            stream.pack_string(self.psa_type)
        if self.psa_message:
            flags |= (1 << 2)
            stream.pack_string(self.psa_message)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.proxy = True
        self.expires = data.unpack_int32()
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.chats = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Chat()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.chats.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        if flags.check_bit(1):
            self.psa_type = data.unpack_string()
        if flags.check_bit(2):
            self.psa_message = data.unpack_string()
        return self

class help_getPromoData(TLObject):
    ID = 0xc0977421
    def __init__(self):
        pass
    def __str__(self):
        return 'help_getPromoData'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_PromoData(TLObject):
    DERIVED_OBJECTS = {0x98f6ac75: help_promoDataEmpty, 0x8c39793f: help_promoData, 0xc0977421: help_getPromoData}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class videoSize(TLObject):
    ID = 0xde33b094
    def __init__(self, flags = None, type = None, w = None, h = None, size = None, video_start_ts = None):
        self.flags = flags
        self.type = type
        self.w = w
        self.h = h
        self.size = size
        self.video_start_ts = video_start_ts
    def __str__(self):
        return 'videoSize'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.type)
        stream.pack_int32(self.w)
        stream.pack_int32(self.h)
        stream.pack_int32(self.size)
        flags = 0x0
        if self.video_start_ts:
            flags |= (1 << 0)
            stream.pack_double(self.video_start_ts)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.type = data.unpack_string()
        self.w = data.unpack_int32()
        self.h = data.unpack_int32()
        self.size = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.video_start_ts = data.unpack_double()
        return self

class VideoSize(TLObject):
    DERIVED_OBJECTS = {0xde33b094: videoSize}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsGroupTopPoster(TLObject):
    ID = 0x9d04af9b
    def __init__(self, user_id = None, messages = None, avg_chars = None):
        self.user_id = user_id
        self.messages = messages
        self.avg_chars = avg_chars
    def __str__(self):
        return 'statsGroupTopPoster'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.messages)
        stream.pack_int32(self.avg_chars)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.messages = data.unpack_int32()
        self.avg_chars = data.unpack_int32()
        return self

class StatsGroupTopPoster(TLObject):
    DERIVED_OBJECTS = {0x9d04af9b: statsGroupTopPoster}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsGroupTopAdmin(TLObject):
    ID = 0xd7584c87
    def __init__(self, user_id = None, deleted = None, kicked = None, banned = None):
        self.user_id = user_id
        self.deleted = deleted
        self.kicked = kicked
        self.banned = banned
    def __str__(self):
        return 'statsGroupTopAdmin'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.deleted)
        stream.pack_int32(self.kicked)
        stream.pack_int32(self.banned)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.deleted = data.unpack_int32()
        self.kicked = data.unpack_int32()
        self.banned = data.unpack_int32()
        return self

class StatsGroupTopAdmin(TLObject):
    DERIVED_OBJECTS = {0xd7584c87: statsGroupTopAdmin}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class statsGroupTopInviter(TLObject):
    ID = 0x535f779d
    def __init__(self, user_id = None, invitations = None):
        self.user_id = user_id
        self.invitations = invitations
    def __str__(self):
        return 'statsGroupTopInviter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.invitations)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.invitations = data.unpack_int32()
        return self

class StatsGroupTopInviter(TLObject):
    DERIVED_OBJECTS = {0x535f779d: statsGroupTopInviter}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stats_megagroupStats(TLObject):
    ID = 0xef7ff916
    def __init__(self, period = None, members = None, messages = None, viewers = None, posters = None, growth_graph = None, members_graph = None, new_members_by_source_graph = None, languages_graph = None, messages_graph = None, actions_graph = None, top_hours_graph = None, weekdays_graph = None, top_posters = None, top_admins = None, top_inviters = None, users = None):
        self.period = period
        self.members = members
        self.messages = messages
        self.viewers = viewers
        self.posters = posters
        self.growth_graph = growth_graph
        self.members_graph = members_graph
        self.new_members_by_source_graph = new_members_by_source_graph
        self.languages_graph = languages_graph
        self.messages_graph = messages_graph
        self.actions_graph = actions_graph
        self.top_hours_graph = top_hours_graph
        self.weekdays_graph = weekdays_graph
        self.top_posters = top_posters
        self.top_admins = top_admins
        self.top_inviters = top_inviters
        self.users = users
    def __str__(self):
        return 'stats_megagroupStats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.period.write())
        stream.pack_bytes(self.members.write())
        stream.pack_bytes(self.messages.write())
        stream.pack_bytes(self.viewers.write())
        stream.pack_bytes(self.posters.write())
        stream.pack_bytes(self.growth_graph.write())
        stream.pack_bytes(self.members_graph.write())
        stream.pack_bytes(self.new_members_by_source_graph.write())
        stream.pack_bytes(self.languages_graph.write())
        stream.pack_bytes(self.messages_graph.write())
        stream.pack_bytes(self.actions_graph.write())
        stream.pack_bytes(self.top_hours_graph.write())
        stream.pack_bytes(self.weekdays_graph.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.top_posters))
        for vec_k_2 in self.top_posters:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.top_admins))
        for vec_k_3 in self.top_admins:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.top_inviters))
        for vec_k_4 in self.top_inviters:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_5 in self.users:
            stream.pack_bytes(vec_k_5.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.period = StatsDateRangeDays()
        self.period = self.period.read(data)
        self.members = StatsAbsValueAndPrev()
        self.members = self.members.read(data)
        self.messages = StatsAbsValueAndPrev()
        self.messages = self.messages.read(data)
        self.viewers = StatsAbsValueAndPrev()
        self.viewers = self.viewers.read(data)
        self.posters = StatsAbsValueAndPrev()
        self.posters = self.posters.read(data)
        self.growth_graph = StatsGraph()
        self.growth_graph = self.growth_graph.read(data)
        self.members_graph = StatsGraph()
        self.members_graph = self.members_graph.read(data)
        self.new_members_by_source_graph = StatsGraph()
        self.new_members_by_source_graph = self.new_members_by_source_graph.read(data)
        self.languages_graph = StatsGraph()
        self.languages_graph = self.languages_graph.read(data)
        self.messages_graph = StatsGraph()
        self.messages_graph = self.messages_graph.read(data)
        self.actions_graph = StatsGraph()
        self.actions_graph = self.actions_graph.read(data)
        self.top_hours_graph = StatsGraph()
        self.top_hours_graph = self.top_hours_graph.read(data)
        self.weekdays_graph = StatsGraph()
        self.weekdays_graph = self.weekdays_graph.read(data)
        self.top_posters = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = StatsGroupTopPoster()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.top_posters.append(elem_of_1_vec)
        self.top_admins = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = StatsGroupTopAdmin()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.top_admins.append(elem_of_2_vec)
        self.top_inviters = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = StatsGroupTopInviter()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.top_inviters.append(elem_of_3_vec)
        self.users = list()
        data.unpack_int32()
        vector_4_size = data.unpack_int32()
        for vec_i_4 in range(vector_4_size):
            elem_of_4_vec = User()
            elem_of_4_vec = elem_of_4_vec.read(data)
            self.users.append(elem_of_4_vec)
        return self

class stats_getMegagroupStats(TLObject):
    ID = 0xdcdf8607
    def __init__(self, flags = None, dark = None, channel = None):
        self.flags = flags
        self.dark = dark
        self.channel = channel
    def __str__(self):
        return 'stats_getMegagroupStats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.dark:
            flags |= (1 << 0)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.dark = True
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class stats_MegagroupStats(TLObject):
    DERIVED_OBJECTS = {0xef7ff916: stats_megagroupStats, 0xdcdf8607: stats_getMegagroupStats}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class globalPrivacySettings(TLObject):
    ID = 0xbea2f424
    def __init__(self, flags = None, archive_and_mute_new_noncontact_peers = None):
        self.flags = flags
        self.archive_and_mute_new_noncontact_peers = archive_and_mute_new_noncontact_peers
    def __str__(self):
        return 'globalPrivacySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.archive_and_mute_new_noncontact_peers:
            flags |= (1 << 0)
            stream.pack_bytes(self.archive_and_mute_new_noncontact_peers.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.archive_and_mute_new_noncontact_peers = Bool()
            self.archive_and_mute_new_noncontact_peers = self.archive_and_mute_new_noncontact_peers.read(data)
        return self

class account_getGlobalPrivacySettings(TLObject):
    ID = 0xeb2b4cf6
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getGlobalPrivacySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_setGlobalPrivacySettings(TLObject):
    ID = 0x1edaaac2
    def __init__(self, settings = None):
        self.settings = settings
    def __str__(self):
        return 'account_setGlobalPrivacySettings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.settings.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.settings = GlobalPrivacySettings()
        self.settings = self.settings.read(data)
        return self

class GlobalPrivacySettings(TLObject):
    DERIVED_OBJECTS = {0xbea2f424: globalPrivacySettings, 0xeb2b4cf6: account_getGlobalPrivacySettings, 0x1edaaac2: account_setGlobalPrivacySettings}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_countryCode(TLObject):
    ID = 0x4203c5ef
    def __init__(self, flags = None, country_code = None, prefixes = None, patterns = None):
        self.flags = flags
        self.country_code = country_code
        self.prefixes = prefixes
        self.patterns = patterns
    def __str__(self):
        return 'help_countryCode'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.country_code)
        flags = 0x0
        if self.prefixes:
            flags |= (1 << 0)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.prefixes))
            for vec_k_2 in self.prefixes:
                stream.pack_string(vec_k_2)
        if self.patterns:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.patterns))
            for vec_k_3 in self.patterns:
                stream.pack_string(vec_k_3)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.country_code = data.unpack_string()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.prefixes = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                self.prefixes.append(data.unpack_string())
        if flags.check_bit(1):
            self.patterns = list()
            data.unpack_int32()
            vector_2_size = data.unpack_int32()
            for vec_i_2 in range(vector_2_size):
                self.patterns.append(data.unpack_string())
        return self

class help_CountryCode(TLObject):
    DERIVED_OBJECTS = {0x4203c5ef: help_countryCode}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_country(TLObject):
    ID = 0xc3878e23
    def __init__(self, flags = None, hidden = None, iso2 = None, default_name = None, name = None, country_codes = None):
        self.flags = flags
        self.hidden = hidden
        self.iso2 = iso2
        self.default_name = default_name
        self.name = name
        self.country_codes = country_codes
    def __str__(self):
        return 'help_country'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.hidden:
            flags |= (1 << 0)
        stream.pack_string(self.iso2)
        stream.pack_string(self.default_name)
        if self.name:
            flags |= (1 << 1)
            stream.pack_string(self.name)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.country_codes))
        for vec_k_2 in self.country_codes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.hidden = True
        self.iso2 = data.unpack_string()
        self.default_name = data.unpack_string()
        if flags.check_bit(1):
            self.name = data.unpack_string()
        self.country_codes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = help_CountryCode()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.country_codes.append(elem_of_1_vec)
        return self

class help_Country(TLObject):
    DERIVED_OBJECTS = {0xc3878e23: help_country}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class help_countriesListNotModified(TLObject):
    ID = 0x93cc1f32
    def __init__(self):
        pass
    def __str__(self):
        return 'help_countriesListNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class help_countriesList(TLObject):
    ID = 0x87d0759e
    def __init__(self, countries = None, hash = None):
        self.countries = countries
        self.hash = hash
    def __str__(self):
        return 'help_countriesList'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.countries))
        for vec_k_2 in self.countries:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.countries = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = help_Country()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.countries.append(elem_of_1_vec)
        self.hash = data.unpack_int32()
        return self

class help_getCountriesList(TLObject):
    ID = 0x735787a8
    def __init__(self, lang_code = None, hash = None):
        self.lang_code = lang_code
        self.hash = hash
    def __str__(self):
        return 'help_getCountriesList'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_code)
        stream.pack_int32(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_code = data.unpack_string()
        self.hash = data.unpack_int32()
        return self

class help_CountriesList(TLObject):
    DERIVED_OBJECTS = {0x93cc1f32: help_countriesListNotModified, 0x87d0759e: help_countriesList, 0x735787a8: help_getCountriesList}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageViews(TLObject):
    ID = 0x455b853d
    def __init__(self, flags = None, views = None, forwards = None, replies = None):
        self.flags = flags
        self.views = views
        self.forwards = forwards
        self.replies = replies
    def __str__(self):
        return 'messageViews'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.views:
            flags |= (1 << 0)
            stream.pack_int32(self.views)
        if self.forwards:
            flags |= (1 << 1)
            stream.pack_int32(self.forwards)
        if self.replies:
            flags |= (1 << 2)
            stream.pack_bytes(self.replies.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.views = data.unpack_int32()
        if flags.check_bit(1):
            self.forwards = data.unpack_int32()
        if flags.check_bit(2):
            self.replies = MessageReplies()
            self.replies = self.replies.read(data)
        return self

class MessageViews(TLObject):
    DERIVED_OBJECTS = {0x455b853d: messageViews}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_messageViews(TLObject):
    ID = 0xb6c4f543
    def __init__(self, views = None, chats = None, users = None):
        self.views = views
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_messageViews'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.views))
        for vec_k_2 in self.views:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.views = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessageViews()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.views.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class messages_getMessagesViews(TLObject):
    ID = 0x5784d3e1
    def __init__(self, peer = None, id = None, increment = None):
        self.peer = peer
        self.id = id
        self.increment = increment
    def __str__(self):
        return 'messages_getMessagesViews'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_int32(vec_k_2)
        stream.pack_bytes(self.increment.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.id.append(data.unpack_int32())
        self.increment = Bool()
        self.increment = self.increment.read(data)
        return self

class messages_MessageViews(TLObject):
    DERIVED_OBJECTS = {0xb6c4f543: messages_messageViews, 0x5784d3e1: messages_getMessagesViews}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_discussionMessage(TLObject):
    ID = 0xa6341782
    def __init__(self, flags = None, messages = None, max_id = None, read_inbox_max_id = None, read_outbox_max_id = None, unread_count = None, chats = None, users = None):
        self.flags = flags
        self.messages = messages
        self.max_id = max_id
        self.read_inbox_max_id = read_inbox_max_id
        self.read_outbox_max_id = read_outbox_max_id
        self.unread_count = unread_count
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_discussionMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_bytes(vec_k_2.write())
        flags = 0x0
        if self.max_id:
            flags |= (1 << 0)
            stream.pack_int32(self.max_id)
        if self.read_inbox_max_id:
            flags |= (1 << 1)
            stream.pack_int32(self.read_inbox_max_id)
        if self.read_outbox_max_id:
            flags |= (1 << 2)
            stream.pack_int32(self.read_outbox_max_id)
        stream.pack_int32(self.unread_count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Message()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.messages.append(elem_of_1_vec)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.max_id = data.unpack_int32()
        if flags.check_bit(1):
            self.read_inbox_max_id = data.unpack_int32()
        if flags.check_bit(2):
            self.read_outbox_max_id = data.unpack_int32()
        self.unread_count = data.unpack_int32()
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class messages_getDiscussionMessage(TLObject):
    ID = 0x446972fd
    def __init__(self, peer = None, msg_id = None):
        self.peer = peer
        self.msg_id = msg_id
    def __str__(self):
        return 'messages_getDiscussionMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        return self

class messages_DiscussionMessage(TLObject):
    DERIVED_OBJECTS = {0xa6341782: messages_discussionMessage, 0x446972fd: messages_getDiscussionMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageReplyHeader(TLObject):
    ID = 0xa6d57763
    def __init__(self, flags = None, reply_to_msg_id = None, reply_to_peer_id = None, reply_to_top_id = None):
        self.flags = flags
        self.reply_to_msg_id = reply_to_msg_id
        self.reply_to_peer_id = reply_to_peer_id
        self.reply_to_top_id = reply_to_top_id
    def __str__(self):
        return 'messageReplyHeader'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.reply_to_msg_id)
        flags = 0x0
        if self.reply_to_peer_id:
            flags |= (1 << 0)
            stream.pack_bytes(self.reply_to_peer_id.write())
        if self.reply_to_top_id:
            flags |= (1 << 1)
            stream.pack_int32(self.reply_to_top_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.reply_to_msg_id = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.reply_to_peer_id = Peer()
            self.reply_to_peer_id = self.reply_to_peer_id.read(data)
        if flags.check_bit(1):
            self.reply_to_top_id = data.unpack_int32()
        return self

class MessageReplyHeader(TLObject):
    DERIVED_OBJECTS = {0xa6d57763: messageReplyHeader}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messageReplies(TLObject):
    ID = 0x83d60fc2
    def __init__(self, flags = None, comments = None, replies = None, replies_pts = None, recent_repliers = None, channel_id = None, max_id = None, read_max_id = None):
        self.flags = flags
        self.comments = comments
        self.replies = replies
        self.replies_pts = replies_pts
        self.recent_repliers = recent_repliers
        self.channel_id = channel_id
        self.max_id = max_id
        self.read_max_id = read_max_id
    def __str__(self):
        return 'messageReplies'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.comments:
            flags |= (1 << 0)
        stream.pack_int32(self.replies)
        stream.pack_int32(self.replies_pts)
        if self.recent_repliers:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.recent_repliers))
            for vec_k_2 in self.recent_repliers:
                stream.pack_bytes(vec_k_2.write())
        if self.channel_id:
            flags |= (1 << 0)
            stream.pack_int64(self.channel_id)
        if self.max_id:
            flags |= (1 << 2)
            stream.pack_int32(self.max_id)
        if self.read_max_id:
            flags |= (1 << 3)
            stream.pack_int32(self.read_max_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.comments = True
        self.replies = data.unpack_int32()
        self.replies_pts = data.unpack_int32()
        if flags.check_bit(1):
            self.recent_repliers = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = Peer()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.recent_repliers.append(elem_of_1_vec)
        if flags.check_bit(0):
            self.channel_id = data.unpack_int64()
        if flags.check_bit(2):
            self.max_id = data.unpack_int32()
        if flags.check_bit(3):
            self.read_max_id = data.unpack_int32()
        return self

class MessageReplies(TLObject):
    DERIVED_OBJECTS = {0x83d60fc2: messageReplies}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class peerBlocked(TLObject):
    ID = 0xe8fd8014
    def __init__(self, peer_id = None, date = None):
        self.peer_id = peer_id
        self.date = date
    def __str__(self):
        return 'peerBlocked'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer_id.write())
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer_id = Peer()
        self.peer_id = self.peer_id.read(data)
        self.date = data.unpack_int32()
        return self

class PeerBlocked(TLObject):
    DERIVED_OBJECTS = {0xe8fd8014: peerBlocked}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stats_messageStats(TLObject):
    ID = 0x8999f295
    def __init__(self, views_graph = None):
        self.views_graph = views_graph
    def __str__(self):
        return 'stats_messageStats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.views_graph.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.views_graph = StatsGraph()
        self.views_graph = self.views_graph.read(data)
        return self

class stats_getMessageStats(TLObject):
    ID = 0xb6e0a3f5
    def __init__(self, flags = None, dark = None, channel = None, msg_id = None):
        self.flags = flags
        self.dark = dark
        self.channel = channel
        self.msg_id = msg_id
    def __str__(self):
        return 'stats_getMessageStats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.dark:
            flags |= (1 << 0)
        stream.pack_bytes(self.channel.write())
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.dark = True
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        self.msg_id = data.unpack_int32()
        return self

class stats_MessageStats(TLObject):
    DERIVED_OBJECTS = {0x8999f295: stats_messageStats, 0xb6e0a3f5: stats_getMessageStats}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class groupCallDiscarded(TLObject):
    ID = 0x7780bcb4
    def __init__(self, id = None, access_hash = None, duration = None):
        self.id = id
        self.access_hash = access_hash
        self.duration = duration
    def __str__(self):
        return 'groupCallDiscarded'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.duration)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.duration = data.unpack_int32()
        return self

class groupCall(TLObject):
    ID = 0xd597650c
    def __init__(self, flags = None, join_muted = None, can_change_join_muted = None, join_date_asc = None, schedule_start_subscribed = None, can_start_video = None, record_video_active = None, id = None, access_hash = None, participants_count = None, title = None, stream_dc_id = None, record_start_date = None, schedule_date = None, unmuted_video_count = None, unmuted_video_limit = None, version = None):
        self.flags = flags
        self.join_muted = join_muted
        self.can_change_join_muted = can_change_join_muted
        self.join_date_asc = join_date_asc
        self.schedule_start_subscribed = schedule_start_subscribed
        self.can_start_video = can_start_video
        self.record_video_active = record_video_active
        self.id = id
        self.access_hash = access_hash
        self.participants_count = participants_count
        self.title = title
        self.stream_dc_id = stream_dc_id
        self.record_start_date = record_start_date
        self.schedule_date = schedule_date
        self.unmuted_video_count = unmuted_video_count
        self.unmuted_video_limit = unmuted_video_limit
        self.version = version
    def __str__(self):
        return 'groupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.join_muted:
            flags |= (1 << 1)
        if self.can_change_join_muted:
            flags |= (1 << 2)
        if self.join_date_asc:
            flags |= (1 << 6)
        if self.schedule_start_subscribed:
            flags |= (1 << 8)
        if self.can_start_video:
            flags |= (1 << 9)
        if self.record_video_active:
            flags |= (1 << 11)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        stream.pack_int32(self.participants_count)
        if self.title:
            flags |= (1 << 3)
            stream.pack_string(self.title)
        if self.stream_dc_id:
            flags |= (1 << 4)
            stream.pack_int32(self.stream_dc_id)
        if self.record_start_date:
            flags |= (1 << 5)
            stream.pack_int32(self.record_start_date)
        if self.schedule_date:
            flags |= (1 << 7)
            stream.pack_int32(self.schedule_date)
        if self.unmuted_video_count:
            flags |= (1 << 10)
            stream.pack_int32(self.unmuted_video_count)
        stream.pack_int32(self.unmuted_video_limit)
        stream.pack_int32(self.version)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(1):
            self.join_muted = True
        if flags.check_bit(2):
            self.can_change_join_muted = True
        if flags.check_bit(6):
            self.join_date_asc = True
        if flags.check_bit(8):
            self.schedule_start_subscribed = True
        if flags.check_bit(9):
            self.can_start_video = True
        if flags.check_bit(11):
            self.record_video_active = True
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        self.participants_count = data.unpack_int32()
        if flags.check_bit(3):
            self.title = data.unpack_string()
        if flags.check_bit(4):
            self.stream_dc_id = data.unpack_int32()
        if flags.check_bit(5):
            self.record_start_date = data.unpack_int32()
        if flags.check_bit(7):
            self.schedule_date = data.unpack_int32()
        if flags.check_bit(10):
            self.unmuted_video_count = data.unpack_int32()
        self.unmuted_video_limit = data.unpack_int32()
        self.version = data.unpack_int32()
        return self

class GroupCall(TLObject):
    DERIVED_OBJECTS = {0x7780bcb4: groupCallDiscarded, 0xd597650c: groupCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inputGroupCall(TLObject):
    ID = 0xd8aa840f
    def __init__(self, id = None, access_hash = None):
        self.id = id
        self.access_hash = access_hash
    def __str__(self):
        return 'inputGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        stream.pack_int64(self.access_hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        self.access_hash = data.unpack_int64()
        return self

class InputGroupCall(TLObject):
    DERIVED_OBJECTS = {0xd8aa840f: inputGroupCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class groupCallParticipant(TLObject):
    ID = 0xeba636fe
    def __init__(self, flags = None, muted = None, left = None, can_self_unmute = None, just_joined = None, versioned = None, min = None, muted_by_you = None, volume_by_admin = None, self_ = None, video_joined = None, peer = None, date = None, active_date = None, source = None, volume = None, about = None, raise_hand_rating = None, video = None, presentation = None):
        self.flags = flags
        self.muted = muted
        self.left = left
        self.can_self_unmute = can_self_unmute
        self.just_joined = just_joined
        self.versioned = versioned
        self.min = min
        self.muted_by_you = muted_by_you
        self.volume_by_admin = volume_by_admin
        self.self_ = self_
        self.video_joined = video_joined
        self.peer = peer
        self.date = date
        self.active_date = active_date
        self.source = source
        self.volume = volume
        self.about = about
        self.raise_hand_rating = raise_hand_rating
        self.video = video
        self.presentation = presentation
    def __str__(self):
        return 'groupCallParticipant'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.muted:
            flags |= (1 << 0)
        if self.left:
            flags |= (1 << 1)
        if self.can_self_unmute:
            flags |= (1 << 2)
        if self.just_joined:
            flags |= (1 << 4)
        if self.versioned:
            flags |= (1 << 5)
        if self.min:
            flags |= (1 << 8)
        if self.muted_by_you:
            flags |= (1 << 9)
        if self.volume_by_admin:
            flags |= (1 << 10)
        if self.self_:
            flags |= (1 << 12)
        if self.video_joined:
            flags |= (1 << 15)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.date)
        if self.active_date:
            flags |= (1 << 3)
            stream.pack_int32(self.active_date)
        stream.pack_int32(self.source)
        if self.volume:
            flags |= (1 << 7)
            stream.pack_int32(self.volume)
        if self.about:
            flags |= (1 << 11)
            stream.pack_string(self.about)
        if self.raise_hand_rating:
            flags |= (1 << 13)
            stream.pack_int64(self.raise_hand_rating)
        if self.video:
            flags |= (1 << 6)
            stream.pack_bytes(self.video.write())
        if self.presentation:
            flags |= (1 << 14)
            stream.pack_bytes(self.presentation.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.muted = True
        if flags.check_bit(1):
            self.left = True
        if flags.check_bit(2):
            self.can_self_unmute = True
        if flags.check_bit(4):
            self.just_joined = True
        if flags.check_bit(5):
            self.versioned = True
        if flags.check_bit(8):
            self.min = True
        if flags.check_bit(9):
            self.muted_by_you = True
        if flags.check_bit(10):
            self.volume_by_admin = True
        if flags.check_bit(12):
            self.self_ = True
        if flags.check_bit(15):
            self.video_joined = True
        self.peer = Peer()
        self.peer = self.peer.read(data)
        self.date = data.unpack_int32()
        if flags.check_bit(3):
            self.active_date = data.unpack_int32()
        self.source = data.unpack_int32()
        if flags.check_bit(7):
            self.volume = data.unpack_int32()
        if flags.check_bit(11):
            self.about = data.unpack_string()
        if flags.check_bit(13):
            self.raise_hand_rating = data.unpack_int64()
        if flags.check_bit(6):
            self.video = GroupCallParticipantVideo()
            self.video = self.video.read(data)
        if flags.check_bit(14):
            self.presentation = GroupCallParticipantVideo()
            self.presentation = self.presentation.read(data)
        return self

class GroupCallParticipant(TLObject):
    DERIVED_OBJECTS = {0xeba636fe: groupCallParticipant}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phone_groupCall(TLObject):
    ID = 0x9e727aad
    def __init__(self, call = None, participants = None, participants_next_offset = None, chats = None, users = None):
        self.call = call
        self.participants = participants
        self.participants_next_offset = participants_next_offset
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'phone_groupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.participants))
        for vec_k_2 in self.participants:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_string(self.participants_next_offset)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = GroupCall()
        self.call = self.call.read(data)
        self.participants = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = GroupCallParticipant()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.participants.append(elem_of_1_vec)
        self.participants_next_offset = data.unpack_string()
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class phone_getGroupCall(TLObject):
    ID = 0x41845db
    def __init__(self, call = None, limit = None):
        self.call = call
        self.limit = limit
    def __str__(self):
        return 'phone_getGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.limit = data.unpack_int32()
        return self

class phone_GroupCall(TLObject):
    DERIVED_OBJECTS = {0x9e727aad: phone_groupCall, 0x41845db: phone_getGroupCall}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phone_groupParticipants(TLObject):
    ID = 0xf47751b6
    def __init__(self, count = None, participants = None, next_offset = None, chats = None, users = None, version = None):
        self.count = count
        self.participants = participants
        self.next_offset = next_offset
        self.chats = chats
        self.users = users
        self.version = version
    def __str__(self):
        return 'phone_groupParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.participants))
        for vec_k_2 in self.participants:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_string(self.next_offset)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        stream.pack_int32(self.version)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.participants = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = GroupCallParticipant()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.participants.append(elem_of_1_vec)
        self.next_offset = data.unpack_string()
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        self.version = data.unpack_int32()
        return self

class phone_getGroupParticipants(TLObject):
    ID = 0xc558d8ab
    def __init__(self, call = None, ids = None, sources = None, offset = None, limit = None):
        self.call = call
        self.ids = ids
        self.sources = sources
        self.offset = offset
        self.limit = limit
    def __str__(self):
        return 'phone_getGroupParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.ids))
        for vec_k_2 in self.ids:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sources))
        for vec_k_3 in self.sources:
            stream.pack_int32(vec_k_3)
        stream.pack_string(self.offset)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.ids = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputPeer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.ids.append(elem_of_1_vec)
        self.sources = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            self.sources.append(data.unpack_int32())
        self.offset = data.unpack_string()
        self.limit = data.unpack_int32()
        return self

class phone_GroupParticipants(TLObject):
    DERIVED_OBJECTS = {0xf47751b6: phone_groupParticipants, 0xc558d8ab: phone_getGroupParticipants}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class inlineQueryPeerTypeSameBotPM(TLObject):
    ID = 0x3081ed9d
    def __init__(self):
        pass
    def __str__(self):
        return 'inlineQueryPeerTypeSameBotPM'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inlineQueryPeerTypePM(TLObject):
    ID = 0x833c0fac
    def __init__(self):
        pass
    def __str__(self):
        return 'inlineQueryPeerTypePM'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inlineQueryPeerTypeChat(TLObject):
    ID = 0xd766c50a
    def __init__(self):
        pass
    def __str__(self):
        return 'inlineQueryPeerTypeChat'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inlineQueryPeerTypeMegagroup(TLObject):
    ID = 0x5ec4be43
    def __init__(self):
        pass
    def __str__(self):
        return 'inlineQueryPeerTypeMegagroup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class inlineQueryPeerTypeBroadcast(TLObject):
    ID = 0x6334ee9a
    def __init__(self):
        pass
    def __str__(self):
        return 'inlineQueryPeerTypeBroadcast'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class InlineQueryPeerType(TLObject):
    DERIVED_OBJECTS = {0x3081ed9d: inlineQueryPeerTypeSameBotPM, 0x833c0fac: inlineQueryPeerTypePM, 0xd766c50a: inlineQueryPeerTypeChat, 0x5ec4be43: inlineQueryPeerTypeMegagroup, 0x6334ee9a: inlineQueryPeerTypeBroadcast}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_historyImport(TLObject):
    ID = 0x1662af0b
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'messages_historyImport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = data.unpack_int64()
        return self

class messages_initHistoryImport(TLObject):
    ID = 0x34090c3b
    def __init__(self, peer = None, file = None, media_count = None):
        self.peer = peer
        self.file = file
        self.media_count = media_count
    def __str__(self):
        return 'messages_initHistoryImport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.file.write())
        stream.pack_int32(self.media_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.file = InputFile()
        self.file = self.file.read(data)
        self.media_count = data.unpack_int32()
        return self

class messages_HistoryImport(TLObject):
    DERIVED_OBJECTS = {0x1662af0b: messages_historyImport, 0x34090c3b: messages_initHistoryImport}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_historyImportParsed(TLObject):
    ID = 0x5e0fb7b9
    def __init__(self, flags = None, pm = None, group = None, title = None):
        self.flags = flags
        self.pm = pm
        self.group = group
        self.title = title
    def __str__(self):
        return 'messages_historyImportParsed'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.pm:
            flags |= (1 << 0)
        if self.group:
            flags |= (1 << 1)
        if self.title:
            flags |= (1 << 2)
            stream.pack_string(self.title)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.pm = True
        if flags.check_bit(1):
            self.group = True
        if flags.check_bit(2):
            self.title = data.unpack_string()
        return self

class messages_checkHistoryImport(TLObject):
    ID = 0x43fe19f3
    def __init__(self, import_head = None):
        self.import_head = import_head
    def __str__(self):
        return 'messages_checkHistoryImport'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.import_head)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.import_head = data.unpack_string()
        return self

class messages_HistoryImportParsed(TLObject):
    DERIVED_OBJECTS = {0x5e0fb7b9: messages_historyImportParsed, 0x43fe19f3: messages_checkHistoryImport}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_affectedFoundMessages(TLObject):
    ID = 0xef8d3e6c
    def __init__(self, pts = None, pts_count = None, offset = None, messages = None):
        self.pts = pts
        self.pts_count = pts_count
        self.offset = offset
        self.messages = messages
    def __str__(self):
        return 'messages_affectedFoundMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.pts)
        stream.pack_int32(self.pts_count)
        stream.pack_int32(self.offset)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.pts = data.unpack_int32()
        self.pts_count = data.unpack_int32()
        self.offset = data.unpack_int32()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.messages.append(data.unpack_int32())
        return self

class messages_deletePhoneCallHistory(TLObject):
    ID = 0xf9cbe409
    def __init__(self, flags = None, revoke = None):
        self.flags = flags
        self.revoke = revoke
    def __str__(self):
        return 'messages_deletePhoneCallHistory'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.revoke:
            flags |= (1 << 0)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.revoke = True
        return self

class messages_AffectedFoundMessages(TLObject):
    DERIVED_OBJECTS = {0xef8d3e6c: messages_affectedFoundMessages, 0xf9cbe409: messages_deletePhoneCallHistory}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatInviteImporter(TLObject):
    ID = 0xb5cd5f4
    def __init__(self, user_id = None, date = None):
        self.user_id = user_id
        self.date = date
    def __str__(self):
        return 'chatInviteImporter'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.user_id)
        stream.pack_int32(self.date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.user_id = data.unpack_int64()
        self.date = data.unpack_int32()
        return self

class ChatInviteImporter(TLObject):
    DERIVED_OBJECTS = {0xb5cd5f4: chatInviteImporter}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_exportedChatInvites(TLObject):
    ID = 0xbdc62dcc
    def __init__(self, count = None, invites = None, users = None):
        self.count = count
        self.invites = invites
        self.users = users
    def __str__(self):
        return 'messages_exportedChatInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.invites))
        for vec_k_2 in self.invites:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.invites = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ExportedChatInvite()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.invites.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class messages_getExportedChatInvites(TLObject):
    ID = 0xa2b5a3f6
    def __init__(self, flags = None, revoked = None, peer = None, admin_id = None, offset_date = None, offset_link = None, limit = None):
        self.flags = flags
        self.revoked = revoked
        self.peer = peer
        self.admin_id = admin_id
        self.offset_date = offset_date
        self.offset_link = offset_link
        self.limit = limit
    def __str__(self):
        return 'messages_getExportedChatInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.revoked:
            flags |= (1 << 3)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.admin_id.write())
        if self.offset_date:
            flags |= (1 << 2)
            stream.pack_int32(self.offset_date)
        if self.offset_link:
            flags |= (1 << 2)
            stream.pack_string(self.offset_link)
        stream.pack_int32(self.limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(3):
            self.revoked = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.admin_id = InputUser()
        self.admin_id = self.admin_id.read(data)
        if flags.check_bit(2):
            self.offset_date = data.unpack_int32()
        if flags.check_bit(2):
            self.offset_link = data.unpack_string()
        self.limit = data.unpack_int32()
        return self

class messages_ExportedChatInvites(TLObject):
    DERIVED_OBJECTS = {0xbdc62dcc: messages_exportedChatInvites, 0xa2b5a3f6: messages_getExportedChatInvites}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_exportedChatInvite(TLObject):
    ID = 0x1871be50
    def __init__(self, invite = None, users = None):
        self.invite = invite
        self.users = users
    def __str__(self):
        return 'messages_exportedChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.invite.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.invite = ExportedChatInvite()
        self.invite = self.invite.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = User()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class messages_exportedChatInviteReplaced(TLObject):
    ID = 0x222600ef
    def __init__(self, invite = None, new_invite = None, users = None):
        self.invite = invite
        self.new_invite = new_invite
        self.users = users
    def __str__(self):
        return 'messages_exportedChatInviteReplaced'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.invite.write())
        stream.pack_bytes(self.new_invite.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_2 in self.users:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.invite = ExportedChatInvite()
        self.invite = self.invite.read(data)
        self.new_invite = ExportedChatInvite()
        self.new_invite = self.new_invite.read(data)
        self.users = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = User()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.users.append(elem_of_1_vec)
        return self

class messages_getExportedChatInvite(TLObject):
    ID = 0x73746f5c
    def __init__(self, peer = None, link = None):
        self.peer = peer
        self.link = link
    def __str__(self):
        return 'messages_getExportedChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.link)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.link = data.unpack_string()
        return self

class messages_editExportedChatInvite(TLObject):
    ID = 0x2e4ffbe
    def __init__(self, flags = None, revoked = None, peer = None, link = None, expire_date = None, usage_limit = None):
        self.flags = flags
        self.revoked = revoked
        self.peer = peer
        self.link = link
        self.expire_date = expire_date
        self.usage_limit = usage_limit
    def __str__(self):
        return 'messages_editExportedChatInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.revoked:
            flags |= (1 << 2)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.link)
        if self.expire_date:
            flags |= (1 << 0)
            stream.pack_int32(self.expire_date)
        if self.usage_limit:
            flags |= (1 << 1)
            stream.pack_int32(self.usage_limit)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(2):
            self.revoked = True
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.link = data.unpack_string()
        if flags.check_bit(0):
            self.expire_date = data.unpack_int32()
        if flags.check_bit(1):
            self.usage_limit = data.unpack_int32()
        return self

class messages_ExportedChatInvite(TLObject):
    DERIVED_OBJECTS = {0x1871be50: messages_exportedChatInvite, 0x222600ef: messages_exportedChatInviteReplaced, 0x73746f5c: messages_getExportedChatInvite, 0x2e4ffbe: messages_editExportedChatInvite}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_chatInviteImporters(TLObject):
    ID = 0x81b6b00a
    def __init__(self, count = None, importers = None, users = None):
        self.count = count
        self.importers = importers
        self.users = users
    def __str__(self):
        return 'messages_chatInviteImporters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.count)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.importers))
        for vec_k_2 in self.importers:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.count = data.unpack_int32()
        self.importers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ChatInviteImporter()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.importers.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class messages_getChatInviteImporters(TLObject):
    ID = 0x26fb7289
    def __init__(self, peer = None, link = None, offset_date = None, offset_user = None, limit = None):
        self.peer = peer
        self.link = link
        self.offset_date = offset_date
        self.offset_user = offset_user
        self.limit = limit
    def __str__(self):
        return 'messages_getChatInviteImporters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_string(self.link)
        stream.pack_int32(self.offset_date)
        stream.pack_bytes(self.offset_user.write())
        stream.pack_int32(self.limit)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.link = data.unpack_string()
        self.offset_date = data.unpack_int32()
        self.offset_user = InputUser()
        self.offset_user = self.offset_user.read(data)
        self.limit = data.unpack_int32()
        return self

class messages_ChatInviteImporters(TLObject):
    DERIVED_OBJECTS = {0x81b6b00a: messages_chatInviteImporters, 0x26fb7289: messages_getChatInviteImporters}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatAdminWithInvites(TLObject):
    ID = 0xf2ecef23
    def __init__(self, admin_id = None, invites_count = None, revoked_invites_count = None):
        self.admin_id = admin_id
        self.invites_count = invites_count
        self.revoked_invites_count = revoked_invites_count
    def __str__(self):
        return 'chatAdminWithInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.admin_id)
        stream.pack_int32(self.invites_count)
        stream.pack_int32(self.revoked_invites_count)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.admin_id = data.unpack_int64()
        self.invites_count = data.unpack_int32()
        self.revoked_invites_count = data.unpack_int32()
        return self

class ChatAdminWithInvites(TLObject):
    DERIVED_OBJECTS = {0xf2ecef23: chatAdminWithInvites}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_chatAdminsWithInvites(TLObject):
    ID = 0xb69b72d7
    def __init__(self, admins = None, users = None):
        self.admins = admins
        self.users = users
    def __str__(self):
        return 'messages_chatAdminsWithInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.admins))
        for vec_k_2 in self.admins:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_3 in self.users:
            stream.pack_bytes(vec_k_3.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.admins = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ChatAdminWithInvites()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.admins.append(elem_of_1_vec)
        self.users = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = User()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.users.append(elem_of_2_vec)
        return self

class messages_getAdminsWithInvites(TLObject):
    ID = 0x3920e6ef
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_getAdminsWithInvites'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class messages_ChatAdminsWithInvites(TLObject):
    DERIVED_OBJECTS = {0xb69b72d7: messages_chatAdminsWithInvites, 0x3920e6ef: messages_getAdminsWithInvites}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_checkedHistoryImportPeer(TLObject):
    ID = 0xa24de717
    def __init__(self, confirm_text = None):
        self.confirm_text = confirm_text
    def __str__(self):
        return 'messages_checkedHistoryImportPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.confirm_text)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.confirm_text = data.unpack_string()
        return self

class messages_checkHistoryImportPeer(TLObject):
    ID = 0x5dc60f03
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'messages_checkHistoryImportPeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class messages_CheckedHistoryImportPeer(TLObject):
    DERIVED_OBJECTS = {0xa24de717: messages_checkedHistoryImportPeer, 0x5dc60f03: messages_checkHistoryImportPeer}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phone_joinAsPeers(TLObject):
    ID = 0xafe5623f
    def __init__(self, peers = None, chats = None, users = None):
        self.peers = peers
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'phone_joinAsPeers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.peers))
        for vec_k_2 in self.peers:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = Peer()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.peers.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class phone_getGroupCallJoinAs(TLObject):
    ID = 0xef7c213a
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'phone_getGroupCallJoinAs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class phone_JoinAsPeers(TLObject):
    DERIVED_OBJECTS = {0xafe5623f: phone_joinAsPeers, 0xef7c213a: phone_getGroupCallJoinAs}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class phone_exportedGroupCallInvite(TLObject):
    ID = 0x204bd158
    def __init__(self, link = None):
        self.link = link
    def __str__(self):
        return 'phone_exportedGroupCallInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.link)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.link = data.unpack_string()
        return self

class phone_exportGroupCallInvite(TLObject):
    ID = 0xe6aa647f
    def __init__(self, flags = None, can_self_unmute = None, call = None):
        self.flags = flags
        self.can_self_unmute = can_self_unmute
        self.call = call
    def __str__(self):
        return 'phone_exportGroupCallInvite'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.can_self_unmute:
            flags |= (1 << 0)
        stream.pack_bytes(self.call.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.can_self_unmute = True
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        return self

class phone_ExportedGroupCallInvite(TLObject):
    DERIVED_OBJECTS = {0x204bd158: phone_exportedGroupCallInvite, 0xe6aa647f: phone_exportGroupCallInvite}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class groupCallParticipantVideoSourceGroup(TLObject):
    ID = 0xdcb118b7
    def __init__(self, semantics = None, sources = None):
        self.semantics = semantics
        self.sources = sources
    def __str__(self):
        return 'groupCallParticipantVideoSourceGroup'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.semantics)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sources))
        for vec_k_2 in self.sources:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.semantics = data.unpack_string()
        self.sources = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.sources.append(data.unpack_int32())
        return self

class GroupCallParticipantVideoSourceGroup(TLObject):
    DERIVED_OBJECTS = {0xdcb118b7: groupCallParticipantVideoSourceGroup}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class groupCallParticipantVideo(TLObject):
    ID = 0x67753ac8
    def __init__(self, flags = None, paused = None, endpoint = None, source_groups = None, audio_source = None):
        self.flags = flags
        self.paused = paused
        self.endpoint = endpoint
        self.source_groups = source_groups
        self.audio_source = audio_source
    def __str__(self):
        return 'groupCallParticipantVideo'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        flags = 0x0
        if self.paused:
            flags |= (1 << 0)
        stream.pack_string(self.endpoint)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.source_groups))
        for vec_k_2 in self.source_groups:
            stream.pack_bytes(vec_k_2.write())
        if self.audio_source:
            flags |= (1 << 1)
            stream.pack_int32(self.audio_source)
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.paused = True
        self.endpoint = data.unpack_string()
        self.source_groups = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = GroupCallParticipantVideoSourceGroup()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.source_groups.append(elem_of_1_vec)
        if flags.check_bit(1):
            self.audio_source = data.unpack_int32()
        return self

class GroupCallParticipantVideo(TLObject):
    DERIVED_OBJECTS = {0x67753ac8: groupCallParticipantVideo}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class stickers_suggestedShortName(TLObject):
    ID = 0x85fea03f
    def __init__(self, short_name = None):
        self.short_name = short_name
    def __str__(self):
        return 'stickers_suggestedShortName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.short_name)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.short_name = data.unpack_string()
        return self

class stickers_suggestShortName(TLObject):
    ID = 0x4dafc503
    def __init__(self, title = None):
        self.title = title
    def __str__(self):
        return 'stickers_suggestShortName'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.title)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.title = data.unpack_string()
        return self

class stickers_SuggestedShortName(TLObject):
    DERIVED_OBJECTS = {0x85fea03f: stickers_suggestedShortName, 0x4dafc503: stickers_suggestShortName}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class botCommandScopeDefault(TLObject):
    ID = 0x2f6cb2ab
    def __init__(self):
        pass
    def __str__(self):
        return 'botCommandScopeDefault'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class botCommandScopeUsers(TLObject):
    ID = 0x3c4f04d8
    def __init__(self):
        pass
    def __str__(self):
        return 'botCommandScopeUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class botCommandScopeChats(TLObject):
    ID = 0x6fe1a881
    def __init__(self):
        pass
    def __str__(self):
        return 'botCommandScopeChats'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class botCommandScopeChatAdmins(TLObject):
    ID = 0xb9aa606a
    def __init__(self):
        pass
    def __str__(self):
        return 'botCommandScopeChatAdmins'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class botCommandScopePeer(TLObject):
    ID = 0xdb9d897d
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'botCommandScopePeer'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class botCommandScopePeerAdmins(TLObject):
    ID = 0x3fd863d1
    def __init__(self, peer = None):
        self.peer = peer
    def __str__(self):
        return 'botCommandScopePeerAdmins'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        return self

class botCommandScopePeerUser(TLObject):
    ID = 0xa1321f3
    def __init__(self, peer = None, user_id = None):
        self.peer = peer
        self.user_id = user_id
    def __str__(self):
        return 'botCommandScopePeerUser'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_bytes(self.user_id.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.user_id = InputUser()
        self.user_id = self.user_id.read(data)
        return self

class BotCommandScope(TLObject):
    DERIVED_OBJECTS = {0x2f6cb2ab: botCommandScopeDefault, 0x3c4f04d8: botCommandScopeUsers, 0x6fe1a881: botCommandScopeChats, 0xb9aa606a: botCommandScopeChatAdmins, 0xdb9d897d: botCommandScopePeer, 0x3fd863d1: botCommandScopePeerAdmins, 0xa1321f3: botCommandScopePeerUser}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_resetPasswordFailedWait(TLObject):
    ID = 0xe3779861
    def __init__(self, retry_date = None):
        self.retry_date = retry_date
    def __str__(self):
        return 'account_resetPasswordFailedWait'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.retry_date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.retry_date = data.unpack_int32()
        return self

class account_resetPasswordRequestedWait(TLObject):
    ID = 0xe9effc7d
    def __init__(self, until_date = None):
        self.until_date = until_date
    def __str__(self):
        return 'account_resetPasswordRequestedWait'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.until_date)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.until_date = data.unpack_int32()
        return self

class account_resetPasswordOk(TLObject):
    ID = 0xe926d63e
    def __init__(self):
        pass
    def __str__(self):
        return 'account_resetPasswordOk'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_resetPassword(TLObject):
    ID = 0x9308ce1b
    def __init__(self):
        pass
    def __str__(self):
        return 'account_resetPassword'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_ResetPasswordResult(TLObject):
    DERIVED_OBJECTS = {0xe3779861: account_resetPasswordFailedWait, 0xe9effc7d: account_resetPasswordRequestedWait, 0xe926d63e: account_resetPasswordOk, 0x9308ce1b: account_resetPassword}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class chatTheme(TLObject):
    ID = 0xed0b5c33
    def __init__(self, emoticon = None, theme = None, dark_theme = None):
        self.emoticon = emoticon
        self.theme = theme
        self.dark_theme = dark_theme
    def __str__(self):
        return 'chatTheme'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.emoticon)
        stream.pack_bytes(self.theme.write())
        stream.pack_bytes(self.dark_theme.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.emoticon = data.unpack_string()
        self.theme = Theme()
        self.theme = self.theme.read(data)
        self.dark_theme = Theme()
        self.dark_theme = self.dark_theme.read(data)
        return self

class ChatTheme(TLObject):
    DERIVED_OBJECTS = {0xed0b5c33: chatTheme}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_chatThemesNotModified(TLObject):
    ID = 0xe011e1c4
    def __init__(self):
        pass
    def __str__(self):
        return 'account_chatThemesNotModified'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_chatThemes(TLObject):
    ID = 0xfe4cbebd
    def __init__(self, hash = None, themes = None):
        self.hash = hash
        self.themes = themes
    def __str__(self):
        return 'account_chatThemes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.hash)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.themes))
        for vec_k_2 in self.themes:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int32()
        self.themes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = ChatTheme()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.themes.append(elem_of_1_vec)
        return self

class account_getChatThemes(TLObject):
    ID = 0xd6d71d7b
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'account_getChatThemes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int32()
        return self

class account_ChatThemes(TLObject):
    DERIVED_OBJECTS = {0xe011e1c4: account_chatThemesNotModified, 0xfe4cbebd: account_chatThemes, 0xd6d71d7b: account_getChatThemes}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class sponsoredMessage(TLObject):
    ID = 0x2a3c381f
    def __init__(self, flags = None, random_id = None, from_id = None, start_param = None, message = None, entities = None):
        self.flags = flags
        self.random_id = random_id
        self.from_id = from_id
        self.start_param = start_param
        self.message = message
        self.entities = entities
    def __str__(self):
        return 'sponsoredMessage'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.random_id)
        stream.pack_bytes(self.from_id.write())
        flags = 0x0
        if self.start_param:
            flags |= (1 << 0)
            stream.pack_string(self.start_param)
        stream.pack_string(self.message)
        if self.entities:
            flags |= (1 << 1)
            stream.pack_int32(0x1cb5c415)
            stream.pack_int32(len(self.entities))
            for vec_k_2 in self.entities:
                stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        _byte_array = data
        _id = _byte_array[:4]
        _data = _byte_array[4:]
        data = bytes(_id + flags.to_bytes(4, byteorder='little') + _data)
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.flags = data.unpack_int32()
        self.random_id = data.unpack_string()
        self.from_id = Peer()
        self.from_id = self.from_id.read(data)
        flags = Flags(self.flags)
        if flags.check_bit(0):
            self.start_param = data.unpack_string()
        self.message = data.unpack_string()
        if flags.check_bit(1):
            self.entities = list()
            data.unpack_int32()
            vector_1_size = data.unpack_int32()
            for vec_i_1 in range(vector_1_size):
                elem_of_1_vec = MessageEntity()
                elem_of_1_vec = elem_of_1_vec.read(data)
                self.entities.append(elem_of_1_vec)
        return self

class SponsoredMessage(TLObject):
    DERIVED_OBJECTS = {0x2a3c381f: sponsoredMessage}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class messages_sponsoredMessages(TLObject):
    ID = 0x65a4c7d5
    def __init__(self, messages = None, chats = None, users = None):
        self.messages = messages
        self.chats = chats
        self.users = users
    def __str__(self):
        return 'messages_sponsoredMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.messages))
        for vec_k_2 in self.messages:
            stream.pack_bytes(vec_k_2.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.chats))
        for vec_k_3 in self.chats:
            stream.pack_bytes(vec_k_3.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.users))
        for vec_k_4 in self.users:
            stream.pack_bytes(vec_k_4.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.messages = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SponsoredMessage()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.messages.append(elem_of_1_vec)
        self.chats = list()
        data.unpack_int32()
        vector_2_size = data.unpack_int32()
        for vec_i_2 in range(vector_2_size):
            elem_of_2_vec = Chat()
            elem_of_2_vec = elem_of_2_vec.read(data)
            self.chats.append(elem_of_2_vec)
        self.users = list()
        data.unpack_int32()
        vector_3_size = data.unpack_int32()
        for vec_i_3 in range(vector_3_size):
            elem_of_3_vec = User()
            elem_of_3_vec = elem_of_3_vec.read(data)
            self.users.append(elem_of_3_vec)
        return self

class channels_getSponsoredMessages(TLObject):
    ID = 0xec210fbf
    def __init__(self, channel = None):
        self.channel = channel
    def __str__(self):
        return 'channels_getSponsoredMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.channel.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.channel = InputChannel()
        self.channel = self.channel.read(data)
        return self

class messages_SponsoredMessages(TLObject):
    DERIVED_OBJECTS = {0x65a4c7d5: messages_sponsoredMessages, 0xec210fbf: channels_getSponsoredMessages}
    def __init__(self):
        pass
    def read(self, data):
        if isinstance(data, bytes):
            packet_id = int.from_bytes(data[:4], byteorder='little')
        else:
            packet_id = int.from_bytes(data.serialize()[:4], byteorder='little')
        if packet_id not in self.DERIVED_OBJECTS:
            raise ValueError()
        tl_object = self.DERIVED_OBJECTS[packet_id]()
        return tl_object.read(data)

class account_getAllSecureValues(TLObject):
    ID = 0xb288bc7d
    def __init__(self):
        pass
    def __str__(self):
        return 'account_getAllSecureValues'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class account_getSecureValue(TLObject):
    ID = 0x73665bc2
    def __init__(self, types = None):
        self.types = types
    def __str__(self):
        return 'account_getSecureValue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.types))
        for vec_k_2 in self.types:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.types = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = SecureValueType()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.types.append(elem_of_1_vec)
        return self

class account_getMultiWallPapers(TLObject):
    ID = 0x65ad71dc
    def __init__(self, wallpapers = None):
        self.wallpapers = wallpapers
    def __str__(self):
        return 'account_getMultiWallPapers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.wallpapers))
        for vec_k_2 in self.wallpapers:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.wallpapers = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputWallPaper()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.wallpapers.append(elem_of_1_vec)
        return self

class users_getUsers(TLObject):
    ID = 0xd91a548
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'users_getUsers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputUser()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.id.append(elem_of_1_vec)
        return self

class contacts_getContactIDs(TLObject):
    ID = 0x7adc669d
    def __init__(self, hash = None):
        self.hash = hash
    def __str__(self):
        return 'contacts_getContactIDs'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int64(self.hash)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.hash = data.unpack_int64()
        return self

class contacts_getStatuses(TLObject):
    ID = 0xc4a353ee
    def __init__(self):
        pass
    def __str__(self):
        return 'contacts_getStatuses'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class contacts_getSaved(TLObject):
    ID = 0x82f1e39f
    def __init__(self):
        pass
    def __str__(self):
        return 'contacts_getSaved'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_receivedMessages(TLObject):
    ID = 0x5a954c0
    def __init__(self, max_id = None):
        self.max_id = max_id
    def __str__(self):
        return 'messages_receivedMessages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.max_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.max_id = data.unpack_int32()
        return self

class messages_receivedQueue(TLObject):
    ID = 0x55a5bb66
    def __init__(self, max_qts = None):
        self.max_qts = max_qts
    def __str__(self):
        return 'messages_receivedQueue'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(self.max_qts)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.max_qts = data.unpack_int32()
        return self

class messages_getAttachedStickers(TLObject):
    ID = 0xcc5b67cc
    def __init__(self, media = None):
        self.media = media
    def __str__(self):
        return 'messages_getAttachedStickers'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.media.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.media = InputStickeredMedia()
        self.media = self.media.read(data)
        return self

class messages_getSplitRanges(TLObject):
    ID = 0x1cff7e08
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_getSplitRanges'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_getDialogUnreadMarks(TLObject):
    ID = 0x22e24e22
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_getDialogUnreadMarks'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_getEmojiKeywordsLanguages(TLObject):
    ID = 0x4e9963b2
    def __init__(self, lang_codes = None):
        self.lang_codes = lang_codes
    def __str__(self):
        return 'messages_getEmojiKeywordsLanguages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.lang_codes))
        for vec_k_2 in self.lang_codes:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_codes = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.lang_codes.append(data.unpack_string())
        return self

class messages_getSearchCounters(TLObject):
    ID = 0x732eef00
    def __init__(self, peer = None, filters = None):
        self.peer = peer
        self.filters = filters
    def __str__(self):
        return 'messages_getSearchCounters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.filters))
        for vec_k_2 in self.filters:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.filters = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = MessagesFilter()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.filters.append(elem_of_1_vec)
        return self

class messages_getDialogFilters(TLObject):
    ID = 0xf19ed96d
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_getDialogFilters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_getSuggestedDialogFilters(TLObject):
    ID = 0xa29cd42c
    def __init__(self):
        pass
    def __str__(self):
        return 'messages_getSuggestedDialogFilters'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        return self

class messages_getMessageReadParticipants(TLObject):
    ID = 0x2c6f97b7
    def __init__(self, peer = None, msg_id = None):
        self.peer = peer
        self.msg_id = msg_id
    def __str__(self):
        return 'messages_getMessageReadParticipants'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.peer.write())
        stream.pack_int32(self.msg_id)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.peer = InputPeer()
        self.peer = self.peer.read(data)
        self.msg_id = data.unpack_int32()
        return self

class photos_deletePhotos(TLObject):
    ID = 0x87cf7f2f
    def __init__(self, id = None):
        self.id = id
    def __str__(self):
        return 'photos_deletePhotos'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.id))
        for vec_k_2 in self.id:
            stream.pack_bytes(vec_k_2.write())
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.id = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            elem_of_1_vec = InputPhoto()
            elem_of_1_vec = elem_of_1_vec.read(data)
            self.id.append(elem_of_1_vec)
        return self

class upload_reuploadCdnFile(TLObject):
    ID = 0x9b2754a8
    def __init__(self, file_token = None, request_token = None):
        self.file_token = file_token
        self.request_token = request_token
    def __str__(self):
        return 'upload_reuploadCdnFile'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.file_token)
        stream.pack_string(self.request_token)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file_token = data.unpack_string()
        self.request_token = data.unpack_string()
        return self

class upload_getCdnFileHashes(TLObject):
    ID = 0x4da54231
    def __init__(self, file_token = None, offset = None):
        self.file_token = file_token
        self.offset = offset
    def __str__(self):
        return 'upload_getCdnFileHashes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.file_token)
        stream.pack_int32(self.offset)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.file_token = data.unpack_string()
        self.offset = data.unpack_int32()
        return self

class upload_getFileHashes(TLObject):
    ID = 0xc7025931
    def __init__(self, location = None, offset = None):
        self.location = location
        self.offset = offset
    def __str__(self):
        return 'upload_getFileHashes'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.location.write())
        stream.pack_int32(self.offset)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.location = InputFileLocation()
        self.location = self.location.read(data)
        self.offset = data.unpack_int32()
        return self

class bots_getBotCommands(TLObject):
    ID = 0xe34c0dd6
    def __init__(self, scope = None, lang_code = None):
        self.scope = scope
        self.lang_code = lang_code
    def __str__(self):
        return 'bots_getBotCommands'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.scope.write())
        stream.pack_string(self.lang_code)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.scope = BotCommandScope()
        self.scope = self.scope.read(data)
        self.lang_code = data.unpack_string()
        return self

class phone_checkGroupCall(TLObject):
    ID = 0xb59cf977
    def __init__(self, call = None, sources = None):
        self.call = call
        self.sources = sources
    def __str__(self):
        return 'phone_checkGroupCall'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_bytes(self.call.write())
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.sources))
        for vec_k_2 in self.sources:
            stream.pack_int32(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.call = InputGroupCall()
        self.call = self.call.read(data)
        self.sources = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.sources.append(data.unpack_int32())
        return self

class langpack_getStrings(TLObject):
    ID = 0xefea3803
    def __init__(self, lang_pack = None, lang_code = None, keys = None):
        self.lang_pack = lang_pack
        self.lang_code = lang_code
        self.keys = keys
    def __str__(self):
        return 'langpack_getStrings'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_pack)
        stream.pack_string(self.lang_code)
        stream.pack_int32(0x1cb5c415)
        stream.pack_int32(len(self.keys))
        for vec_k_2 in self.keys:
            stream.pack_string(vec_k_2)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_pack = data.unpack_string()
        self.lang_code = data.unpack_string()
        self.keys = list()
        data.unpack_int32()
        vector_1_size = data.unpack_int32()
        for vec_i_1 in range(vector_1_size):
            self.keys.append(data.unpack_string())
        return self

class langpack_getLanguages(TLObject):
    ID = 0x42c6978f
    def __init__(self, lang_pack = None):
        self.lang_pack = lang_pack
    def __str__(self):
        return 'langpack_getLanguages'
    def write(self):
        stream = BinaryStream()
        stream.pack_int32(self.ID)
        stream.pack_string(self.lang_pack)
        data = stream.serialize()
        return data
    def read(self, data):
        if isinstance(data, bytes):
            data = BinaryStream(data)
        if data.unpack_int32() != self.ID:
            raise ValueError()
        self.lang_pack = data.unpack_string()
        return self

